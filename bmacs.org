#+TITLE: BMACS
#+AUTHOR: Bryan Gilbert
#+PROPERTY: header-args :tangle yes

* Configuration :PROPERTIES:
:VISIBILITY: children
:END:

** Table of Contents :TOC_3_gh:
- [[#configuration][Configuration]]
  - [[#about-this-file][About this file]]
  - [[#personal-information][Personal Information]]
  - [[#variables][Variables]]
    - [[#font][Font]]
    - [[#theme][Theme]]
    - [[#leader-keys][Leader Keys]]
    - [[#directories][Directories]]
    - [[#hooks][Hooks]]
    - [[#large-file-handling][Large File Handling]]
    - [[#misc][Misc]]
  - [[#security-settings][Security Settings]]
  - [[#emacs-initialization][Emacs Initialization]]
    - [[#initialization-settings][Initialization Settings]]
    - [[#initialize-and-add-package-sources][Initialize and Add Package Sources]]
    - [[#libraries][Libraries]]
  - [[#doom-macros][DOOM! Macros]]
    - [[#after][after!]]
    - [[#map][map!]]
    - [[#add-hook][add-hook!]]
    - [[#quiet][quiet!]]
    - [[#def-memoized][def-memoized!]]
    - [[#λ][λ!]]
    - [[#def-menu][def-menu!]]
  - [[#use-package-modifications][Use Package Modifications]]
  - [[#helper-functions][Helper Functions]]
  - [[#core-settings][Core Settings]]
    - [[#charset][Charset]]
    - [[#backups][Backups]]
    - [[#history][History]]
    - [[#ui][UI]]
    - [[#editor][Editor]]
    - [[#font-1][Font]]
    - [[#help][Help]]
    - [[#cool-doom-exit-messages][Cool doom exit messages]]
    - [[#various-settings][Various Settings]]
    - [[#file-locations][File Locations]]
    - [[#operating-system-specific][Operating System Specific]]
  - [[#core-packages][Core Packages]]
    - [[#which-key][which-key]]
    - [[#smartparens][smartparens]]
    - [[#ivy][Ivy]]
    - [[#evil][evil]]
    - [[#recentf][recentf]]
  - [[#completion][Completion]]
    - [[#swiper][swiper]]
    - [[#counsel][counsel]]
    - [[#smex][smex]]
    - [[#ivy-rich][ivy-rich]]
    - [[#ivy-hydra][ivy-hydra]]
    - [[#ivy-posframe-disabled][ivy-posframe (disabled)]]
    - [[#company][company]]
    - [[#comany-statistics][comany-statistics]]
    - [[#company-dict][company-dict]]
    - [[#company-box-disabled][company-box (disabled)]]
  - [[#workspaces--projects][Workspaces / Projects]]
    - [[#persp-mode][persp-mode]]
    - [[#projectile][projectile]]
  - [[#editing][Editing]]
    - [[#evil-1][evil]]
    - [[#hideshow][hideshow]]
    - [[#undo-tree][undo-tree]]
    - [[#expand-region][expand-region]]
    - [[#clean-aindent-mode][clean-aindent-mode]]
    - [[#iedit][iedit]]
    - [[#yasnippet][yasnippet]]
    - [[#yasnippet-snippets][yasnippet-snippets]]
    - [[#auto-yasnippet][auto-yasnippet]]
    - [[#flycheck][flycheck]]
    - [[#dtrt-indent-mode][dtrt-indent-mode]]
  - [[#git][Git]]
    - [[#magit][Magit]]
    - [[#gitconfig-mode][gitconfig-mode]]
    - [[#gitignore-mode][gitignore-mode]]
    - [[#git-gutter-fringe][git-gutter-fringe]]
    - [[#gist][gist]]
    - [[#git-timemachine][git-timemachine]]
    - [[#git-link][git-link]]
    - [[#evil-magit][evil-magit]]
    - [[#smerge][smerge]]
  - [[#ui-1][UI]]
    - [[#general][general]]
    - [[#all-the-icons][all-the-icons]]
    - [[#vi-tilde-fringe][vi-tilde-fringe]]
    - [[#doom-themes][doom-themes]]
    - [[#doom-dashboard][doom-dashboard]]
    - [[#doom-modeline][doom-modeline]]
    - [[#doom-quit][doom-quit]]
    - [[#evil-goggles][evil-goggles]]
    - [[#hl-todo][hl-todo]]
    - [[#nav-flash][nav-flash]]
    - [[#highlight-indentation][highlight-indentation]]
    - [[#highlight-numbers][highlight-numbers]]
    - [[#hl-line][hl-line]]
    - [[#rainbow-delimiters][rainbow-delimiters]]
    - [[#visual-fill-column][visual-fill-column]]
    - [[#nlinum-mode][nlinum-mode]]
    - [[#winner-mode][winner-mode]]
  - [[#navigation][Navigation]]
    - [[#ace-link][ace-link]]
    - [[#ace-window][ace-window]]
    - [[#avy][avy]]
    - [[#wgrep][wgrep]]
    - [[#dumb-jump][dumb-jump]]
  - [[#org-mode-needs-cleaning][Org Mode (Needs Cleaning)]]
    - [[#org][Org]]
    - [[#babel][Babel]]
    - [[#capture][Capture]]
    - [[#present][Present]]
  - [[#email-needs-cleaning][Email (Needs Cleaning)]]
    - [[#fix-mark-emails-in-region][Fix Mark Emails in Region]]
  - [[#tools][Tools]]
    - [[#restclient][Restclient]]
    - [[#dash-docs][Dash Docs]]
    - [[#dired][Dired]]
    - [[#eshell][EShell]]
    - [[#imenu][Imenu]]
    - [[#neotree][NeoTree]]
  - [[#programming-languages][Programming Languages]]
    - [[#assembly][Assembly]]
    - [[#cc][CC]]
    - [[#clojure][Clojure]]
    - [[#csharp][CSharp]]
    - [[#data--config-formats][Data + Config Formats]]
    - [[#elm][Elm]]
    - [[#emacs-lisp][Emacs-lisp]]
    - [[#go][Go]]
    - [[#haskell][Haskell]]
    - [[#hy][Hy]]
    - [[#java--android--groovy][Java / Android / Groovy]]
    - [[#javascript][Javascript]]
    - [[#julia][Julia]]
    - [[#lua][Lua]]
    - [[#markdown][Markdown]]
    - [[#ocaml][OCaml]]
    - [[#perl-disabled][Perl (Disabled)]]
    - [[#php][Php]]
    - [[#plant-uml][Plant Uml]]
    - [[#play-framework][Play Framework]]
    - [[#purescript][Purescript]]
    - [[#python][Python]]
    - [[#ruby][Ruby]]
    - [[#rust][Rust]]
    - [[#scala][Scala]]
    - [[#shell][Shell]]
    - [[#swift][Swift]]
    - [[#web][Web]]
  - [[#misc-1][Misc]]
    - [[#hydra][hydra]]
    - [[#command-log-mode][command-log-mode]]
  - [[#popup-rules][Popup Rules]]
  - [[#hydras][Hydras]]
    - [[#window-management][Window Management]]
    - [[#smerge-1][Smerge]]
    - [[#zoom][Zoom]]
  - [[#functions][Functions]]
    - [[#file-functions][File Functions]]
    - [[#buffer-functions][Buffer Functions]]
    - [[#window-functions][Window Functions]]
    - [[#counsel-project-bookmarks][Counsel Project Bookmarks]]
    - [[#random-functions][Random Functions]]
  - [[#keybindings][Keybindings]]
  - [[#post-init][Post Init]]
    - [[#run-post-init-hook][Run Post Init Hook]]
    - [[#web-browser][Web Browser]]
    - [[#indentation][Indentation]]
    - [[#adjust-fringe][Adjust Fringe]]
    - [[#update-faces][Update Faces]]
    - [[#mardown-open-comamnd][Mardown Open Comamnd]]
    - [[#fix-org-popups][Fix Org Popups]]
    - [[#start-profiling-debug][Start profiling (debug)]]

** About this file

This is Bryan Gilbert's personal Emacs configuration.

** Personal Information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Daniel Paschke"
      user-mail-address "paschdan@gmail.com"
      auth-sources (list (expand-file-name "~/.authinfo")))
#+END_SRC

** Variables

*** Font

#+BEGIN_SRC emacs-lisp
(defvar bmacs-font (font-spec :family "Iosevka" :size 24))
#+END_SRC

*** Theme

#+BEGIN_SRC emacs-lisp
(defvar doom-theme 'doom-one)
#+END_SRC

*** Leader Keys

Define the leader and local leader keys. These are the basis of most custom global and mode specific
keybindings.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar bmacs-leader-key "SPC"
    "The leader prefix key, for global commands.")

  (defvar bmacs-localleader-key "SPC m"
    "The localleader prefix key, for major-mode specific commands."))
#+END_SRC

*** Directories

We're going to define a number of directories that are used throughout this configuration to store
different types of files.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defvar bmacs-emacs-dir (expand-file-name user-emacs-directory)
    "The path to the emacs.d directory.")

  (defvar bmacs-local-dir (concat bmacs-emacs-dir ".local/")
    "Root directory for local Emacs files. Use this as permanent storage for files
  that are safe to share across systems (if this config is symlinked across
  several computers).")

  (defvar bmacs-host-dir (concat bmacs-local-dir "@" (system-name))
    "Directory for hostname-specific file storage. Used by `bmacs-etc-dir' and
  `bmacs-cache-dir'.")

  (defvar bmacs-etc-dir (concat bmacs-host-dir "/etc/")
    "Host-namespaced directory for non-volatile storage. These are not deleted or
  tampored with by BMACS functions. Use this for dependencies like servers or
  config files that are stable (i.e. it should be unlikely that you need to delete
  them if something goes wrong).")

  (defvar bmacs-cache-dir (concat bmacs-host-dir "/cache/")
    "Host-namespaced directory for volatile storage. Deleted when `bmacs/reset' is
  called. Use this for transient files that are generated on the fly like caches
  and temporary files. Anything that may need to be cleared if there are
  problems.")

  (defvar bmacs-packages-dir (concat bmacs-local-dir "packages/")
    "Where package.el and quelpa plugins (and their caches) are stored.")

  (defvar bmacs-custom-dir (concat bmacs-emacs-dir "custom/")
    "Where custom lisp files are stored")

  (dolist (dir (list bmacs-local-dir bmacs-etc-dir bmacs-cache-dir (expand-file-name "elpa" bmacs-packages-dir)))
    (unless (file-directory-p dir)
      (make-directory dir t))))
#+END_SRC

*** Hooks

#+BEGIN_SRC emacs-lisp
(defvar bmacs-post-init-hook nil
  "A list of hooks run after BMACS initialization is complete, and after
`bmacs-init-hook'.")

(defvar bmacs-escape-hook nil
  "A hook run after C-g is pressed (or ESC in normal mode, for evil users). Both
trigger `bmacs/escape'.

If any hook returns non-nil, all hooks after it are ignored.")

(defvar bmacs-init-ui-hook nil
  "List of hooks to run when the UI has been initialized.")

(defvar bmacs-load-theme-hook nil
  "Hook run when the theme (and font) is initialized (or reloaded
with `doom//reload-theme').")

#+END_SRC

*** Large File Handling

#+BEGIN_SRC emacs-lisp
(defvar bmacs-large-file-size 1
  "Size (in MB) above which the user will be prompted to open the file literally
to avoid performance issues. Opening literally means that no major or minor
modes are active and the buffer is read-only.")

(defvar bmacs-large-file-modes-list
  '(archive-mode tar-mode jka-compr git-commit-mode image-mode
    doc-view-mode doc-view-mode-maybe ebrowse-tree-mode pdf-view-mode)
  "Major modes that `bmacs/check-large-file' will ignore.")
#+END_SRC

*** Misc

#+BEGIN_SRC emacs-lisp
(defvar bmacs-popups '()
  "A list of popup matchers that determine if a popup can be escaped")
#+END_SRC

** Security Settings
Properly verify outgoing ssl connections.

#+BEGIN_SRC emacs-lisp
(setq gnutls-verify-error t
      tls-checktrust gnutls-verify-error
      tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"
                        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof")
      nsm-settings-file (expand-file-name "network-security.data" bmacs-cache-dir))
#+END_SRC

** Emacs Initialization

*** Initialization Settings

We're going to increase the gc-cons-threshold to a very high number to decrease the load time. We're
going to add a hook to reset this value after initialization

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))

(add-hook 'bmacs-post-init-hook #'(lambda () (setq gc-cons-threshold 16777216
                                                   gc-cons-percentage 0.1)))
#+END_SRC

Let's increase the =max-lisp-eval-depth= and =max-specpdl-size= to prevent exceeding recursion limits.

#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 50000)
(setq max-specpdl-size 10000)
#+END_SRC

Now, we're going to disable double-buffering to prevent stuttering.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC

Disable certain byte compiler warnings to cut down on the noise.

#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC

*** Initialize and Add Package Sources

Tell =use-package= to always defer loading packages unless explicitly told otherwise. This speeds up
initialization significantly as many packages are only loaded later when they are explicitly used.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-defer t
        use-package-verbose t)
#+END_SRC

We're using a custom directory to store our packages so we need to set =package-user-dir= to the
location we wan them stored. We're going to set the =load-path= ourselves and avoid calling
=(package-initilize)= (for performance reasons) so we need to set =package--init-file-ensured= to
tell =package.el= to not automatically call it on our behalf. Additionally we're setting
=package-enable-at-startup= so that packages will not automatically be loaded for us since
=use-package= will be handling that.


#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq package-user-dir (expand-file-name "elpa" bmacs-packages-dir)))

  (setq load-prefer-newer noninteractive
        package--init-file-ensured t
        package-enable-at-startup nil)
#+END_SRC

We're going to set the load path ourselves so that we don't have to call =package-initialize= at
runtime and incur a large performance hit.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t)))
    (add-to-list 'load-path bmacs-custom-dir))
#+END_SRC

Next we are going to require =package.el= and add our additional package archives, 'melpa' and 'org'.
Afterwards we need to initialize our packages and then ensure that =use-package= is installed, which
we promptly install if it's missing. Finally we load =use-package= and tell it to always install any
missing packages.

Note that this entire block is wrapped in =eval-when-compile=. The effect of this is to perform all
of the package initialization during compilation so that when byte compiled, all of this time consuming
code is skipped. This can be done because the result of byte compiling =use-package= statements results
in the macro being fully expanded at which point =use-package= isn't actually required any longer.

Since the code is automatically compiled during runtime, if the configuration hasn't already been
previously compiled manually then all of the package initialization will still take place at startup.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'package)

    (unless (assoc-default "melpa" package-archives)
      (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
    (unless (assoc-default "melpa-stable" package-archives)
      (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t))
    (unless (assoc-default "org" package-archives)
      (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))

    (setq package-pinned-packages
      '((evil . "melpa-stable")))

    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (require 'use-package)
    (setq use-package-always-ensure t))
#+END_SRC

Add the package directory =mu4e= to the load path.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e"))
#+END_SRC

*** Libraries

#+BEGIN_SRC emacs-lisp
(use-package async :demand t)
(use-package f :demand t)
(use-package subr-x :demand t :ensure nil)
(eval-when-compile (require 'cl-lib))
#+END_SRC

** DOOM! Macros

A set of fantastic macros written by [[https://github.com/hlissner][hlissner]]. There won't be much
documentation around these because the comments for each macro does a great job explaining their
function.

*** after!

#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC

*** map!

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun bmacs-enlist (exp)
    "Return EXP wrapped in a list, or as-is if already a list."
    (if (listp exp) exp (list exp)))

  (defun doom-unquote (exp)
    "Return EXP unquoted."
    (while (memq (car-safe exp) '(quote function))
      (setq exp (cadr exp)))
    exp)

  (defvar bmacs-evil-state-alist
    '((?n . normal)
      (?v . visual)
      (?i . insert)
      (?e . emacs)
      (?o . operator)
      (?m . motion)
      (?r . replace))
    "A list of cons cells that map a letter to a evil state symbol.")

  ;; Register keywords for proper indentation (see `map!')
  (put ':after        'lisp-indent-function 'defun)
  (put ':desc         'lisp-indent-function 'defun)
  (put ':leader       'lisp-indent-function 'defun)
  (put ':local        'lisp-indent-function 'defun)
  (put ':localleader  'lisp-indent-function 'defun)
  (put ':map          'lisp-indent-function 'defun)
  (put ':map*         'lisp-indent-function 'defun)
  (put ':mode         'lisp-indent-function 'defun)
  (put ':prefix       'lisp-indent-function 'defun)
  (put ':textobj      'lisp-indent-function 'defun)
  (put ':unless       'lisp-indent-function 'defun)
  (put ':when         'lisp-indent-function 'defun)

;; specials
  (defvar bmacs--keymaps nil)
  (defvar bmacs--prefix  nil)
  (defvar bmacs--defer   nil)
  (defvar bmacs--local   nil)

(defun bmacs--keybind-register (key desc &optional modes)
  "Register a description for KEY with `which-key' in MODES.

  KEYS should be a string in kbd format.
  DESC should be a string describing what KEY does.
  MODES should be a list of major mode symbols."
  (if modes
      (dolist (mode modes)
        (which-key-add-major-mode-key-based-replacements mode key desc))
    (which-key-add-key-based-replacements key desc)))

(defun bmacs--keyword-to-states (keyword)
  "Convert a KEYWORD into a list of evil state symbols.

For example, :nvi will map to (list 'normal 'visual 'insert). See
`bmacs-evil-state-alist' to customize this."
  (cl-loop for l across (substring (symbol-name keyword) 1)
           if (cdr (assq l bmacs-evil-state-alist))
             collect it
           else
             do (error "not a valid state: %s" l)))

(defmacro map! (&rest rest)
  "A nightmare of a key-binding macro that will use `evil-define-key*',
`define-key', `local-set-key' and `global-set-key' depending on context and
plist key flags (and whether evil is loaded or not). It was designed to make
binding multiple keys more concise, like in vim.

If evil isn't loaded, it will ignore evil-specific bindings.

States
    :n  normal
    :v  visual
    :i  insert
    :e  emacs
    :o  operator
    :m  motion
    :r  replace

    These can be combined (order doesn't matter), e.g. :nvi will apply to
    normal, visual and insert mode. The state resets after the following
    key=>def pair.

    If states are omitted the keybind will be global.

    This can be customized with `bmacs-evil-state-alist'.

    :textobj is a special state that takes a key and two commands, one for the
    inner binding, another for the outer.

Flags
    (:mode [MODE(s)] [...])    inner keybinds are applied to major MODE(s)
    (:map [KEYMAP(s)] [...])   inner keybinds are applied to KEYMAP(S)
    (:map* [KEYMAP(s)] [...])  same as :map, but deferred
    (:prefix [PREFIX] [...])   assign prefix to all inner keybindings
    (:after [FEATURE] [...])   apply keybinds when [FEATURE] loads
    (:local [...])             make bindings buffer local; incompatible with keymaps!

Conditional keybinds
    (:when [CONDITION] [...])
    (:unless [CONDITION] [...])

Example
    (map! :map magit-mode-map
          :m \"C-r\" 'do-something           ; assign C-r in motion state
          :nv \"q\" 'magit-mode-quit-window  ; assign to 'q' in normal and visual states
          \"C-x C-r\" 'a-global-keybind

          (:when IS-MAC
           :n \"M-s\" 'some-fn
           :i \"M-o\" (lambda (interactive) (message \"Hi\"))))"
  (let ((bmacs--keymaps bmacs--keymaps)
        (bmacs--prefix  bmacs--prefix)
        (bmacs--defer   bmacs--defer)
        (bmacs--local   bmacs--local)
        key def states forms desc modes)
    (while rest
      (setq key (pop rest))
      (cond
       ;; it's a sub expr
       ((listp key)
        (push (macroexpand `(map! ,@key)) forms))

       ;; it's a flag
       ((keywordp key)
        (cond ((eq key :leader)
               (push 'bmacs-leader-key rest)
               (setq key :prefix
                     desc "<leader>"))
              ((eq key :localleader)
               (push 'bmacs-localleader-key rest)
               (setq key :prefix
                     desc "<localleader>")))
        (pcase key
          (:when    (push `(if ,(pop rest)       ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
          (:unless  (push `(if (not ,(pop rest)) ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
          (:after   (push `(after! ,(pop rest)   ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
          (:desc    (setq desc (pop rest)))
          (:map*    (setq bmacs--defer t) (push :map rest))
          (:map
            (setq bmacs--keymaps (bmacs-enlist (pop rest))))
          (:mode
            (setq modes (bmacs-enlist (pop rest)))
            (unless bmacs--keymaps
              (setq bmacs--keymaps
                    (cl-loop for m in modes
                             collect (intern (format "%s-map" (symbol-name m)))))))
          (:textobj
            (let* ((key (pop rest))
                   (inner (pop rest))
                   (outer (pop rest)))
              (push (macroexpand `(map! (:map evil-inner-text-objects-map ,key ,inner)
                                        (:map evil-outer-text-objects-map ,key ,outer)))
                    forms)))
          (:prefix
            (let ((def (pop rest)))
              (setq bmacs--prefix `(vconcat ,bmacs--prefix (kbd ,def)))
              (when desc
                (push `(bmacs--keybind-register ,(key-description (eval bmacs--prefix))
                                                ,desc ',modes)
                      forms)
                (setq desc nil))))
          (:local
           (setq bmacs--local t))
          (_ ; might be a state bmacs--prefix
           (setq states (bmacs--keyword-to-states key)))))

       ;; It's a key-def pair
       ((or (stringp key)
            (characterp key)
            (vectorp key)
            (symbolp key))
        (unwind-protect
            (catch 'skip
              (when (symbolp key)
                (setq key `(kbd ,key)))
              (when (stringp key)
                (setq key (kbd key)))
              (when bmacs--prefix
                (setq key (append bmacs--prefix (list key))))
              (unless (> (length rest) 0)
                (user-error "map! has no definition for %s key" key))
              (setq def (pop rest))
              (when desc
                (push `(bmacs--keybind-register ,(key-description (eval key))
                                              ,desc ',modes)
                      forms))
              (cond ((and bmacs--local bmacs--keymaps)
                     (push `(lwarn 'bmacs-map :warning
                                   "Can't local bind '%s' key to a keymap; skipped"
                                   ,key)
                           forms)
                     (throw 'skip 'local))
                    ((and bmacs--keymaps states)
                     (dolist (keymap bmacs--keymaps)
                       (push `(,(if bmacs--defer 'evil-define-key 'evil-define-key*)
                               ',states ,keymap ,key ,def)
                             forms)))
                    (states
                     (dolist (state states)
                       (push `(define-key
                                ,(intern (format "evil-%s-state-%smap" state (if bmacs--local "local-" "")))
                                ,key ,def)
                             forms)))
                    (bmacs--keymaps
                     (dolist (keymap bmacs--keymaps)
                       (push `(define-key ,keymap ,key ,def) forms)))
                    (t
                     (push `(,(if bmacs--local 'local-set-key 'global-set-key) ,key ,def)
                           forms))))
          (setq states '()
                bmacs--local nil
                desc nil)))

       (t (user-error "Invalid key %s" key))))
    `(progn ,@(nreverse forms)))))
#+END_SRC

*** add-hook!
A macro that makes adding hooks easy

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defun bmacs--resolve-hook-forms (hooks)
    (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
             for hook in (bmacs-enlist (doom-unquote hooks))
             if (eq (car-safe hook) 'quote)
              collect (cadr hook)
             else if quoted-p
              collect hook
             else collect (intern (format "%s-hook" (symbol-name hook)))))

  (defvar bmacs--transient-counter 0)
  (defmacro add-transient-hook! (hook &rest forms)
    "Attaches transient forms to a HOOK.

  HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

  These forms will be evaluated once when that function/hook is first invoked,
  then it detaches itself."
    (declare (indent 1))
    (let ((append (eq (car forms) :after))
          (fn (intern (format "bmacs-transient-hook-%s" (cl-incf bmacs--transient-counter)))))
      `(when ,hook
         (fset ',fn
               (lambda (&rest _)
                 ,@forms
                 (cond ((functionp ,hook) (advice-remove ,hook #',fn))
                       ((symbolp ,hook)   (remove-hook ,hook #',fn)))
                 (unintern ',fn nil)))
         (cond ((functionp ,hook)
                (advice-add ,hook ,(if append :after :before) #',fn))
               ((symbolp ,hook)
                (add-hook ,hook #',fn ,append)))))))

(defmacro add-hook! (&rest args)
  "A convenience macro for `add-hook'. Takes, in order:

  1. Optional properties :local and/or :append, which will make the hook
     buffer-local or append to the list of hooks (respectively),
  2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
     a quoted hook variable or a quoted list of hook variables. If unquoted, the
     hooks will be resolved by appending -hook to each symbol.
  3. A function, list of functions, or body forms to be wrapped in a lambda.

Examples:
    (add-hook! 'some-mode-hook 'enable-something)
    (add-hook! some-mode '(enable-something and-another))
    (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
    (add-hook! (one-mode second-mode) 'enable-something)
    (add-hook! :append (one-mode second-mode) 'enable-something)
    (add-hook! :local (one-mode second-mode) 'enable-something)
    (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
    (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

Body forms can access the hook's arguments through the let-bound variable
`args'."
  (declare (indent defun) (debug t))
  (let ((hook-fn 'add-hook)
        append-p local-p)
    (while (keywordp (car args))
      (pcase (pop args)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq hook-fn 'remove-hook))))
    (let ((hooks (bmacs--resolve-hook-forms (pop args)))
          (funcs
           (let ((val (car args)))
             (if (memq (car-safe val) '(quote function))
                 (if (cdr-safe (cadr val))
                     (cadr val)
                   (list (cadr val)))
               (list args))))
          forms)
      (dolist (fn funcs)
        (setq fn (if (symbolp fn)
                     `(function ,fn)
                   `(lambda (&rest _) ,@args)))
        (dolist (hook hooks)
          (push (cond ((eq hook-fn 'remove-hook)
                       `(remove-hook ',hook ,fn ,local-p))
                      (t
                       `(add-hook ',hook ,fn ,append-p ,local-p)))
                forms)))
      `(progn ,@(nreverse forms)))))

(defmacro remove-hook! (&rest args)
  "Convenience macro for `remove-hook'. Takes the same arguments as
`add-hook!'."
  `(add-hook! :remove ,@args))
#+END_SRC

*** quiet!
A simple macro that prevents code from making any noise

#+BEGIN_SRC emacs-lisp
(defmacro quiet! (&rest forms)
  "Run FORMS without making any noise."
  `(if nil
       (progn ,@forms)
 (fset 'doom--old-write-region-fn (symbol-function 'write-region))
      (cl-letf ((standard-output (lambda (&rest _)))
                ((symbol-function 'load-file) (lambda (file) (load file nil t)))
                ((symbol-function 'message) (lambda (&rest _)))
                ((symbol-function 'write-region)
                 (lambda (start end filename &optional append visit lockname mustbenew)
                   (unless visit (setq visit 'no-message))
                   (doom--old-write-region-fn
                    start end filename append visit lockname mustbenew)))
                (inhibit-message t)
                (save-silently t))
        ,@forms)))
#+END_SRC

*** def-memoized!
Creates a memoized function

#+BEGIN_SRC emacs-lisp
(defvar doom-memoized-table (make-hash-table :test 'equal :size 10)
  "A lookup table containing memoized functions. The keys are argument lists,
and the value is the function's return value.")

(defun doom-memoize (name)
  "Memoizes an existing function. NAME is a symbol."
  (let ((func (symbol-function name)))
    (put name 'function-documentation
         (concat (documentation func) " (memoized)"))
    (fset name
          `(lambda (&rest args)
             (let ((key (cons ',name args)))
               (or (gethash key doom-memoized-table)
                   (puthash key (apply ',func args)
                            doom-memoized-table)))))))

(defmacro def-memoized! (name arglist &rest body)
  "Create a memoize'd function. NAME, ARGLIST, DOCSTRING and BODY
have the same meaning as in `defun'."
  (declare (indent defun) (doc-string 3))
  `(,(if (bound-and-true-p byte-compile-current-file)
         'with-no-warnings
       'progn)
     (defun ,name ,arglist ,@body)
     (doom-memoize ',name)))


#+END_SRC

*** λ!

#+BEGIN_SRC emacs-lisp
(defmacro λ! (&rest body)
  "A shortcut for inline interactive lambdas."
  (declare (doc-string 1))
  `(lambda () (interactive) ,@body))

#+END_SRC

*** def-menu!

#+BEGIN_SRC emacs-lisp
(defvar doom-menu-display-fn #'doom-menu-read-default
  "The method to use to prompt the user with the menu. This takes two arguments:
PROMPT (a string) and COMMAND (a list of command plists; see `def-menu!').")

(defvar-local doom-menu-last-command nil
  "TODO")

(defun doom-menu-read-default (prompt commands)
  "Default method for displaying a completion-select prompt."
  (completing-read prompt (mapcar #'car commands) nil nil nil nil (car doom-menu-last-command)))

(defun doom--menu-read (prompt commands)
  (if-let* ((choice (funcall doom-menu-display-fn prompt commands)))
      (assoc choice commands)
    (user-error "Aborted")))

(defun doom--menu-exec (plist)
  (save-selected-window
    (let ((command (plist-get plist :exec))
          (cwd     (plist-get plist :cwd)))
      (let ((default-directory
              (cond ((eq cwd t) (bmacs-project-root))
                    ((stringp cwd) cwd)
                    ((functionp cwd) (funcall cwd))
                    (t default-directory))))
        (cond ((stringp command)
               (let (buf)
                 (compile command)
                 (setq buf next-error-last-buffer)
                 (unless buf
                   (error "Couldn't create compilation buffer"))
                 (with-current-buffer buf
                   (setq header-line-format
                         (concat (propertize "$ " 'face 'font-lock-doc-face)
                                 (propertize command 'face 'font-lock-preprocessor-face))))))
              ((or (symbolp command)
                   (functionp command))
               (call-interactively command))
              ((and command (listp command))
               (eval command t))
              (t
               (error "Not a valid command: %s" command)))))))

(defmacro def-menu! (name desc commands &rest plist)
  "Defines a menu and returns a function symbol for invoking it.

A dispatcher is an interactive command named NAME (a symbol). When called, this
dispatcher prompts you to select a command to run. This list is filtered
depending on its properties. Each command is takes the form of:

  (DESCRIPTION :exec COMMAND &rest PROPERTIES)

PROPERTIES accepts the following properties:

  :when FORM
  :unless FORM
  :region BOOL
  :cwd BOOL|PATH|FUNCTION
  :project BOOL|PATH|FUNCTION

COMMAND can be a string (a shell command), a symbol (an elisp function) or a
lisp form.

`def-menu!'s PLIST supports the following properties:

  :prompt STRING"
  (declare (indent defun) (doc-string 2))
  (let ((commands-var (intern (format "%s-commands" name)))
        (prop-prompt (or (plist-get plist :prompt) "> "))
        (prop-sort   (plist-get plist :sort)))
    `(progn
       (defconst ,commands-var
         ,(if prop-sort
              `(cl-sort ,commands #'string-lessp :key #'car)
            commands)
         ,(format "Menu for %s" name))
       (defun ,name (arg command)
         ,(concat
           (if (stringp desc) (concat desc "\n\n"))
           "This is a command dispatcher. It will rerun the last command on\n"
           "consecutive executions. If ARG (universal argument) is non-nil\n"
           "then it always prompt you.")
         (declare (interactive-only t))
         (interactive
          (list current-prefix-arg
                (progn
                  (unless ,commands-var
                    (user-error "The '%s' menu is empty" ',name))
                  (doom--menu-read
                   ,prop-prompt
                   (or (cl-remove-if-not
                        (let ((project-root (bmacs-project-root)))
                          (lambda (cmd)
                            (let ((plist (cdr cmd)))
                              (and (cond ((not (plist-member plist :region)) t)
                                         ((plist-get plist :region) (use-region-p))
                                         (t (not (use-region-p))))
                                   (let ((when (plist-get plist :when))
                                         (unless (plist-get plist :unless))
                                         (project (plist-get plist :project)))
                                     (when (functionp project)
                                       (setq project (funcall project)))
                                     (or (or (not when) (eval when))
                                         (or (not unless) (not (eval unless)))
                                         (and (stringp project)
                                              (file-in-directory-p (or buffer-file-name default-directory)
                                                                   project-root))))))))
                        ,commands-var)
                       (user-error "No commands available here"))))))
         (doom--menu-exec
          (cdr (or (when arg doom-menu-last-command)
                   (setq doom-menu-last-command command)
                   (user-error "No command selected"))))))))
#+END_SRC

** Use Package Modifications

#+BEGIN_SRC emacs-lisp
(eval-and-compile
;;
;; Use-package modifications
;;

(autoload 'use-package "use-package-core" nil nil t)

;; Adds the :after-call custom keyword to `use-package' (and consequently,
;; `def-package!'). :after-call takes a symbol ro list of symbols. These symbols
;; can be functions to hook variables.
;;
;;   (use-package X :after-call find-file-hook)
;;
;; This will load X on the first invokation of `find-file-hook' (then it will
;; remove itself from the hook).
(defvar doom--deferred-packages-alist ())
(after! use-package-core
  (add-to-list 'use-package-deferring-keywords :after-call nil #'eq)

  (setq use-package-keywords
        (use-package-list-insert :after-call use-package-keywords :after))

  (defalias 'use-package-normalize/:after-call
    'use-package-normalize-symlist)

  (defun use-package-handler/:after-call (name-symbol _keyword hooks rest state)
    (let ((fn (intern (format "doom|transient-hook--load-%s" name-symbol)))
          (hooks (delete-dups hooks)))
      (if (plist-get state :demand)
          (use-package-process-keywords name rest state)
        (use-package-concat
         `((fset ',fn
                 (lambda (&rest _)
                   (require ',name-symbol)
                   (dolist (hook (cdr (assq ',name-symbol doom--deferred-packages-alist)))
                     (if (functionp hook)
                         (advice-remove hook #',fn)
                       (remove-hook hook #',fn)))
                   (map-delete doom--deferred-packages-alist ',name-symbol)
                   (fmakunbound ',fn))))
         (cl-mapcan (lambda (hook)
                      (if (functionp hook)
                          `((advice-add #',hook :before #',fn))
                        `((add-hook ',hook #',fn))))
                    hooks)
         `((map-put doom--deferred-packages-alist
                    ',name-symbol
                    '(,@hooks ,@(cdr (assq name-symbol doom--deferred-packages-alist)))))
         (use-package-process-keywords name rest state)))))))
#+END_SRC

** Helper Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs-project-root ()
  "Get the path to the root of your project.
If STRICT-P, return nil if no project was found, otherwise return
`default-directory'."
  (let (projectile-require-project-root)
    (projectile-project-root)))

(defun bmacs/escape ()
  "Run the `bmacs-escape-hook'."
  (interactive)
  (cond ((minibuffer-window-active-p (minibuffer-window))
         ;; quit the minibuffer if open.
         (abort-recursive-edit))
        ;; Run all escape hooks. If any returns non-nil, then stop there.
        ((run-hook-with-args-until-success 'bmacs-escape-hook))
        ;; don't abort macros
        ((or defining-kbd-macro executing-kbd-macro) nil)
        ;; Back to the default
        (t (keyboard-quit))))

(global-set-key [remap keyboard-quit] #'bmacs/escape)

(defun bmacs/backward-kill-to-bol-and-indent ()
  "Kill line to the first non-blank character. If invoked again
afterwards, kill line to beginning of line."
  (interactive)
  (let ((empty-line-p (save-excursion (beginning-of-line)
                                      (looking-at-p "[ \t]*$"))))
    (funcall #'evil-delete (point-at-bol) (point))
    (unless empty-line-p
      (indent-according-to-mode))))

(defun bmacs/backward-to-bol-or-indent ()
  "Jump between the indentation column (first non-whitespace character) and the
beginning of the line. The opposite of
`doom/forward-to-last-non-comment-or-eol'."
  (interactive)
  (let ((pos (point))
        (indent (save-excursion
                  (beginning-of-visual-line)
                  (skip-chars-forward " \t\r")
                  (point))))
    (cond ((or (> pos indent) (= pos (line-beginning-position)))
           (goto-char indent))
          ((<= pos indent)
           (beginning-of-visual-line)))))

(defun bmacs/forward-to-last-non-comment-or-eol ()
  "Jumps between the last non-blank, non-comment character in the line and the
true end of the line. The opposite of `doom/backward-to-bol-or-indent'."
  (interactive)
  (let ((eol (save-excursion (if visual-line-mode
                                 (end-of-visual-line)
                               (end-of-line))
                             (point))))
    (if (and (sp-point-in-comment) (not (= (point) eol)))
        (goto-char eol)
      (let* ((bol (save-excursion (beginning-of-visual-line) (point)))
             (boc (or (save-excursion
                        (if (not comment-use-syntax)
                            (progn
                              (goto-char bol)
                              (when (re-search-forward comment-start-skip eol t)
                                (or (match-end 1) (match-beginning 0))))
                          (goto-char eol)
                          (while (and (sp-point-in-comment)
                                      (> (point) bol))
                            (backward-char))
                          (skip-chars-backward " " bol)
                          (point)))
                      eol)))
        (cond ((= boc (point))
               (goto-char eol))
              ((/= bol boc)
               (goto-char boc)))))))
#+END_SRC

** Core Settings

*** Charset

Set UTF-8 as the default coding system

#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system        'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(setq locale-coding-system   'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
#+END_SRC

*** Backups

We don't make any backups of files. This is what git is for.

#+BEGIN_SRC emacs-lisp
(setq-default auto-save-default nil
              create-lockfiles nil
              make-backup-files nil)
#+END_SRC

*** History

Various history preservation settings settings
From http://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html:

#+BEGIN_SRC emacs-lisp
(setq savehist-file (concat bmacs-cache-dir "savehist")
      history-length 500
      savehist-save-minibuffer-history t
      savehist-autosave-interval nil ; save on kill only
      savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
      save-place-file (concat bmacs-cache-dir "saveplace"))

(savehist-mode +1)
(save-place-mode +1)
#+END_SRC

**** TODO Verify all the save/history settings

*** UI

**** Various Settings

#+BEGIN_SRC emacs-lisp
;; simple name in frame title
(setq frame-title-format '("%b – BMACS"))

(setq-default
  bidi-display-reordering nil         ; disable bidirectional text for tiny performance boost
  blink-matching-paren nil            ; don't blink--too distracting
  cursor-in-non-selected-windows nil  ; hide cursors in other windows
  display-line-numbers-width 3        ; minimum width used to display line numbers
  frame-inhibit-implied-resize t      ; prevent frames from automatically resizing themselves
  ;; remove continuation arrow on right fringe
  highlight-nonselected-windows nil   ; don't highlight selections in other windows
  fringe-indicator-alist (delq (assq 'continuation fringe-indicator-alist) fringe-indicator-alist)
  indicate-buffer-boundaries nil      ; don't indicate beginning and end of buffer in fringe
  indicate-empty-lines nil            ; don't indicate empty lines in fringe
  max-mini-window-height 0.3          ; maximum height for resizing mini windows
  mode-line-default-help-echo nil     ; disable mode-line mouseovers
  mouse-yank-at-point t               ; middle-click paste at point, not at click
  resize-mini-windows 'grow-only      ; Minibuffer resizing
  show-help-function nil              ; hide :help-echo text
  split-width-threshold 160           ; favor horizontal splits
  uniquify-buffer-name-style 'forward ; follow unix path style when creating unique buffer names
  use-dialog-box nil                  ; always avoid GUI
  visible-cursor nil                  ; don't make cursor 'very visible'
  x-stretch-cursor nil                ; don't add wide glyph under cursor

  jit-lock-defer-time nil             ; defer jit font locking slightly to [try to] improve Emacs performance
  ;; BMACS - improve cpu usage vs DOOM
  jit-lock-stealth-nice 0.5           ; pause time between fontify chunks
  jit-lock-stealth-time 1             ; time to wait before start of stealth fontify
  jit-lock-stealth-verbose nil        ; silence stealth fontification
  ;; `pos-tip' defaults
  pos-tip-internal-border-width 6     ; increase pos-tip width
  pos-tip-border-width 1              ; define border width
  ;; no beeping or blinking please
  ring-bell-function #'ignore         ; don't beep
  visible-bell nil)                   ; don't blink

  (fset #'yes-or-no-p #'y-or-n-p)     ; y/n instead of yes/no
#+END_SRC

**** Toolbar

Disable tooltips, menubar, and scroll bar.

#+BEGIN_SRC emacs-lisp
(tooltip-mode -1)
(menu-bar-mode -1)
(if (fboundp 'tool-bar-mode)   (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

**** Line numbers

Enable line numbers

#+BEGIN_SRC emacs-lisp
(defun bmacs|enable-line-numbers ()
  "Enables the display of line numbers, using `display-line-numbers' (in Emacs
26+) or `nlinum-mode'."
  (if (boundp 'display-line-numbers)
      (setq display-line-numbers t)
    (nlinum-mode +1)))

(defun bmacs|disable-line-numbers ()
  "Disable the display of line numbers."
  (if (boundp 'display-line-numbers)
      (setq display-line-numbers nil)
    (nlinum-mode -1)))

(add-hook 'prog-mode-hook #'bmacs|enable-line-numbers)
(add-hook 'text-mode-hook #'bmacs|enable-line-numbers)
(add-hook 'conf-mode-hook #'bmacs|enable-line-numbers)
#+END_SRC

**** Childframes

#+BEGIN_SRC emacs-lisp
(defun bmacs*fix-whitespace-mode-in-childframes (orig-fn &rest args)
  (let ((frame (apply orig-fn args)))
    (with-selected-frame frame
      (setq-local whitespace-style nil)
      frame)))
(advice-add #'company-box--make-frame :around #'bmacs*fix-whitespace-mode-in-childframes)
(advice-add #'posframe--create-posframe :around #'bmacs*fix-whitespace-mode-in-childframes)

;; ensure posframe cleans up after itself
(after! posframe
  ;; TODO Find a better place for this
  (defun bmacs|delete-posframe-on-escape ()
    (unless (frame-parameter (selected-frame) 'posframe-buffer)
      (cl-loop for frame in (frame-list)
               if (and (frame-parameter frame 'posframe-buffer)
                       (not (frame-visible-p frame)))
               do (delete-frame frame))
      (dolist (buffer (buffer-list))
        (let ((frame (buffer-local-value 'posframe--frame buffer)))
          (when (and frame (or (not (frame-live-p frame))
                               (not (frame-visible-p frame))))
            (posframe--kill-buffer buffer))))))
  (add-hook 'bmacs-escape-hook #'bmacs|delete-posframe-on-escape))
#+END_SRC

**** Hide Fringes

#+BEGIN_SRC emacs-lisp
(defun bmacs|no-fringes-in-minibuffer (&rest _)
  "Disable fringes in the minibuffer window."
  (set-window-fringes (minibuffer-window) 0 0 nil))
(add-hook! '(bmacs-init-ui-hook minibuffer-setup-hook window-configuration-change-hook)
  #'bmacs|no-fringes-in-minibuffer)

(defun bmacs|no-fringes-in-which-key-buffer (&rest _)
  (bmacs|no-fringes-in-minibuffer)
  (set-window-fringes (get-buffer-window which-key--buffer) 0 0 nil))
(advice-add 'which-key--show-buffer-side-window :after #'bmacs|no-fringes-in-which-key-buffer)
#+END_SRC

*** Editor

**** Bookmarks

#+BEGIN_SRC emacs-lisp
(setq-default
 bookmark-save-flag 1)  ; automatically save bookmarks after every change
#+END_SRC

**** Formatting

#+BEGIN_SRC emacs-lisp
(setq-default
 fill-column 100                  ; set line-wrapping column to 100
 word-wrap t                     ; enable word wrap so lines are wrapped at nearest space
 ;; TODO: Investigate these further
 truncate-lines t
 truncate-partial-width-windows 50)

#+END_SRC

**** Scrolling

#+BEGIN_SRC emacs-lisp
(setq-default
 scroll-conservatively 1001             ; always scroll to the point no matter how far away (don't recenter)
 scroll-margin 0                        ; don't automatically scroll to retain a margin
 scroll-preserve-screen-position t)     ; preserve point location on screen when scrolling
#+END_SRC

**** Whitespace

#+BEGIN_SRC emacs-lisp
(setq-default
 indent-tabs-mode nil         ; don't insert tabs by default
 require-final-newline t      ; ensure newline exists at end of file
 tab-always-indent t          ; always indent line when pressing TAB (don't add tab character)
 tab-width 2                  ; default tab width of 2 characters
 tabify-regexp "^\t* [ \t]+") ; only tabify initial whitespace when converting to tabifying

 ;; whitespace-mode
(setq-default
 whitespace-line-column fill-column
 whitespace-style
 '(face indentation tabs tab-mark spaces space-mark newline newline-mark trailing lines-tail)
 whitespace-display-mappings
 '((tab-mark ?\t [?› ?\t])
   (newline-mark ?\n [?¬ ?\n])
   (space-mark ?\  [?·] [?.])))
#+END_SRC

**** Large File Handling

#+BEGIN_SRC emacs-lisp
(defun bmacs/check-large-file ()
  "Check if the buffer's file is large (see `bmacs-large-file-size'). If so, ask
for confirmation to open it literally (read-only, disabled undo and in
fundamental-mode) for performance sake."
  (let* ((filename (buffer-file-name))
         (size (nth 7 (file-attributes filename))))
    (when (and (not (memq major-mode bmacs-large-file-modes-list))
               size (> size (* 1024 1024 bmacs-large-file-size))
               (y-or-n-p
                (format (concat "%s is a large file, open literally to "
                                "avoid performance issues?")
                        (file-relative-name filename))))
      (setq buffer-read-only t)
      (buffer-disable-undo)
      (fundamental-mode))))

(add-hook 'find-file-hook #'bmacs/check-large-file)
#+END_SRC

**** Auto Indent Pasted Code

#+BEGIN_SRC emacs-lisp
(defvar bmacs|yank-indent-threshold 1000 "don't auto indent over 1000 lines")

(defvar bmacs|indent-sensitive-modes '(conf-mode coffee-mode haml-mode python-mode slim-mode yaml-mode)
  "modes to limit auto indentation on")


(defmacro bmacs|advise-commands (advice-name commands class &rest body)
  "Apply advice named ADVICE-NAME to multiple COMMANDS.
  The body of the advice is in BODY."
  `(progn
     ,@(mapcar (lambda (command)
                 `(defadvice ,command
                      (,class ,(intern (format "%S-%s" command advice-name))
                              activate)
                    ,@body))
               commands)))

(defvar bmacs-indent-sensitive-modes '(conf-mode coffee-mode haml-mode python-mode slim-mode yaml-mode)
  "modes to limit auto indentation on")

(defun bmacs|yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) bmacs|yank-indent-threshold)
      (indent-region beg end nil)))

(bmacs|advise-commands
  "indent" (evil-paste-before evil-paste-after) around
  "If current mode is not one of bmacs-indent-sensitive-modes
  indent yanked text (with universal arg don't indent)."
  ad-do-it
  (evil-with-single-undo
    (if (and (not (equal '(4) (ad-get-arg 0)))
             (not (member major-mode bmacs-indent-sensitive-modes)) ;; TODO indent-sensitive-modes
             (derived-mode-p 'prog-mode))
        (let ((transient-mark-mode nil)
              (save-undo buffer-undo-list))
          (bmacs|yank-advised-indent-function (region-beginning)
                                                (region-end))))))
#+END_SRC

**** Misc

#+BEGIN_SRC emacs-lisp
(setq-default
 vc-follow-symlinks t                             ; automatically follow symlinks
 save-interprogram-paste-before-kill t)           ; save clipboard contents into kill-ring before replacing them
(global-auto-revert-mode -1)                      ; diable auto revert mode (don't revert changed buffers)
(show-paren-mode)                                 ; highlight matching parenthesis
(push '("/LICENSE$" . text-mode) auto-mode-alist) ; license files should be handled in text mode
#+END_SRC


*** Font

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :font bmacs-font)
#+END_SRC


*** Help

When opening a help window, always select that window afterwards and move focus to it.

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

*** Cool doom exit messages

Displays various "are you sure" messages when exiting emacs.

#+BEGIN_SRC emacs-lisp
(defun doom-quit-p (&optional prompt)
  "Return t if this session should be killed. Prompts the user for
confirmation."
  (or (yes-or-no-p (format "››› %s" (or prompt "Quit Emacs?")))
      (ignore (message "Aborted"))))
(setq confirm-kill-emacs nil)
(add-hook 'kill-emacs-query-functions #'doom-quit-p)
#+END_SRC

*** Various Settings

Various settings of varying importance.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (setq ad-redefinition-action 'accept))

(setq-default
 ad-redefinition-action 'accept          ; silence advised function warnings
 apropos-do-all t                        ; make `apropos' more useful
 compilation-always-kill t               ; kill compilation process before starting another
 compilation-ask-about-save nil          ; save all buffers on `compile'
 compilation-scroll-output t             ; scroll to end of compilation output
 confirm-nonexistent-file-or-buffer t    ; confirm nonexisting files/buffers when opening
 idle-update-delay 2                     ; update ui less often (performance)
 warning-minimum-level :error            ; don't show warnings only errors
 ;; keep the point out of the minibuffer
 minibuffer-prompt-properties '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
#+END_SRC

*** File Locations

Define various file locations to be used by emacs

#+BEGIN_SRC emacs-lisp
(setq-default
 bookmark-default-file        (concat bmacs-etc-dir "bookmarks")
 abbrev-file-name             (concat bmacs-local-dir "abbrev.el")
 auto-save-list-file-name     (concat bmacs-cache-dir "autosave")
 pcache-directory             (concat bmacs-cache-dir "pcache"))
#+END_SRC

*** Operating System Specific

**** Common

Variables that can be easily used to determine operating system type.

#+BEGIN_SRC emacs-lisp
(setq IS-LINUX (eq system-type 'gnu/linux)
      IS-MAC (eq system-type 'darwin))
#+END_SRC


**** Clipboard
Use shared system clipboard and don't stream visual changes to clipboard

#+BEGIN_SRC emacs-lisp
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
      select-enable-clipboard t
      select-enable-primary t)

(after! evil
  (advice-add #'evil-visual-update-x-selection :override #'ignore))
#+END_SRC

**** Linux

#+BEGIN_SRC emacs-lisp
(if IS-LINUX
  (setq x-gtk-use-system-tooltips nil))   ; don't use gtk
#+END_SRC

**** Mac

#+BEGIN_SRC emacs-lisp
(if IS-MAC
  (setq mac-command-modifier 'meta
        mac-option-modifier  'alt
        ;; sane trackpad/mouse scroll settings
        mac-redisplay-dont-reset-vscroll t
        mac-mouse-wheel-smooth-scroll nil
        mouse-wheel-scroll-amount '(5 ((shift) . 2))  ; one line at a time
        mouse-wheel-progressive-speed nil             ; don't accelerate scrolling
        ;; Curse Lion and its sudden but inevitable fullscreen mode!
        ;; NOTE Meaningless to railwaycat's emacs-mac build
        ns-use-native-fullscreen nil
        ;; Don't open files from the workspace in a new frame
        ns-pop-up-frames nil)

  (cond ((display-graphic-p)
         ;; A known problem with GUI Emacs on MacOS: it runs in an isolated
         ;; environment, so envvars will be wrong. That includes the PATH
         ;; Emacs picks up. `exec-path-from-shell' fixes this. This is slow
         ;; and benefits greatly from compilation.
         (setq exec-path
               (or (eval-when-compile
                     (when (require 'exec-path-from-shell nil t)
                       (setq exec-path-from-shell-check-startup-files nil
                             exec-path-from-shell-arguments (delete "-i" exec-path-from-shell-arguments))
                       (nconc exec-path-from-shell-variables '("GOPATH" "GOROOT" "PYTHONPATH"))
                       (exec-path-from-shell-initialize)
                       exec-path))
                   exec-path)))
        (t
         (when (require 'osx-clipboard nil t)
           (osx-clipboard-mode +1)))))
#+END_SRC

** Core Packages

*** which-key

Dynamically show keybinding options.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :demand t
  :config
  (setq which-key-sort-order #'which-key-prefix-then-key-order
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 5)
  ;; embolden local bindings
  (set-face-attribute 'which-key-local-map-description-face nil :weight 'bold)
  (which-key-setup-side-window-bottom)
  (which-key-mode))
#+END_SRC

*** smartparens

Auto-close delimiters and blocks as you type.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :demand t
  :config
  (setq sp-autowrap-region nil) ; let evil-surround handle this

  (require 'smartparens-config)

  ;; disable smartparens in evil-mode's replace state (they conflict)
  (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
  (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode)

  (sp-local-pair '(xml-mode nxml-mode php-mode) "<!--" "-->"
                 :post-handlers '(("| " "SPC")))

  ;; disable global pairing for `
  (sp-pair "`" nil :actions :rem)

  (smartparens-global-mode))
#+END_SRC

*** Ivy
They power and the glory! Generic complete anything frontend

**** Functions

#+BEGIN_SRC emacs-lisp
(defun +ivy/wgrep-occur ()
  "Invoke the search+replace wgrep buffer on the current ag/rg search results."
  (interactive)
  (unless (window-minibuffer-p)
    (user-error "No completion session is active"))
  (require 'wgrep)
  (let* ((caller (ivy-state-caller ivy-last))
         (occur-fn (plist-get ivy--occurs-list caller))
         (buffer
          (generate-new-buffer
           (format "*ivy-occur%s \"%s\"*"
                   (if caller (concat " " (prin1-to-string caller)) "")
                   ivy-text))))
    (with-current-buffer buffer
      (let ((inhibit-read-only t))
        (erase-buffer)
        (funcall occur-fn))
      (setf (ivy-state-text ivy-last) ivy-text)
      (setq ivy-occur-last ivy-last)
      (setq-local ivy--directory ivy--directory))
    (ivy-exit-with-action
     `(lambda (_)
        (pop-to-buffer ,buffer)
        (ivy-wgrep-change-to-wgrep-mode)))))

(defun +ivy--tasks-candidates (tasks)
  "Generate a list of task tags (specified by `+ivy-task-tags') for
`+ivy/tasks'."
  (let* ((max-type-width
          (cl-loop for task in +ivy-task-tags maximize (length (car task))))
         (max-desc-width
          (cl-loop for task in tasks maximize (length (cl-cdadr task))))
         (max-width (max (- (frame-width) (1+ max-type-width) max-desc-width)
                         25)))
    (cl-loop
     with fmt = (format "%%-%ds %%-%ds%%s%%s:%%s" max-type-width max-width)
     for alist in tasks
     collect
     (let-alist alist
       (format fmt
               (propertize .type 'face (cdr (assoc .type +ivy-task-tags)))
               (substring .desc 0 (min max-desc-width (length .desc)))
               (propertize " | " 'face 'font-lock-comment-face)
               (propertize (abbreviate-file-name .file) 'face 'font-lock-keyword-face)
               (propertize .line 'face 'font-lock-constant-face))))))

(defun +ivy--tasks (target)
  (let* (case-fold-search
         (task-tags (mapcar #'car +ivy-task-tags))
         (cmd
          (format "%s -H -S --no-heading -- %s %s"
                  (or (when-let* ((bin (executable-find "rg")))
                        (concat bin " --line-number"))
                      (when-let* ((bin (executable-find "ag")))
                        (concat bin " --numbers"))
                      (error "ripgrep & the_silver_searcher are unavailable"))
                  (shell-quote-argument
                   (concat "\\s("
                           (string-join task-tags "|")
                           ")([\\s:]|\\([^)]+\\):?)"))
                  target)))
    (save-match-data
      (cl-loop with out = (shell-command-to-string cmd)
               for x in (and out (split-string out "\n" t))
               when (condition-case-unless-debug ex
                      (string-match
                       (concat "^\\([^:]+\\):\\([0-9]+\\):.+\\("
                               (string-join task-tags "\\|")
                               "\\):?\\s-*\\(.+\\)")
                       x)
                      (error
                       (print! (red "Error matching task in file: (%s) %s"
                                    (error-message-string ex)
                                    (car (split-string x ":"))))
                       nil))
               collect `((type . ,(match-string 3 x))
                         (desc . ,(match-string 4 x))
                         (file . ,(match-string 1 x))
                         (line . ,(match-string 2 x)))))))

(defun +ivy--tasks-open-action (x)
  "Jump to the file and line of the current task."
  (let ((location (cadr (split-string x " | ")))
        (type (car (split-string x " "))))
    (cl-destructuring-bind (file line) (split-string location ":")
      (with-ivy-window
        (find-file (expand-file-name file (doom-project-root)))
        (goto-char (point-min))
        (forward-line (1- (string-to-number line)))
        (search-forward type (line-end-position) t)
        (backward-char (length type))
        (recenter)))))

(defun +ivy/tasks (&optional arg)
  "Search through all TODO/FIXME tags in the current project. If ARG, only
search current file. See `+ivy-task-tags' to customize what this searches for."
  (interactive "P")
  (ivy-read (format "Tasks (%s): "
                    (if arg
                        (concat "in: " (file-relative-name buffer-file-name))
                      "project"))
            (+ivy--tasks-candidates
             (+ivy--tasks (if arg buffer-file-name (doom-project-root))))
            :action #'+ivy--tasks-open-action
            :caller '+ivy/tasks))

(defun +ivy-git-grep-other-window-action (x)
  "Opens the current candidate in another window."
  (when (string-match "\\`\\(.*?\\):\\([0-9]+\\):\\(.*\\)\\'" x)
    (select-window
     (with-ivy-window
       (let ((file-name   (match-string-no-properties 1 x))
             (line-number (match-string-no-properties 2 x)))
         (find-file-other-window (expand-file-name file-name (ivy-state-directory ivy-last)))
         (goto-char (point-min))
         (forward-line (1- (string-to-number line-number)))
         (re-search-forward (ivy--regex ivy-text t) (line-end-position) t)
         (run-hooks 'counsel-grep-post-action-hook)
         (selected-window))))))

(defun +ivy-buffer-transformer (str)
  "Dim special buffers, buffers whose file aren't in the current buffer, and
virtual buffers. Uses `ivy-rich' under the hood."
  (let ((buf (get-buffer str)))
    (require 'ivy-rich)
    (cond (buf (ivy-rich-switch-buffer-transformer str))
          ((and (eq ivy-virtual-abbreviate 'full)
                ivy-rich-switch-buffer-align-virtual-buffer)
           (ivy-rich-switch-buffer-virtual-buffer str))
          ((eq ivy-virtual-abbreviate 'full)
           (propertize (abbreviate-file-name str) 'str 'ivy-virtual))
          (t (propertize str 'face 'ivy-virtual)))))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :after-call pre-command-hook
  :config
  (setq ivy-height 15                                  ; slightly longer ivy completions list
        ivy-wrap t                                     ; wrap around at end of completions list
        ivy-fixed-height-minibuffer t                  ; use consistent height for ivy
        projectile-completion-system 'ivy              ; use ivy for projectile
        smex-completion-method 'ivy                    ; use ivy for smex
        ivy-initial-inputs-alist nil                   ; don't use ^ as initial input
        ivy-format-function #'ivy-format-function-line ; highlight til EOL
        ivy-use-virtual-buffers nil                    ; dont' show recent files in switch-buffer
        ivy-virtual-abbreviate 'full                   ; show full path if showing virtual buffer
        ivy-magic-slash-non-match-action nil           ; disable magic slash on non-match
        ivy-on-del-error-function nil                  ; don't quit minibuffer on delete-error
        ivy-use-selectable-prompt t)                   ; allow input prompt value to be selectable

  (map! [remap switch-to-buffer]       #'ivy-switch-buffer
        [remap persp-switch-to-buffer] #'counsel-projectile-switch-to-buffer
        [remap imenu-anywhere]         #'ivy-imenu-anywhere)

  ;; (after! ivy-rich
  ;;   (dolist (cmd '(ivy-switch-buffer +ivy/switch-workspace-buffer
  ;;                  counsel-projectile-switch-to-buffer))
  ;;     (ivy-set-display-transformer cmd '+ivy-buffer-transformer)))

  (after! magit     (setq magit-completing-read-function #'ivy-completing-read))
  (after! yasnippet (add-to-list 'yas-prompt-functions #'+ivy-yas-prompt nil #'eq))

  (ivy-mode +1))
#+END_SRC

*** evil

Like vim but better.

**** Functions

#+BEGIN_SRC emacs-lisp
(defvar +evil--flag nil)

(defun +evil--ex-match-init (name &optional face update-hook)
  (with-current-buffer evil-ex-current-buffer
    (cond
     ((eq +evil--flag 'start)
      (evil-ex-make-hl name
        :face (or face 'evil-ex-substitute-matches)
        :update-hook (or update-hook #'evil-ex-pattern-update-ex-info))
      (setq +evil--flag 'update))

     ((eq +evil--flag 'stop)
      (evil-ex-delete-hl name)))))

(defun +evil--ex-buffer-match (arg &optional hl-name flags beg end)
  (when (and (eq +evil--flag 'update)
             evil-ex-substitute-highlight-all
             (not (zerop (length arg))))
    (condition-case lossage
        (let ((pattern (evil-ex-make-substitute-pattern
                        arg
                        (or flags (list))))
              (range (or (evil-copy-range evil-ex-range)
                         (evil-range (or beg (line-beginning-position))
                                     (or end (line-end-position))
                                     'line
                                     :expanded t))))
          (evil-expand-range range)
          (evil-ex-hl-set-region hl-name
                                 (max (evil-range-beginning range) (window-start))
                                 (min (evil-range-end range) (window-end)))
          (evil-ex-hl-change hl-name pattern))
      (end-of-file
       (evil-ex-pattern-update-ex-info nil "incomplete replacement"))
      (user-error
       (evil-ex-pattern-update-ex-info nil (format "?%s" lossage))))))

(defun +evil-ex-buffer-match (flag &optional arg)
  (let ((hl-name 'evil-ex-buffer-match)
        (+evil--flag flag))
    (with-selected-window (minibuffer-selected-window)
      (+evil--ex-match-init hl-name)
      (+evil--ex-buffer-match arg hl-name (list (if evil-ex-substitute-global ?g))))))

(defun +evil-ex-global-match (flag &optional arg)
  (let ((hl-name 'evil-ex-global-match)
        (+evil--flag flag))
    (with-selected-window (minibuffer-selected-window)
      (+evil--ex-match-init hl-name)
      (+evil--ex-buffer-match arg hl-name nil (point-min) (point-max)))))

(defun +evil-ex-global-delim-match (flag &optional arg)
  (let ((hl-name 'evil-ex-global-delim-match)
        (+evil--flag flag))
    (with-selected-window (minibuffer-selected-window)
      (+evil--ex-match-init hl-name)
      (let ((result (car-safe (evil-delimited-arguments arg 2))))
        (+evil--ex-buffer-match result hl-name nil (point-min) (point-max))))))

(defun +evil/visual-indent ()
  (interactive)
  (evil-shift-right (region-beginning) (region-end))
  (evil-normal-state)
  (evil-visual-restore))

(defun +evil/visual-dedent ()
  (interactive)
  (evil-shift-left (region-beginning) (region-end))
  (evil-normal-state)
  (evil-visual-restore))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package evil
  :demand t
  :init
  (setq evil-want-C-u-scroll t                  ; C-u scrolls up
        evil-want-visual-char-semi-exclusive t  ; don't include new line in visual selection
        evil-want-Y-yank-to-eol t               ; 'Y' yanks to end of line
        evil-echo-state t                       ; signal current state in echo area
        evil-indent-convert-tabs t              ; automatically convert tabs or spaces to desired type
        evil-magic t                            ; use vim patterns in search
        evil-ex-search-vim-style-regexp t       ; support vim style backslash codes
        evil-ex-substitute-global t             ; global substitute patterns
        evil-ex-visual-char-range t             ; column range for ex commands
        evil-mode-line-format 'nil              ; don't have evil show modeline tag
        evil-symbol-word-search t               ; more vim-like behavior
        shift-select-mode nil                   ; don't activate mark on shift-click
        evil-default-cursor '+evil-default-cursor
        evil-normal-state-cursor 'box
        evil-emacs-state-cursor  '(box +evil-emacs-cursor)
        evil-insert-state-cursor 'bar
        evil-visual-state-cursor 'hollow)

  :config
  (add-hook 'bmacs-post-init-hook #'evil-mode)
  ;; use evil-search for searching
  (evil-select-search-module 'evil-search-module 'evil-search)

  ;; Change the cursor color in emacs mode
  (defvar +evil--default-cursor-color "#ffffff")
  (defun +evil-default-cursor () (set-cursor-color +evil--default-cursor-color))
  (defun +evil-emacs-cursor ()   (set-cursor-color (face-foreground 'warning)))

  (defun +evil|update-cursor-color ()
    (setq +evil--default-cursor-color (face-background 'cursor)))
  (add-hook 'bmacs-load-theme-hook #'+evil|update-cursor-color)

  ;; default modes
  (dolist (mode '(tabulated-list-mode view-mode comint-mode term-mode calendar-mode Man-mode grep-mode))
    (evil-set-initial-state mode 'emacs))
  (dolist (mode '(help-mode debugger-mode))
    (evil-set-initial-state mode 'normal))

  (defun +evil|disable-highlights ()
    "Disable ex search buffer highlights."
    (when (evil-ex-hl-active-p 'evil-ex-search)
      (evil-ex-nohighlight)
      t))
  (add-hook 'bmacs-escape-hook #'+evil|disable-highlights)

  ;; make `try-expand-dabbrev' from `hippie-expand' work in minibuffer
  ;; @see `he-dabbrev-beg', so we need re-define syntax for '/'
  (defun minibuffer-inactive-mode-hook-setup ()
    (set-syntax-table (let* ((table (make-syntax-table)))
                        (modify-syntax-entry ?/ "." table)
                        table)))
  (add-hook 'minibuffer-inactive-mode-hook #'minibuffer-inactive-mode-hook-setup)

  ;; --- evil hacks -------------------------
  (defun +evil|save-buffer ()
    "Shorter, vim-esque save messages."
    (message "\"%s\" %dL, %dC written"
             (if buffer-file-name
                 (file-relative-name (file-truename buffer-file-name) (bmacs-project-root))
               (buffer-name))
             (count-lines (point-min) (point-max))
             (buffer-size)))
  (unless noninteractive
    (setq save-silently t)
    (add-hook 'after-save-hook #'+evil|save-buffer))

  ;; Focus and recenter new splits
  (advice-add #'evil-window-split  :override #'+evil*window-split)
  (advice-add #'evil-window-vsplit :override #'+evil*window-vsplit)

  ;; Make ESC (from normal mode) the universal escaper. See `bmacs-escape-hook'.
  (advice-add #'evil-force-normal-state :after #'bmacs/escape)

  (defun +evil*restore-normal-state-on-windmove (orig-fn &rest args)
    "If in anything but normal or motion mode when moving to another window,
restore normal mode. This prevents insert state from bleeding into other modes
across windows."
    (unless (memq evil-state '(normal motion emacs))
      (evil-normal-state +1))
    (apply orig-fn args))
  (advice-add #'windmove-do-window-select :around #'+evil*restore-normal-state-on-windmove)

  ;; These arg types will highlight matches in the current buffer
  (evil-ex-define-argument-type buffer-match :runner +evil-ex-buffer-match)
  (evil-ex-define-argument-type global-match :runner +evil-ex-global-match)

  ;; By default :g[lobal] doesn't highlight matches in the current buffer. I've
  ;; got to write my own argument type and interactive code to get it to do so.
  (evil-ex-define-argument-type global-delim-match :runner +evil-ex-global-delim-match)
  (dolist (sym '(evil-ex-global evil-ex-global-inverted))
    (evil-set-command-property sym :ex-arg 'global-delim-match)))
#+END_SRC

**** Operators

I like to prevent evil from yanking text to the clipboard in many scenarios.

#+BEGIN_SRC emacs-lisp
(evil-define-operator evil-delete-char-without-register (beg end type reg)
  "delete character without yanking unless in visual mode"
  :motion evil-forward-char
  (interactive "<R><y>")
  (if (evil-visual-state-p)
    (evil-delete beg end type reg)
    (evil-delete beg end type ?_)))

(evil-define-operator evil-delete-backward-char-without-register (beg end type _)
  "delete backward character without yanking"
  :motion evil-backward-char
  (interactive "<R><y>")
  (evil-delete beg end type ?_))

(evil-define-operator evil-delete-without-register (beg end type _ _2)
  (interactive "<R><y>")
  (evil-delete beg end type ?_))

(evil-define-operator evil-delete-without-register-if-whitespace (beg end type reg yank-handler)
  (interactive "<R><y>")
  (let ((text (replace-regexp-in-string "\n" "" (filter-buffer-substring beg end))))
    (if (string-match-p "^\\s-*$" text)
      (evil-delete beg end type ?_)
      (evil-delete beg end type reg yank-handler))))

(evil-define-operator evil-delete-line-without-register (beg end type _ yank-handler)
    (interactive "<R><y>")
    (evil-delete-line beg end type ?_ yank-handler))

(evil-define-operator evil-change-without-register (beg end type _ yank-handler)
  (interactive "<R><y>")
  (evil-change beg end type ?_ yank-handler))

(evil-define-operator evil-change-line-without-register (beg end type _ yank-handler)
  "Change to end of line without yanking."
  :motion evil-end-of-line
  (interactive "<R><y>")
  (evil-change beg end type ?_ yank-handler #'evil-delete-line))

(evil-define-command evil-paste-after-without-register (count &optional register yank-handler)
  "evil paste before without yanking"
  :suppress-operator t
  (interactive "P<x>")
  (if (evil-visual-state-p)
      (evil-visual-paste-without-register count register)
      (evil-paste-after count register yank-handler)))

(evil-define-command evil-paste-before-without-register (count &optional register yank-handler)
  "evil paste before without yanking"
  :suppress-operator t
  (interactive "P<x>")
  (if (evil-visual-state-p)
      (evil-visual-paste-without-register count register)
      (evil-paste-before count register yank-handler)))

(evil-define-command evil-visual-paste-without-register (count &optional register)
  "Paste over Visual selection."
  :suppress-operator t
  (interactive "P<x>")
  ;; evil-visual-paste is typically called from evil-paste-before or
  ;; evil-paste-after, but we have to mark that the paste was from
  ;; visual state
  (setq this-command 'evil-visual-paste)
  (let* ((text (if register
                   (evil-get-register register)
                 (current-kill 0)))
         (yank-handler (car-safe (get-text-property
                                  0 'yank-handler text)))
         new-kill
         paste-eob)
    (evil-with-undo
      (let* ((kill-ring (list (current-kill 0)))
             (kill-ring-yank-pointer kill-ring))
        (when (evil-visual-state-p)
          (evil-visual-rotate 'upper-left)
          ;; if we replace the last buffer line that does not end in a
          ;; newline, we use `evil-paste-after' because `evil-delete'
          ;; will move point to the line above
          (when (and (= evil-visual-end (point-max))
                     (/= (char-before (point-max)) ?\n))
            (setq paste-eob t))
          (evil-delete-without-register evil-visual-beginning evil-visual-end
                       (evil-visual-type))
          (when (and (eq yank-handler #'evil-yank-line-handler)
                     (not (eq (evil-visual-type) 'line))
                     (not (= evil-visual-end (point-max))))
            (insert "\n"))
          (evil-normal-state)
          (setq new-kill (current-kill 0))
          (current-kill 1))
        (if paste-eob
            (evil-paste-after count register)
          (evil-paste-before count register)))
      (kill-new new-kill)
      ;; mark the last paste as visual-paste
      (setq evil-last-paste
            (list (nth 0 evil-last-paste)
                  (nth 1 evil-last-paste)
                  (nth 2 evil-last-paste)
                  (nth 3 evil-last-paste)
                  (nth 4 evil-last-paste)
                  t)))))

(evil-define-command +evil*window-split (&optional count file)
  "Same as `evil-window-split', but focuses (and recenters) the new split."
  :repeat nil
  (interactive "P<f>")
  (split-window (selected-window) count
                (if evil-split-window-below 'above 'below))
  (call-interactively
   (if evil-split-window-below
       #'evil-window-up
     #'evil-window-down))
  (recenter)
  (when (and (not count) evil-auto-balance-windows)
    (balance-windows (window-parent)))
  (if file (evil-edit file)))

(evil-define-command +evil*window-vsplit (&optional count file)
  "Same as `evil-window-vsplit', but focuses (and recenters) the new split."
  :repeat nil
  (interactive "P<f>")
  (split-window (selected-window) count
                (if evil-vsplit-window-right 'left 'right))
  (call-interactively
   (if evil-vsplit-window-right
       #'evil-window-left
     #'evil-window-right))
  (recenter)
  (when (and (not count) evil-auto-balance-windows)
    (balance-windows (window-parent)))
  (if file (evil-edit file)))
#+END_SRC

*** recentf

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :demand t
  :config
  (setq recentf-save-file (concat bmacs-etc-dir "recentf")
      recentf-max-menu-items 0
      recentf-max-saved-items 300)
  (recentf-mode))
#+END_SRC

** Completion

*** swiper
Awesome visual search utility

#+BEGIN_SRC emacs-lisp
(use-package swiper :commands (swiper swiper-all))
#+END_SRC

*** counsel
Making everything all ivy-ed up.

**** Functions

#+BEGIN_SRC emacs-lisp
;; Find in project using current word or selection
(defun counsel-projectile-rg-initial (&optional value)
  "Ivy version of `projectile-rg'."
  (interactive)
  (if (projectile-project-p)
        (counsel-rg value
                    (projectile-project-root)
                    nil
                    (projectile-prepend-project-name "rg"))
  (user-error "You're not in a project")))

(defun counsel-projectile-rg-region-or-symbol ()
  "Use `counsel-rg' to search for the selected region or
 the symbol around point in the current project with git grep."
  (interactive)
  (let ((input (if (region-active-p)
    (buffer-substring-no-properties
      (region-beginning) (region-end))
      (thing-at-point 'symbol t))))
    (if (projectile-project-p)
      (counsel-projectile-rg-initial input)
      (counsel-rg input))))

  (defun +ivy-recentf-transformer (str)
    "Dim recentf entries that are not in the current project of the buffer you
  started `counsel-recentf' from. Also uses `abbreviate-file-name'."
    (let ((str (abbreviate-file-name str)))
      (if (file-in-directory-p str (bmacs-project-root))
          str
        (propertize str 'face 'ivy-virtual))))

(defun +ivy-projectile-find-file-transformer (str)
  "Highlight entries that have been visited. This is the opposite of
`counsel-projectile-find-file'."
  (cond ((get-file-buffer (projectile-expand-root str))
         (propertize str 'face '(:weight ultra-bold :slant italic)))
        (t str)))

;;   (defun +ivy-projectile-find-file-transformer (str)
;;   "Highlight entries that have been visited. This is the opposite of
;; `counsel-projectile-find-file'."
;;     (cond ((get-file-buffer (projectile-expand-root str))
;;            (propertize str 'face '(:weight ultra-bold :slant italic :foreground "#51afef")))
;;           (t str)))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :commands (counsel-projectile-find-file counsel-projectile-find-dir counsel-projectile-switch-to-buffer
             counsel-projectile-grep counsel-projectile-ag counsel-projectile-switch-project)
  :after counsel
  :init
  (map! [remap projectile-find-file]        #'counsel-projectile-find-file
        [remap projectile-find-dir]         #'counsel-projectile-find-dir
        [remap projectile-switch-to-buffer] #'counsel-projectile-switch-to-buffer
        [remap projectile-grep]             #'counsel-projectile-grep
        [remap projectile-ag]               #'counsel-projectile-ag
        [remap projectile-switch-project]   #'counsel-projectile-switch-project)
  :config
  (ivy-set-display-transformer #'counsel-projectile-find-file #'+ivy-projectile-find-file-transformer))

(use-package counsel
  :demand t
  :init
  (map! [remap apropos]                  #'counsel-apropos
        [remap bookmark-jump]            #'counsel-bookmark
        [remap describe-face]            #'counsel-describe-face
        [remap describe-function]        #'counsel-describe-function
        [remap describe-variable]        #'counsel-describe-variable
        [remap execute-extended-command] #'counsel-M-x
        [remap find-file]                #'counsel-find-file
        [remap find-library]             #'counsel-find-library
        [remap info-lookup-symbol]       #'counsel-info-lookup-symbol
        [remap imenu]                    #'counsel-imenu
        [remap recentf-open-files]       #'counsel-recentf
        [remap org-capture]              #'counsel-org-capture
        [remap swiper]                   #'counsel-grep-or-swiper)
  :config
  (setq counsel-find-file-ignore-regexp "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)"
        ;; Add smart-casing and compressed archive searching (-zS) to default
        ;; command arguments:
        counsel-rg-base-command "rg -zS --no-heading --line-number --color never %s ."
        counsel-ag-base-command "ag -zS --nocolor --nogroup %s"
        counsel-pt-base-command "pt -zS --nocolor --nogroup -e %s")

  ;; Set evil jump point before search
  (advice-add #'counsel-ag-function :before (lambda (arg)
                                              (evil--jumps-push)))

  ;; Add action to open in other window during search
  (dolist (cmd '(counsel-ag counsel-rg counsel-pt))
    (ivy-add-actions
     cmd
     '(("O" +ivy-git-grep-other-window-action "open in other window"))))

  (ivy-set-display-transformer #'counsel-recentf #'+ivy-recentf-transformer))
#+END_SRC

*** smex

Improved M-x

#+BEGIN_SRC emacs-lisp
(use-package smex
  :commands (smex smex-major-mode-commands)
  :config
  (setq smex-save-file (concat bmacs-cache-dir "/smex-items"))
  (smex-initialize))
#+END_SRC


*** ivy-rich

Provide more information in ivy buffers list.

**** functions

#+BEGIN_SRC emacs-lisp
(defun +ivy-buffer-transformer (str)
  "Dim special buffers, buffers whose file aren't in the current buffer, and
virtual buffers. Uses `ivy-rich' under the hood."
  (let ((buf (get-buffer str)))
    (require 'ivy-rich)
    (cond (buf (ivy-rich-switch-buffer-transformer str))
          ((and (eq ivy-virtual-abbreviate 'full)
                ivy-rich-switch-buffer-align-virtual-buffer)
           (ivy-rich-switch-buffer-virtual-buffer str))
          ((eq ivy-virtual-abbreviate 'full)
           (propertize (abbreviate-file-name str) 'str 'ivy-virtual))
          (t (propertize str 'face 'ivy-virtual)))))

(defun +ivy*rich-switch-buffer-buffer-name (str)
  (propertize
   (ivy-rich-pad str ivy-rich-switch-buffer-name-max-length)
   'face (cond ((string-match-p "^ *\\*" str)
                'font-lock-comment-face)
               ((and buffer-file-truename
                     (not (file-in-directory-p buffer-file-truename (bmacs-project-root))))
                'font-lock-doc-face)
               (t nil))))
(advice-add 'ivy-rich-switch-buffer-buffer-name :override #'+ivy*rich-switch-buffer-buffer-name)

#+END_SRC

**** config

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :demand t
  :after ivy)
#+END_SRC

*** ivy-hydra

Nice ivy hydra

#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :demand t
    :after ivy
    :commands (+ivy@coo/body ivy-dispatching-done-hydra)
    :init
    (map! :map ivy-minibuffer-map
          "C-o" #'+ivy@coo/body
          "M-o" #'ivy-dispatching-done-hydra)
    :config
    (defhydra +ivy@coo (:hint nil :color pink)
      "
   Move     ^^^^^^^^^^ | Call         ^^^^ | Cancel^^ | Options^^ | Action _w_/_s_/_a_: %s(ivy-action-name)
  ----------^^^^^^^^^^-+--------------^^^^-+-------^^-+--------^^-+---------------------------------
   _g_ ^ ^ _k_ ^ ^ _u_ | _f_orward _o_ccur | _i_nsert | _c_alling: %-7s(if ivy-calling \"on\" \"off\") _C_ase-fold: %-10`ivy-case-fold-search
   ^↨^ _h_ ^+^ _l_ ^↕^ | _RET_ done     ^^ | _q_uit   | _m_atcher: %-7s(ivy--matcher-desc) _t_runcate: %-11`truncate-lines
   _G_ ^ ^ _j_ ^ ^ _d_ | _TAB_ alt-done ^^ | ^ ^      | _<_/_>_: shrink/grow
  "
      ;; arrows
      ("j" ivy-next-line)
      ("k" ivy-previous-line)
      ("l" ivy-alt-done)
      ("h" ivy-backward-delete-char)
      ("g" ivy-beginning-of-buffer)
      ("G" ivy-end-of-buffer)
      ("d" ivy-scroll-up-command)
      ("u" ivy-scroll-down-command)
      ("e" ivy-scroll-down-command)
      ;; actions
      ("q" keyboard-escape-quit :exit t)
      ("C-g" keyboard-escape-quit :exit t)
      ("<escape>" keyboard-escape-quit :exit t)
      ("C-o" nil)
      ("i" nil)
      ("TAB" ivy-alt-done :exit nil)
      ("C-j" ivy-alt-done :exit nil)
      ;; ("d" ivy-done :exit t)
      ("RET" ivy-done :exit t)
      ("C-m" ivy-done :exit t)
      ("f" ivy-call)
      ("c" ivy-toggle-calling)
      ("m" ivy-toggle-fuzzy)
      (">" ivy-minibuffer-grow)
      ("<" ivy-minibuffer-shrink)
      ("w" ivy-prev-action)
      ("s" ivy-next-action)
      ("a" ivy-read-action)
      ("t" (setq truncate-lines (not truncate-lines)))
      ("C" ivy-toggle-case-fold)
      ("o" ivy-occur :exit t)))
#+END_SRC

*** ivy-posframe (disabled)

**** functions

#+BEGIN_SRC emacs-lisp :tangle no
(defun +ivy-display-at-frame-center-near-bottom (str)
  "TODO"
  (ivy-posframe--display str #'+ivy-poshandler-frame-center-near-bottom))

(defun +ivy-poshandler-frame-center-near-bottom (info)
  "TODO"
  (let ((parent-frame (plist-get info :parent-frame))
        (pos (posframe-poshandler-frame-center info)))
    (cons (car pos)
          (truncate (/ (frame-pixel-height parent-frame) 1.6)))))
#+END_SRC

**** config

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy-posframe
  :after ivy
  :preface
  ;; This function searches the entire `obarray' just to populate
  ;; `ivy-display-functions-props'. There are 15k entries in mine! This is
  ;; wasteful, so...
  (advice-add #'ivy-posframe-setup :override #'ignore)
  :config
  (setq ivy-height 16
        ivy-fixed-height-minibuffer nil
        ivy-posframe-parameters `((min-width . 90)
                                  (min-height . ,ivy-height)
                                  (internal-border-width . 10)))

  ;; ... let's do it manually
  (dolist (fn (list 'ivy-posframe-display-at-frame-bottom-left
                    'ivy-posframe-display-at-frame-center
                    'ivy-posframe-display-at-point
                    'ivy-posframe-display-at-frame-bottom-window-center
                    'ivy-posframe-display
                    'ivy-posframe-display-at-window-bottom-left
                    'ivy-posframe-display-at-window-center
                    '+ivy-display-at-frame-center-near-bottom))
    (map-put ivy-display-functions-props fn '(:cleanup ivy-posframe-cleanup)))

  (map-put ivy-display-functions-alist 't '+ivy-display-at-frame-center-near-bottom)

  ;; posframe doesn't work well with async sources
  (dolist (fn '(swiper counsel-rg counsel-ag counsel-pt counsel-grep counsel-git-grep counsel-dash))
    (map-put ivy-display-functions-alist fn nil))

  (ivy-posframe-enable))
#+END_SRC

*** company
Generic code auto completion

#+BEGIN_SRC emacs-lisp
(use-package company
  :commands (company-mode global-company-mode company-complete
             company-complete-common company-manual-begin company-grab-line)
  :config
  (setq company-idle-delay 0.1
        company-tooltip-limit 10
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-dabbrev-code-other-buffers t
        company-tooltip-align-annotations t
        company-minimum-prefix-length 3
        company-require-match 'never
        company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
        company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
        company-backends '(company-dabbrev-code company-capf company-keywords company-files company-dabbrev)
        company-transformers '(company-sort-by-occurrence))

  (after! yasnippet
    (nconc company-backends '(company-yasnippet)))

  (global-company-mode +1))

(defun +company/complete ()
  "Bring up the completion popup. If only one result, complete it."
  (interactive)
  (require 'company)
  (when (and (company-manual-begin)
             (= company-candidates-length 1))
    (company-complete-common)))
#+END_SRC

*** comany-statistics
Keep company completion statistics to improve sorting

#+BEGIN_SRC emacs-lisp
(use-package company-statistics
  :demand t
  :after company
  :config
  (setq company-statistics-file (concat bmacs-cache-dir "company-stats-cache.el"))
  (quiet! (company-statistics-mode +1)))
#+END_SRC

*** company-dict
Dictionary based completions in company

#+BEGIN_SRC emacs-lisp
  (use-package company-dict
    :commands company-dict)
#+END_SRC

*** company-box (disabled)
A company front-end with icons. Currently disabled because configuration seems pretty limited and I'm not currently sold on it. It doesn't show when there is only one candidate and the minimum height with only a few candidates is way too small.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-box
  :hook (company-mode . company-box-mode)
  :init
  (defun +company|fix-frontends ()
    "Ensure `company-pseudo-tooltip-frontend' is *not* in `company-frontends'
when company-box is active, which are incompatible and cause duplicate popups."
    (make-variable-buffer-local 'company-frontends)
    (if company-box-mode
        (setq company-frontends (delq 'company-pseudo-tooltip-frontend company-frontends))
      (cl-pushnew 'company-pseudo-tooltip-frontend company-frontends :test #'eq)))
  (add-hook 'company-box-mode-hook #'+company|fix-frontends)
  :config
  (setq company-box-backends-colors nil
        company-box-icons-elisp
        (list (all-the-icons-material "functions" :face 'all-the-icons-purple)
              (all-the-icons-material "check_circle" :face 'all-the-icons-blue)
              (all-the-icons-material "stars" :face 'all-the-icons-yellow)
              (all-the-icons-material "format_paint" :face 'all-the-icons-pink))
        company-box-icons-unknown (all-the-icons-material "find_in_page" :face 'all-the-icons-silver)
        company-box-icons-yasnippet (all-the-icons-material "short_text" :face 'all-the-icons-green)))
#+END_SRC

** Workspaces / Projects

*** persp-mode
Allows for creation of isolated workspaces

**** Functions

#+BEGIN_SRC emacs-lisp
(defvar +workspaces-last-persp nil
  "A variable that contains the last accessed perspective")

(defun +workspace-exists-p (name)
  "Returns t if NAME is the name of an existing workspace."
  (when (symbolp name)
    (setq name (symbol-name name)))
  (unless (stringp name)
    (error "Expected a string, got a %s" (type-of name)))
  (member name (persp-names-current-frame-fast-ordered)))

(defun +workspace-switch-last ()
  "Switches to the last workspace"
  (interactive)
  (if (+workspace-exists-p +workspaces-last-persp)
      (persp-switch +workspaces-last-persp)
    (error "No previous workspace.")))

(defun +workspace-switch-project ()
  (interactive)
  (ivy-read "Switch to Project Perspective: "
            (if (projectile-project-p)
                (cons (abbreviate-file-name (projectile-project-root))
                      (projectile-relevant-known-projects))
              projectile-known-projects)
            :action (lambda (project)
                      (persp-switch project)
                      (let ((projectile-completion-system 'ivy))
                        (projectile-switch-project-by-name project)))))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package persp-mode :demand t
  :config
  (setq wg-morph-on nil
        persp-autokill-buffer-on-remove 'kill-weak
        persp-nil-name "nil"
        persp-nil-hidden t
        persp-auto-save-fname "autosave"
        persp-auto-resume-time 1
        persp-auto-save-opt 1
        persp-save-dir (concat bmacs-etc-dir "workspaces/"))

  (defun +workspaces*track-last-persp (switch-fun &rest args)
    (let ((before-persp (safe-persp-name (get-current-persp)))
          (after-persp (apply switch-fun args)))
      (when (not (string= before-persp after-persp))
        (setq +workspaces-last-persp before-persp))))
  (advice-add #'persp-switch :around #'+workspaces*track-last-persp)
  (add-hook 'bmacs-post-init-hook #'(lambda () (persp-mode 1))))
#+END_SRC


*** projectile
Project support anywhere, for any project

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :demand t
  :init
  (setq projectile-cache-file (concat bmacs-cache-dir "projectile.cache")
        projectile-enable-caching t
        projectile-indexing-method 'alien
        projectile-require-project-root nil
        projectile-known-projects-file (concat bmacs-cache-dir "projectile.projects")
        projectile-globally-ignored-files '(".DS_Store" "Icon" "TAGS")
        projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o" ".class"))

  (add-hook 'bmacs-post-init-hook #'projectile-mode)
  :config
  ;; a more generic project root file
  (push ".project" projectile-project-root-files-bottom-up)

  (setq grep-find-ignored-directories '("target" ".ensime_cache" ".fingerprint"))
  (nconc projectile-globally-ignored-directories '("target" ".ensime_cache" ".fingerprint" "project/target" "node_modules"))
  (nconc projectile-other-file-alist '(("css"  . ("scss" "sass" "less" "style"))
                                       ("scss" . ("css"))
                                       ("sass" . ("css"))
                                       ("less" . ("css"))
                                       ("styl" . ("css"))))

  ;; Projectile root-searching functions can cause an infinite loop on TRAMP
  ;; connections, so disable them.
  (defun bmacs--projectile-locate-dominating-file (orig-fn &rest args)
    "Don't traverse the file system if on a remote connection."
    (unless (file-remote-p default-directory)
      (apply orig-fn args)))
  (advice-add #'projectile-locate-dominating-file :around #'bmacs--projectile-locate-dominating-file))
#+END_SRC

** Editing

*** evil

**** evil-commentary
Robust commenting support in evil-mode

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :commands (evil-commentary evil-commentary-yank evil-commentary-line)
  :config (evil-commentary-mode 1))
#+END_SRC

**** evil-easymotion
I like to move it move it

#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :demand t
  :after evil-snipe
  :commands evilem-create
  :config
  (let ((prefix "g"))
    (evilem-default-keybindings prefix)
    (map! :prefix "g"
          :nv "l" #'evilem-motion-forward-word-begin
          :nv "h" #'evilem-motion-backward-word-begin
          :nv "L" #'evilem-motion-forward-WORD-begin
          :nv "H" #'evilem-motion-backward-WORD-begin
          :nv "(" #'evilem-motion-forward-sentance-begin
          :nv ")" #'evilem-motion-backward-sentance-begin
          :nv "n" #'evilem-motion-search-next
          :nv "N" #'evilem-motion-search-previous
          :nv "g" #'evil-goto-first-line)))
#+END_SRC

**** evil-matchit
Jump between matching delimiters

#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :commands (evilmi-jump-items evilmi-text-object global-evil-matchit-mode)
  :config (global-evil-matchit-mode 1)
  :init
  (map! [remap evil-jump-item] #'evilmi-jump-items
        :textobj "%" #'evilmi-text-object #'evilmi-text-object)
  :config
  (defun +evil|simple-matchit ()
    "A hook to force evil-matchit to favor simple bracket jumping. Helpful when
the new algorithm is confusing, like in python or ruby."
    (setq-local evilmi-always-simple-jump t))
  (add-hook 'python-mode-hook #'+evil|simple-matchit))
#+END_SRC

**** evil-mc
Multiple cursors!

#+BEGIN_SRC emacs-lisp
  (use-package evil-mc ;; :demand t TODO
    :commands (evil-mc-make-cursor-here evil-mc-make-all-cursors
               evil-mc-undo-all-cursors evil-mc-pause-cursors
               evil-mc-resume-cursors evil-mc-make-and-goto-first-cursor
               evil-mc-make-and-goto-last-cursor
               evil-mc-make-cursor-move-next-line
               evil-mc-make-cursor-move-prev-line evil-mc-make-cursor-at-pos
               evil-mc-has-cursors-p evil-mc-make-and-goto-next-cursor
               evil-mc-skip-and-goto-next-cursor evil-mc-make-and-goto-prev-cursor
               evil-mc-skip-and-goto-prev-cursor evil-mc-make-and-goto-next-match
               evil-mc-skip-and-goto-next-match evil-mc-skip-and-goto-next-match
               evil-mc-make-and-goto-prev-match evil-mc-skip-and-goto-prev-match)
    :config
    (global-evil-mc-mode +1)

    (dolist
        (commands '((evil-change-without-register . ((:default . evil-mc-execute-default-evil-change)))
                   (evil-change-line-without-register . ((:default . evil-mc-execute-default-evil-change-line)))
                   (evil-delete-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                   (evil-delete-without-register-if-whitespace . ((:default . evil-mc-execute-default-evil-delete)))
                   (evil-delete-char-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                   (evil-delete-backward-char-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                   (evil-delete-line-without-register . ((:default . evil-mc-execute-default-evil-delete)))
                   (evil-paste-after-without-register . ((:default . evil-mc-execute-default-evil-paste)))
                   (evil-paste-before-without-register . ((:default . evil-mc-execute-default-evil-paste)))))
      (push commands evil-mc-custom-known-commands))

    (defun evil-mc-maybe-run-cursors-before ()
      "Runs `evil-mc-cursors-before' if there are no cursors created yet."
      (when (not (evil-mc-has-cursors-p))
        (evil-mc-cursors-before)))

    (defun evil-mc-cursors-before ()
      "Actions to be executed before any cursors are created."
      (setq evil-mc-cursor-state (evil-mc-read-cursor-state nil))
        (evil-mc-write-cursor-state
         (evil-mc-put-cursor-last-position (evil-mc-get-default-cursor) (point)))
      (run-hooks 'evil-mc-before-cursors-created))

    (defun evil-mc-make-cursor-move-by-line (dir count)
      "Create COUNT cursors one for each line moving in the direction DIR.
    DIR should be 1 or -1 and COUNT should be a positive integer or nil."
      (setq count (max 0 (or count 1)))
      (dotimes (_ count)
        (evil-mc-maybe-run-cursors-before)
        (evil-mc-make-cursor-at-pos (point))
        (if (> dir 0)
          (evil-next-visual-line)
          (evil-previous-visual-line))))
        ;; (let (line-move-visual)
        ;;   (evil-line-move dir))))

    (defun +evil|escape-multiple-cursors ()
      "Clear evil-mc cursors and restore state."
      (when (evil-mc-has-cursors-p)
        (evil-mc-undo-all-cursors)
        (evil-mc-resume-cursors)
        t))
    (add-hook 'bmacs-escape-hook #'+evil|escape-multiple-cursors))
#+END_SRC

**** evil-snipe
I only really use this for the extended s/S/f/F behavior

#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :commands (evil-snipe-override-mode)
  :init
  (setq evil-snipe-smart-case t
        evil-snipe-scope 'visible
        evil-snipe-repeat-scope 'buffer
        evil-snipe-char-fold t)
  (add-hook 'bmacs-post-init-hook #'evil-snipe-override-mode))
#+END_SRC

**** evil-surround
Surround text with various delimiters

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :commands (global-evil-surround-mode
             evil-surround-edit
             evil-Surround-edit
             evil-surround-region)
  :config (global-evil-surround-mode 1))
#+END_SRC

**** evil-visualstar
Allow visual selections to be searched using '*'

#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :commands (global-evil-visualstar-mode
             evil-visualstar/begin-search
             evil-visualstar/begin-search-forward
             evil-visualstar/begin-search-backward)
  :init
  (map! :v "*" #'evil-visualstar/begin-search-forward
        :v "#" #'evil-visualstar/begin-search-backward)
  :config
  (global-evil-visualstar-mode 1))
#+END_SRC

**** evil-iedit-state
Add evil states for iedit mode

#+BEGIN_SRC emacs-lisp
(use-package evil-iedit-state
  :commands (evil-iedit-state evil-iedit-state/iedit-mode)
  :init
  (progn
    (setq iedit-current-symbol-default t
          iedit-only-at-symbol-boundaries t
          iedit-toggle-key-default nil)))
#+END_SRC


**** evil-args
Treat arguments as text objects using 'a'

#+BEGIN_SRC emacs-lisp
(use-package evil-args
  :demand t
  :after evil
  :commands (evil-inner-arg evil-outer-arg
             evil-forward-arg evil-backward-arg
             evil-jump-out-args)
  :config

  (map! :textobj "a" #'evil-inner-arg #'evil-outer-arg))
#+END_SRC

**** evil-textobj-anyblock
Treat simple code blocks as text objects using 'b'

#+BEGIN_SRC emacs-lisp
(use-package evil-textobj-anyblock
  :commands (evil-textobj-anyblock-inner-block evil-textobj-anyblock-a-block)
  :config
  (map! :textobj "b" #'evil-textobj-anyblock-inner-block #'evil-textobj-anyblock-a-block))
#+END_SRC

**** goto-chg

#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :demand t
  :after evil)
#+END_SRC

**** evil-terminal-cursor-changer
When used in the terminal over ssh, this allows emacs to properly update the cursor shape in evil mode.

#+BEGIN_SRC emacs-lisp
  (unless (display-graphic-p)
    (use-package evil-terminal-cursor-changer
       :demand t
       :config (evil-terminal-cursor-changer-activate)))
#+END_SRC

**** evil-little-word

Support for word motions through camelCase and snake_case

#+BEGIN_SRC emacs-lisp
(defun maybe-define-category (cat doc &optional table)
  (unless (category-docstring cat table) (define-category cat doc table)))

(let (uc lc defs (table (standard-category-table)))
  (map-char-table
   #'(lambda (key value)
       (when (natnump value)
         (let (from to)
           (if (consp key)
               (setq from (car key) to (cdr key))
             (setq from (setq to key)))
           (while (<= from to)
             (cond ((/= from (downcase from))
                    (add-to-list 'uc from))
                   ((/= from (upcase from))
                    (add-to-list 'lc from)))
             (setq from (1+ from))))))
   (standard-case-table))
  (setq defs `(("Uppercase" ?U ,uc)
               ("Lowercase" ?u ,lc)
               ("Underscore" ?_ (?_))))
  (dolist (elt defs)
    (maybe-define-category (cadr elt) (car elt) table)
    (dolist (ch (car (cddr elt)))
      (modify-category-entry ch (cadr elt) table))))

(defgroup evil-little-word nil
  "CamelCase and snake_case word movement support."
  :prefix "evil-little-word-"
  :group 'evil)

(defcustom evil-little-word-separating-categories
  (append evil-cjk-word-separating-categories '((?u . ?U) (?_ . ?u) (?_ . ?U)))
  "List of pair (cons) of categories to determine word boundary
for little word movement. See the documentation of
`word-separating-categories'. Use `describe-categories' to see
the list of categories."
  :type '((character . character))
  :group 'evil-little-word)

(defcustom evil-little-word-combining-categories
  (append evil-cjk-word-combining-categories '())
  "List of pair (cons) of categories to determine word boundary
for little word movement. See the documentation of
`word-combining-categories'. Use `describe-categories' to see the
list of categories."
  :type '((character . character))
  :group 'evil-little-word)

(defmacro evil-with-little-word (&rest body)
  (declare (indent defun) (debug t))
  `(let ((evil-cjk-word-separating-categories
          evil-little-word-separating-categories)
         (evil-cjk-word-combining-categories
          evil-little-word-combining-categories))
     ,@body))

(defun forward-evil-little-word (&optional count)
  "Forward by little words."
  (evil-with-little-word (forward-evil-word count)))

(evil-define-motion evil-forward-little-word-begin (count)
  "Move the cursor to the beginning of the COUNT-th next little word."
  :type exclusive
  (evil-with-little-word (evil-forward-word-begin count)))

(evil-define-motion evil-forward-little-word-end (count)
  "Move the cursor to the end of the COUNT-th next little word."
  :type inclusive
  (evil-with-little-word (evil-forward-word-end count)))

(evil-define-motion evil-backward-little-word-begin (count)
  "Move the cursor to the beginning of the COUNT-th previous little word."
  :type exclusive
  (evil-with-little-word (evil-backward-word-begin count)))

(evil-define-motion evil-backward-little-word-end (count)
  "Move the cursor to the end of the COUNT-th previous little word."
  :type inclusive
  (evil-with-little-word (evil-backward-word-end count)))

(evil-define-text-object evil-a-little-word (count &optional beg end type)
  "Select a little word."
  (evil-select-an-object 'evil-little-word beg end type count))

(evil-define-text-object evil-inner-little-word (count &optional beg end type)
  "Select inner little word."
  (evil-select-inner-object 'evil-little-word beg end type count))

(define-key evil-motion-state-map (kbd "glw") 'evil-forward-little-word-begin)
(define-key evil-motion-state-map (kbd "glb") 'evil-backward-little-word-begin)
(define-key evil-motion-state-map (kbd "glW") 'evil-forward-little-word-end)
(define-key evil-motion-state-map (kbd "glB") 'evil-backward-little-word-end)
(define-key evil-outer-text-objects-map (kbd "lw") 'evil-a-little-word)
(define-key evil-inner-text-objects-map (kbd "lw") 'evil-inner-little-word)
#+END_SRC

*** hideshow
Allows code folding

#+BEGIN_SRC emacs-lisp
(use-package hideshow :demand t ; built-in
  :commands (hs-minor-mode hs-toggle-hiding hs-already-hidden-p hs-hide-level hs-show-all)
  :config
  (add-hook 'prog-mode-hook #'hs-minor-mode)
  (setq hs-hide-comments-when-hiding-all nil))
#+END_SRC

*** undo-tree
Branching undo

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :demand t
  :config
  (global-undo-tree-mode +1)
  ;; persistent undo history is known to cause undo history corruption, which
  ;; can be very destructive! So disable it!
  (setq undo-tree-auto-save-history nil
        undo-tree-history-directory-alist
        (list (cons "." (concat bmacs-cache-dir "undo-tree-hist/")))))
#+END_SRC

*** expand-region
Allows us to increase selected region by semantic units

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :commands (er/expand-region er/contract-region er/mark-symbol er/mark-word))
#+END_SRC

*** clean-aindent-mode
Auto indentation

#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode :demand t
  :config
  (clean-aindent-mode t)
  (define-key global-map (kbd "RET") 'newline-and-indent))
#+END_SRC

*** iedit
Everyone knows iedit!

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :commands (iedit-mode)
  :config
  (map! :map iedit-mode-occurrence-keymap
        :n [escape] 'iedit-quit))
#+END_SRC

*** yasnippet

**** functions

#+BEGIN_SRC emacs-lisp
(defun +snippets/goto-start-of-field ()
  "Go to the beginning of the current field."
  (interactive)
  (let* ((snippet (car (yas-active-snippets)))
         (position (yas--field-start (yas--snippet-active-field snippet))))
    (if (= (point) position)
        (move-beginning-of-line 1)
      (goto-char position))))

(defun +snippets/goto-end-of-field ()
  "Go to the end of the current field."
  (interactive)
  (let* ((snippet (car (yas-active-snippets)))
         (position (yas--field-end (yas--snippet-active-field snippet))))
    (if (= (point) position)
        (move-end-of-line 1)
      (goto-char position))))

(defun +snippets/delete-backward-char (&optional field)
  "Prevents Yas from interfering with backspace deletion."
  (interactive)
  (let ((field (or field (and yas--active-field-overlay
                              (overlay-buffer yas--active-field-overlay)
                              (overlay-get yas--active-field-overlay 'yas--field)))))
    (cond ((eq (point) (marker-position (yas--field-start field))) nil)
          (t (call-interactively #'delete-backward-char)))))

(defun +snippets/delete-forward-char-or-field (&optional field)
  "Delete forward, or skip the current field if it's empty. This is to prevent
buggy behavior when <delete> is pressed in an empty field."
  (interactive)
  (let ((field (or field (and yas--active-field-overlay
                              (overlay-buffer yas--active-field-overlay)
                              (overlay-get yas--active-field-overlay 'yas--field)))))
    (cond ((and field
                (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          ((eq (point) (marker-position (yas--field-end field))) nil)
          (t (delete-char 1)))))

(defun +snippets/delete-to-start-of-field (&optional field)
  "Delete to start-of-field."
  (interactive)
  (let* ((field (or field (and yas--active-field-overlay
                               (overlay-buffer yas--active-field-overlay)
                               (overlay-get yas--active-field-overlay 'yas--field))))
         (sof (marker-position (yas--field-start field))))
    (when (and field (> (point) sof))
      (delete-region sof (point)))))
#+END_SRC

**** config

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :commands (yas-minor-mode yas-minor-mode-on yas-expand yas-expand-snippet
             yas-lookup-snippet yas-insert-snippet yas-new-snippet
             yas-visit-snippet-file snippet-mode)
  :config
  ;; Use ivy to complete yas snippets
  (defun +ivy-yas-prompt (prompt choices &optional display-fn)
    (yas-completing-prompt prompt choices display-fn #'ivy-completing-read))
  (push #'+ivy-yas-prompt yas-prompt-functions)

  ;; enable yas on desired modes
  (add-hook! (text-mode prog-mode snippet-mode org-mode)
    #'yas-minor-mode-on)

  (setq yas-also-auto-indent-first-line t
        yas-prompt-functions (delq 'yas-dropdown-prompt yas-prompt-functions))

  ;; Exit snippets on ESC from normal mode
  (add-hook 'bmacs-escape-hook #'yas-abort-snippet))
#+END_SRC

*** yasnippet-snippets

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :demand t
  :after yasnippet)
#+END_SRC

*** auto-yasnippet

#+begin_src emacs-lisp
(use-package auto-yasnippet
  :commands (aya-create aya-expand aya-open-line aya-persist-snippet)
  :config
  (setq aya-persist-snippets-dir (concat bmacs-local-dir "auto-snippets/")))
#+end_src

*** flycheck
Check syntax!

#+BEGIN_SRC emacs-lisp
(autoload 'pkg-info-version-info "pkg-info")

(use-package flycheck
  :commands (flycheck-mode flycheck-list-errors flycheck-buffer)
  :config
  ;; Emacs feels snappier without checks on idle/change
  (setq flycheck-check-syntax-automatically '(save mode-enabled)))


(use-package flycheck-pos-tip
  :demand t
  :after flycheck
  :config
  (setq flycheck-pos-tip-timeout 10
        flycheck-display-errors-delay 0.5)
  (flycheck-pos-tip-mode +1))
#+END_SRC

*** dtrt-indent-mode
Automatically detect and set indentation in programming modes

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :demand t
  :config
  (add-to-list 'dtrt-indent-hook-mapping-list '(scala-mode c/c++/java scala-indent:step))
  (add-hook! 'prog-mode-hook #'dtrt-indent-mode))
#+END_SRC

** Git

*** Magit

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (map! :map magit-mode-map
        "SPC" nil))
#+END_SRC

*** gitconfig-mode

#+BEGIN_SRC emacs-lisp
(use-package gitconfig-mode
  :mode "/\\.?git/?config$"
  :mode "/\\.gitmodules$")
#+END_SRC

*** gitignore-mode

#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode
  :mode "/\\.gitignore$")
#+END_SRC

*** git-gutter-fringe

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :commands git-gutter-mode
  :init
  (defun +version-control|git-gutter-maybe ()
    "Enable `git-gutter-mode' in non-remote buffers."
    (when (and (buffer-file-name)
               (not (file-remote-p (buffer-file-name))))
      (git-gutter-mode +1)))
  (add-hook! (text-mode prog-mode conf-mode) #'+version-control|git-gutter-maybe)
  :config
  ;; Update git-gutter on focus (in case I was using git externally)
  (add-hook 'focus-in-hook #'git-gutter:update-all-windows)

  (after! evil
    (defun +version-control|update-git-gutter ()
      "Refresh git-gutter on ESC. Return nil to prevent shadowing other
`bmacs-escape-hook hooks."
      (when git-gutter-mode
        (ignore (git-gutter))))
    (add-hook 'bmacs-escape-hook #'+version-control|update-git-gutter t))

    ;; Update git-gutter on focus (in case I was using git externally)
    (add-hook 'focus-in-hook #'git-gutter:update-all-windows))
#+END_SRC


*** gist
Easy upload and linking of gists

#+BEGIN_SRC emacs-lisp
(use-package gist
  :commands (gist-list gist-buffer gist-region gist-buffer-private gist-region-private))
#+END_SRC

*** git-timemachine
Go back in time ... at least in your code

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :commands (git-timemachine git-timemachine-toggle)
  :config
  (require 'magit-blame)

  ;; Force evil to rehash keybindings for the current state
  (add-hook 'git-timemachine-mode-hook #'evil-force-normal-state))
#+END_SRC

*** git-link

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :commands (git-link git-link-commit git-link-homepage))

(defvar git-link-open-in-browser)

(defun bmacs/git-browse ()
  "Open the website for the current version controlled file. Fallback to
repository root."
  (interactive)
  (require 'git-link)
  (cl-destructuring-bind (beg end)
      (if buffer-file-name (git-link--get-region))
    (let ((git-link-open-in-browser t))
      (git-link (git-link--select-remote) beg end))))
#+END_SRC

*** evil-magit

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :demand t
  :after magit
  :init (setq evil-magit-want-horizontal-movement t))
#+END_SRC

*** smerge

#+BEGIN_SRC emacs-lisp

  (defun +git|enable-smerge-mode-maybe ()
    "Auto-enable `smerge-mode' when merge conflict is detected."
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^<<<<<<< " nil :noerror)
        (smerge-mode 1))))

  (use-package smerge-mode
    :init
    (add-hook 'find-file-hook #'+git|enable-smerge-mode-maybe)
    :config
    (when (version< emacs-version "26")
      (with-no-warnings
        (defalias #'smerge-keep-upper #'smerge-keep-mine)
        (defalias #'smerge-keep-lower #'smerge-keep-other)
        (defalias #'smerge-diff-base-upper #'smerge-diff-base-mine)
        (defalias #'smerge-diff-upper-lower #'smerge-diff-mine-other)
        (defalias #'smerge-diff-base-lower #'smerge-diff-base-other))))

#+END_SRC

** UI

*** general

#+BEGIN_SRC emacs-lisp
#+END_SRC

*** all-the-icons
Allows us to show pretty icons in Emacs.

#+BEGIN_SRC emacs-lisp

(use-package all-the-icons
  :commands (all-the-icons-octicon all-the-icons-faicon all-the-icons-fileicon
             all-the-icons-wicon all-the-icons-material all-the-icons-alltheicon
             all-the-icons-install-fonts)
  :init
  (defun bmacs*disable-all-the-icons-in-tty (orig-fn &rest args)
    (when (display-graphic-p)
      (apply orig-fn args)))

  ;; all-the-icons doesn't work in the terminal, so we "disable" it.
  (dolist (fn '(all-the-icons-octicon all-the-icons-material
                 all-the-icons-faicon all-the-icons-fileicon
                 all-the-icons-wicon all-the-icons-alltheicon))
     (advice-add fn :around #'bmacs*disable-all-the-icons-in-tty)))
#+END_SRC

*** vi-tilde-fringe
Vi like tilde's in the fringe for past EOF

#+BEGIN_SRC emacs-lisp
(use-package vi-tilde-fringe
  :demand t
  :commands (global-vi-tilde-fringe-mode vi-tilde-fringe-mode)
  :init
  (add-hook 'bmacs-post-init-hook #'global-vi-tilde-fringe-mode)
  :config
  (defun +vi-tilde-fringe|disable ()
    (vi-tilde-fringe-mode -1)))
#+END_SRC

*** doom-themes

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :demand t
  :init
  (unless doom-theme
    (setq doom-theme 'doom-one))
  :config
  (defun bmacs*load-theme-hooks (theme &rest _)
    (setq doom-theme theme)
    (run-hooks 'bmacs-load-theme-hook))
  (advice-add #'load-theme :after #'bmacs*load-theme-hooks)

  ;; improve integration with org-mode
  (add-hook 'bmacs-load-theme-hook #'doom-themes-org-config)

  ;; blink mode-line on errors
  (add-hook 'bmacs-load-theme-hook #'doom-themes-visual-bell-config)

  ;; Add file icons to doom-neotree
  (add-hook 'bmacs-load-theme-hook #'doom-themes-neotree-config)
  (setq doom-neotree-enable-variable-pitch nil
        doom-neotree-file-icons 'simple
        doom-neotree-line-spacing 2)

  (when doom-theme
    (load-theme doom-theme t)))

(after! hideshow
  (defface +doom-folded-face `((t (:inherit font-lock-comment-face :weight light)))
    "Face to hightlight `hideshow' overlays."
    :group 'doom-themes)

  ;; Nicer code-folding overlays (with fringe indicators)
  (defun +doom-set-up-overlay (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (when (featurep 'vimish-fold)
        (overlay-put
         ov 'before-string
         (propertize "…" 'display
                     (list vimish-fold-indication-mode
                           'empty-line
                           'vimish-fold-fringe))))
      (overlay-put
       ov 'display (propertize "  [...]  " 'face '+doom-folded-face))))
  (setq hs-set-up-overlay #'+doom-set-up-overlay))

;; NOTE Adjust these bitmaps if you change `doom-fringe-size'
(after! flycheck
  ;; because git-gutter is in the left fringe
  (setq flycheck-indication-mode 'right-fringe)
  ;; A non-descript, left-pointing arrow
  (define-fringe-bitmap 'flycheck-fringe-bitmap-double-arrow
    [16 48 112 240 112 48 16] nil nil 'center))

;; subtle diff indicators in the fringe
(after! git-gutter-fringe
  ;; places the git gutter outside the margins.
  (setq-default fringes-outside-margins t)
  ;; thin fringe bitmaps
  (define-fringe-bitmap 'git-gutter-fr:added [224]
    nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:modified [224]
    nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240]
    nil nil 'bottom))

;; standardize default fringe width
(if (fboundp 'fringe-mode) (fringe-mode '4))
#+END_SRC

*** doom-dashboard
A super cool dashboard on startup!

#+BEGIN_SRC emacs-lisp
  (defvar +doom-dashboard-name " *doom*"
    "The name to use for the dashboard buffer.")

  (defvar +doom-dashboard-inhibit-refresh nil
    "If non-nil, the doom buffer won't be refreshed.")

  (defvar +doom-dashboard-widgets '(banner shortmenu loaded)
    "List of widgets to display in a blank scratch buffer.")

  (defvar +doom-dashboard-inhibit-functions ()
    "A list of functions that determine whether to inhibit the dashboard the
  loading.")

  (defvar doom-fallback-buffer "*scratch*"
    "The name of the buffer to fall back to if no other buffers exist (will create
  it if it doesn't exist).") ;; TODO Not here

  (defun doom-fallback-buffer ()
    "Returns the fallback buffer, creating it if necessary. By default this is the
  scratch buffer."
    (get-buffer-create doom-fallback-buffer))

  (defvar +doom-dashboard--width 80)
  (defvar +doom-dashboard--height 0)
  (defvar +doom-dashboard--old-fringe-indicator fringe-indicator-alist)

  (setq doom-fallback-buffer +doom-dashboard-name)


  (define-derived-mode +doom-dashboard-mode special-mode
    (format "BMACS v%s" "0.1.0")
    "Major mode for the BMACS dashboard buffer."
    (read-only-mode +1)
    (setq truncate-lines t)
    (setq-local whitespace-style nil)
    (setq-local show-trailing-whitespace nil)
    (cl-loop for (car . _cdr) in fringe-indicator-alist
             collect (cons car nil) into alist
             finally do (setq fringe-indicator-alist alist)))

  (map! :map +doom-dashboard-mode-map
        "n" #'+doom-dashboard/next-button
        "p" #'+doom-dashboard/previous-button
        "N" #'+doom-dashboard/last-button
        "P" #'+doom-dashboard/first-button
        :em "j" #'+doom-dashboard/next-button
        :em "k" #'+doom-dashboard/previous-button
        :em "gg" #'+doom-dashboard/first-button
        :em "G"  #'+doom-dashboard/last-button
        [remap evil-insert]      #'evil-normal-state
        [remap evil-change]      #'evil-normal-state
        [remap evil-visual-char] #'evil-normal-state
        [remap evil-visual-line] #'evil-normal-state
        [remap evil-delete]      #'evil-normal-state
        [remap evil-delete-char] #'evil-normal-state)

  ;;
  (defun +doom-dashboard|init ()
    "Initialize doom-dashboard and set up its hooks; possibly open the dashboard
  if in a GUI/non-daemon session."
    (add-hook 'window-configuration-change-hook #'+doom-dashboard-reload)
    (add-hook 'focus-in-hook #'+doom-dashboard-reload)
    (add-hook 'kill-buffer-query-functions #'+doom-dashboard|kill-buffer-query-fn)
    (when (and (display-graphic-p) (not (daemonp)))
      (let ((default-directory bmacs-emacs-dir))
        (+doom-dashboard/open (selected-frame)))))

  (defun +doom-dashboard|kill-buffer-query-fn ()
    (or (not (+doom-dashboard-p))
        (ignore (let (+doom-dashboard-inhibit-refresh)
                  (ignore-errors (+doom-dashboard-reload))))))

  (defun +doom-dashboard|make-frame (frame)
    "Reload the dashboard after a brief pause. This is necessary for new frames,
  whose dimensions may not be fully initialized by the time this is run."
    (run-with-timer 0.1 nil #'+doom-dashboard/open frame))

  (defun +doom-dashboard|server-visit (&rest _)
    "Inhibit dashboard refresh when opening files via emacsclient."
    (setq +doom-dashboard-inhibit-refresh t))

  ;;
  (defun +doom-dashboard/open (frame)
    (interactive (list (selected-frame)))
    (unless (run-hook-with-args-until-success '+doom-dashboard-inhibit-functions)
      (unless +doom-dashboard-inhibit-refresh
        (with-selected-frame frame
          (switch-to-buffer (doom-fallback-buffer))
          (+doom-dashboard-reload)))
      (setq +doom-dashboard-inhibit-refresh nil)))

  (defun +doom-dashboard-p (&optional buffer)
    "Returns t if BUFFER is the dashboard buffer."
    (let ((buffer (or buffer (current-buffer))))
      (and (buffer-live-p buffer)
           (eq buffer (doom-fallback-buffer)))))

  (defun +doom-dashboard-center (len s)
    (concat (make-string (ceiling (max 0 (- len (length s))) 2) ? )
            s))

  (defun +doom-dashboard-reload (&optional dir)
    "Update the DOOM scratch buffer (or create it, if it doesn't exist)."
    (when (get-buffer-window (doom-fallback-buffer))
      (unless (or +doom-dashboard-inhibit-refresh
                  (window-minibuffer-p (frame-selected-window)))
        (let ((old-pwd (or dir default-directory))
              (fallback-buffer (doom-fallback-buffer)))
          (with-current-buffer fallback-buffer
            (with-silent-modifications
              (unless (eq major-mode '+doom-dashboard-mode)
                (+doom-dashboard-mode))
              (erase-buffer)
              (setq default-directory old-pwd)
              (let ((+doom-dashboard--height (window-height (get-buffer-window fallback-buffer)))
                    (lines 1)
                    content)
                (with-temp-buffer
                  (dolist (widget-name +doom-dashboard-widgets)
                    (funcall (intern (format "doom-dashboard-widget--%s" widget-name)))
                    (insert "\n"))
                  (setq content (buffer-string)
                        lines (count-lines (point-min) (point-max))))
                (insert (make-string (max 0 (- (/ +doom-dashboard--height 2)
                                               (/ lines 2)))
                                     ?\n)
                        content))
              (unless (button-at (point))
                (goto-char (next-button (point-min))))))))
      ;; Update all dashboard windows
      (dolist (win (get-buffer-window-list (doom-fallback-buffer) nil t))
        (set-window-fringes win 0 0)
        (set-window-margins
         win (max 0 (/ (- (window-total-width win) +doom-dashboard--width) 2)))))
    t)

  ;; widgets
  (defun doom-dashboard-widget--banner ()
    (mapc (lambda (line)
            (insert (propertize (+doom-dashboard-center +doom-dashboard--width line)
                                'face 'font-lock-comment-face) " ")
            (insert "\n"))
          '("$$$$$$$\\  $$\\      $$\\  $$$$$$\\   $$$$$$\\   $$$$$$   "
            "$$  __$$\\ $$$\\    $$$ |$$  __$$\\ $$  __$$\\ $$  __$$\\ "
            "$$ |  $$ |$$$$\\  $$$$ |$$ /  $$ |$$ /  \\__|$$ /  \\__|"
            "$$$$$$$\\ |$$\\$$\\$$ $$ |$$$$$$$$ |$$ |      \\$$$$$$\\  "
            "$$  __$$\\ $$ \\$$$  $$ |$$  __$$ |$$ |       \\____$$\\ "
            "$$ |  $$ |$$ |\\$  /$$ |$$ |  $$ |$$ |  $$\\ $$\\   $$ |"
            "$$$$$$$  |$$ | \\_/ $$ |$$ |  $$ |\\$$$$$$  |\\$$$$$$  |"
            "\\_______/ \\__|     \\__|\\__|  \\__| \\______/  \\______/ "
            "                                                     "
            "                        EMACS                        ")))

  (defun doom-dashboard-widget--loaded ()
    (insert
     "\n"
     (propertize
      (+doom-dashboard-center
       +doom-dashboard--width
       (format "Loaded %d packages in %.02fs."
               (length load-path)
               (float-time (time-subtract after-init-time before-init-time))))
      'face 'font-lock-comment-face)
     "\n"))

  (defvar all-the-icons-scale-factor)
  (defvar all-the-icons-default-adjust)
  (defun doom-dashboard-widget--shortmenu ()
    (let ((all-the-icons-scale-factor 1.45)
          (all-the-icons-default-adjust -0.02))
      (mapc (lambda (btn)
              (when btn
                (cl-destructuring-bind (label icon fn) btn
                  (insert
                   (with-temp-buffer
                     (insert-text-button
                      (concat (all-the-icons-octicon icon :face 'font-lock-keyword-face)
                              (propertize (concat " " label) 'face 'font-lock-keyword-face))
                      'action `(lambda (_) ,fn)
                      'follow-link t)
                     (+doom-dashboard-center (- +doom-dashboard--width 2) (buffer-string)))
                   "\n\n"))))
            `(("Homepage" "mark-github"
               (browse-url "https://github.com/gilbertw1/bmacs"))
              ,(when (fboundp 'org-agenda-list)
               '("See agenda for this week" "calendar"
                 (call-interactively #'org-agenda-list)))
              ("Recently opened files" "file-text"
               (call-interactively (or (command-remapping #'recentf-open-files)
                                     #'recentf-open-files)))
              ("Open project" "briefcase"
               (call-interactively (or (command-remapping #'projectile-switch-project)
                                     #'projectile-switch-project)))
              ("Jump to bookmark" "bookmark"
               (call-interactively (or (command-remapping #'bookmark-jump)
                                     #'bookmark-jump)))
              ("Edit bmacs.org" "tools"
               (find-file (expand-file-name "bmacs.org" bmacs-emacs-dir)))))))

  (defun +doom-dashboard/next-button ()
    (interactive)
    (ignore-errors (goto-char (next-button (point)))))

  (defun +doom-dashboard/previous-button ()
    (interactive)
    (ignore-errors (goto-char (previous-button (point)))))

  (defun +doom-dashboard/first-button ()
    (interactive)
    (goto-char (point-min))
    (+doom-dashboard/next-button))

  (defun +doom-dashboard/last-button ()
    (interactive)
    (goto-char (point-max))
    (+doom-dashboard/previous-button)
    (beginning-of-line-text))


  (add-hook 'window-setup-hook #'+doom-dashboard|init)
  (add-hook 'after-make-frame-functions #'+doom-dashboard|make-frame)
  (add-hook 'server-visit-hook #'+doom-dashboard|server-visit)
  (add-hook '+doom-dashboard-mode-hook #'+vi-tilde-fringe|disable)
#+END_SRC

*** doom-modeline
The awesome modeline from Doom

#+BEGIN_SRC emacs-lisp
(defvar-local doom--modeline-format nil
  "The modeline format to use when `doom-hide-modeline-mode' is active. Don't
set this directly. Let-bind it instead.")
(defvar-local doom--old-modeline-format nil
  "The old modeline format, so `doom-hide-modeline-mode' can revert when it's
disabled.")
(define-minor-mode doom-hide-modeline-mode
  "Minor mode to hide the mode-line in the current buffer."
  :init-value nil
  :global nil
  (if doom-hide-modeline-mode
      (setq doom--old-modeline-format mode-line-format
            mode-line-format doom--modeline-format)
    (setq mode-line-format doom--old-modeline-format
          doom--old-modeline-format nil))
  (force-mode-line-update))
;; Ensure major-mode or theme changes don't overwrite these variables
(put 'doom--modeline-format 'permanent-local t)
(put 'doom--old-modeline-format 'permanent-local t)
(put 'doom-hide-modeline-mode 'permanent-local t)

(defun doom|hide-modeline-mode-reset ()
  "Sometimes, a major-mode is activated after `doom-hide-modeline-mode' is
activated, thus disabling it (because changing major modes invokes
`kill-all-local-variables' and specifically seems to kill `mode-line-format's
local value, whether or not it's permanent-local. Therefore, we cycle
`doom-hide-modeline-mode' to fix this."
  (when doom-hide-modeline-mode
    (doom-hide-modeline-mode -1)
    (doom-hide-modeline-mode +1)))
(add-hook 'after-change-major-mode-hook #'doom|hide-modeline-mode-reset)


(defmacro def-modeline-segment! (name &rest forms)
  "Defines a modeline segment and byte compiles it."
  (declare (indent defun) (doc-string 2))
  (let ((sym (intern (format "doom-modeline-segment--%s" name))))
    `(progn
       (defun ,sym () ,@forms)
       ,(unless (bound-and-true-p byte-compile-current-file)
          `(let (byte-compile-warnings)
             (byte-compile #',sym))))))

(defsubst doom--prepare-modeline-segments (segments)
  (cl-loop for seg in segments
           if (stringp seg)
            collect seg
           else
            collect (list (intern (format "doom-modeline-segment--%s" (symbol-name seg))))))

(defmacro def-modeline! (name lhs &optional rhs)
  "Defines a modeline format and byte-compiles it. NAME is a symbol to identify
it (used by `doom-modeline' for retrieval). LHS and RHS are lists of symbols of
modeline segments defined with `def-modeline-segment!'.
Example:
  (def-modeline! minimal
    (bar matches \" \" buffer-info)
    (media-info major-mode))
  (doom-set-modeline 'minimal t)"
  (let ((sym (intern (format "doom-modeline-format--%s" name)))
        (lhs-forms (doom--prepare-modeline-segments lhs))
        (rhs-forms (doom--prepare-modeline-segments rhs)))
    `(progn
       (defun ,sym ()
         (let ((lhs (list ,@lhs-forms))
               (rhs (list ,@rhs-forms)))
           (let ((rhs-str (format-mode-line rhs)))
             (list lhs
                   (propertize
                    " " 'display
                    `((space :align-to (- (+ right right-fringe right-margin)
                                          ,(+ 1 (string-width rhs-str))))))
                   rhs-str))))
       ,(unless (bound-and-true-p byte-compile-current-file)
          `(let (byte-compile-warnings)
             (byte-compile #',sym))))))

(defun doom-modeline (key)
  "Returns a mode-line configuration associated with KEY (a symbol). Throws an
error if it doesn't exist."
  (let ((fn (intern (format "doom-modeline-format--%s" key))))
    (when (functionp fn)
      `(:eval (,fn)))))

(defun doom-set-modeline (key &optional default)
  "Set the modeline format. Does nothing if the modeline KEY doesn't exist. If
DEFAULT is non-nil, set the default mode-line for all buffers."
  (when-let* ((modeline (doom-modeline key)))
    (setf (if default
              (default-value 'mode-line-format)
            (buffer-local-value 'mode-line-format (current-buffer)))
          modeline)))


;; no modeline in completion popups
(add-hook 'completion-list-mode-hook #'doom-hide-modeline-mode)

(use-package eldoc-eval
  :demand t
  :config
  (defun +doom-modeline-eldoc (text)
    (concat (when (display-graphic-p)
              (+doom-modeline--make-xpm
               (face-background 'doom-modeline-eldoc-bar nil t)
               +doom-modeline-height
               +doom-modeline-bar-width))
            text))

  ;; Show eldoc in the mode-line with `eval-expression'
  (defun +doom-modeline--show-eldoc (input)
    "Display string STR in the mode-line next to minibuffer."
    (with-current-buffer (eldoc-current-buffer)
      (let* ((str              (and (stringp input) input))
             (mode-line-format (or (and str (or (+doom-modeline-eldoc str) str))
                                   mode-line-format))
             mode-line-in-non-selected-windows)
        (force-mode-line-update)
        (sit-for eldoc-show-in-mode-line-delay))))

  (setq eldoc-in-minibuffer-show-fn #'+doom-modeline--show-eldoc)
  (eldoc-in-minibuffer-mode +1))

;; anzu and evil-anzu expose current/total state that can be displayed in the
;; mode-line.
(use-package evil-anzu
  :when (featurep 'evil)
  :init
  (add-transient-hook! #'evil-ex-start-search (require 'evil-anzu))
  (add-transient-hook! #'evil-ex-start-word-search (require 'evil-anzu))
  :config
  (setq anzu-cons-mode-line-p nil
        anzu-minimum-input-length 1
        anzu-search-threshold 250)

  ;; Avoid anzu conflicts across buffers
  (mapc #'make-variable-buffer-local
        '(anzu--total-matched anzu--current-position anzu--state
          anzu--cached-count anzu--cached-positions anzu--last-command
          anzu--last-isearch-string anzu--overflow-p))

  ;; Ensure anzu state is cleared when searches & iedit are done
  (add-hook 'isearch-mode-end-hook #'anzu--reset-status t)
  (add-hook 'bmacs-escape-hook #'anzu--reset-status t)
  (add-hook 'iedit-mode-end-hook #'anzu--reset-status))


;; Keep `+doom-modeline-current-window' up-to-date
(defvar +doom-modeline-current-window (frame-selected-window))
(defun +doom-modeline|set-selected-window (&rest _)
  "Sets `+doom-modeline-current-window' appropriately"
  (let ((win (frame-selected-window)))
    (unless (minibuffer-window-active-p win)
      (setq +doom-modeline-current-window win))))

(add-hook 'window-configuration-change-hook #'+doom-modeline|set-selected-window)
(add-hook 'focus-in-hook #'+doom-modeline|set-selected-window)
(advice-add #'handle-switch-frame :after #'+doom-modeline|set-selected-window)
(advice-add #'select-window :after #'+doom-modeline|set-selected-window)

;; fish-style modeline
(use-package shrink-path
  :commands (shrink-path-prompt shrink-path-file-mixed))


;;
;; Variables
;;

(defvar +doom-modeline-height 29
  "How tall the mode-line should be (only respected in GUI emacs).")

(defvar +doom-modeline-bar-width 3
  "How wide the mode-line bar should be (only respected in GUI emacs).")

(defvar +doom-modeline-vspc
  (propertize " " 'face 'variable-pitch)
  "TODO")

(defvar +doom-modeline-buffer-file-name-style 'truncate-upto-project
  "Determines the style used by `+doom-modeline-buffer-file-name'.
Given ~/Projects/FOSS/emacs/lisp/comint.el
truncate-upto-project => ~/P/F/emacs/lisp/comint.el
truncate-upto-root => ~/P/F/e/lisp/comint.el
truncate-all => ~/P/F/e/l/comint.el
relative-from-project => emacs/lisp/comint.el
relative-to-project => lisp/comint.el
file-name => comint.el")

;; externs
(defvar anzu--state nil)
(defvar evil-mode nil)
(defvar evil-state nil)
(defvar evil-visual-selection nil)
(defvar iedit-mode nil)
(defvar all-the-icons-scale-factor)
(defvar all-the-icons-default-adjust)


;;
;; Custom faces
;;

(defgroup +doom-modeline nil
  ""
  :group 'doom)

(defface doom-modeline-buffer-path
  '((t (:inherit mode-line-emphasis :bold t)))
  "Face used for the dirname part of the buffer path."
  :group '+doom-modeline)

(defface doom-modeline-buffer-file
  '((t (:inherit mode-line-buffer-id)))
  "Face used for the filename part of the mode-line buffer path."
  :group '+doom-modeline)

(defface doom-modeline-buffer-modified
  '((t (:inherit error :background nil :bold t)))
  "Face used for the 'unsaved' symbol in the mode-line."
  :group '+doom-modeline)

(defface doom-modeline-buffer-major-mode
  '((t (:inherit mode-line-emphasis :bold t)))
  "Face used for the major-mode segment in the mode-line."
  :group '+doom-modeline)

(defface doom-modeline-highlight
  '((t (:inherit mode-line-emphasis)))
  "Face for bright segments of the mode-line."
  :group '+doom-modeline)

(defface doom-modeline-panel
  '((t (:inherit mode-line-highlight)))
  "Face for 'X out of Y' segments, such as `+doom-modeline--anzu', `+doom-modeline--evil-substitute' and
`iedit'"
  :group '+doom-modeline)

(defface doom-modeline-info
  `((t (:inherit success :bold t)))
  "Face for info-level messages in the modeline. Used by `*vc'."
  :group '+doom-modeline)

(defface doom-modeline-warning
  `((t (:inherit warning :bold t)))
  "Face for warnings in the modeline. Used by `*flycheck'"
  :group '+doom-modeline)

(defface doom-modeline-urgent
  `((t (:inherit error :bold t)))
  "Face for errors in the modeline. Used by `*flycheck'"
  :group '+doom-modeline)

;; Bar
(defface doom-modeline-bar '((t (:inherit highlight)))
  "The face used for the left-most bar on the mode-line of an active window."
  :group '+doom-modeline)

(defface doom-modeline-eldoc-bar '((t (:inherit shadow)))
  "The face used for the left-most bar on the mode-line when eldoc-eval is
active."
  :group '+doom-modeline)

(defface doom-modeline-inactive-bar '((t (:inherit warning :inverse-video t)))
  "The face used for the left-most bar on the mode-line of an inactive window."
  :group '+doom-modeline)


;;
;; Modeline helpers
;;

(defsubst active ()
  (eq (selected-window) +doom-modeline-current-window))

;; Inspired from `powerline's `pl/make-xpm'.
(def-memoized! +doom-modeline--make-xpm (color height width)
  "Create an XPM bitmap."
  (propertize
   " " 'display
   (let ((data (make-list height (make-list width 1)))
         (color (or color "None")))
     (create-image
      (concat
       (format "/* XPM */\nstatic char * percent[] = {\n\"%i %i 2 1\",\n\". c %s\",\n\"  c %s\","
               (length (car data))
               (length data)
               color
               color)
       (apply #'concat
              (cl-loop with idx = 0
                       with len = (length data)
                       for dl in data
                       do (cl-incf idx)
                       collect
                       (concat "\""
                               (cl-loop for d in dl
                                        if (= d 0) collect (string-to-char " ")
                                        else collect (string-to-char "."))
                               (if (eq idx len) "\"};" "\",\n")))))
      'xpm t :ascent 'center))))

(defun +doom-modeline-buffer-file-name ()
  "Propertized `buffer-file-name' based on `+doom-modeline-buffer-file-name-style'."
  (propertize
   (pcase +doom-modeline-buffer-file-name-style
     ('truncate-upto-project (+doom-modeline--buffer-file-name 'shrink))
     ('truncate-upto-root (+doom-modeline--buffer-file-name-truncate))
     ('truncate-all (+doom-modeline--buffer-file-name-truncate t))
     ('relative-to-project (+doom-modeline--buffer-file-name-relative))
     ('relative-from-project (+doom-modeline--buffer-file-name-relative 'include-project))
     ('file-name (propertize (file-name-nondirectory buffer-file-name)
                             'face
                             (let ((face (or (and (buffer-modified-p)
                                                  'doom-modeline-buffer-modified)
                                             (and (active)
                                                  'doom-modeline-buffer-file))))
                               (when face `(:inherit ,face))))))
   'help-echo buffer-file-truename))

(defun +doom-modeline--buffer-file-name-truncate (&optional truncate-tail)
  "Propertized `buffer-file-name' that truncates every dir along path.
If TRUNCATE-TAIL is t also truncate the parent directory of the file."
  (let ((dirs (shrink-path-prompt (file-name-directory
                                   (or buffer-file-truename
                                       (file-truename buffer-file-name)))))
        (active (active)))
    (if (null dirs)
        (propertize "%b" 'face (if active 'doom-modeline-buffer-file))
      (let ((modified-faces (if (buffer-modified-p) 'doom-modeline-buffer-modified)))
        (let ((dirname (car dirs))
              (basename (cdr dirs))
              (dir-faces (or modified-faces (if active 'doom-modeline-project-root-dir)))
              (file-faces (or modified-faces (if active 'doom-modeline-buffer-file))))
          (concat (propertize (concat dirname
                                      (if truncate-tail (substring basename 0 1) basename)
                                      "/")
                              'face (if dir-faces `(:inherit ,dir-faces)))
                  (propertize (file-name-nondirectory buffer-file-name)
                              'face (if file-faces `(:inherit ,file-faces)))))))))

(defun +doom-modeline--buffer-file-name-relative (&optional include-project)
  "Propertized `buffer-file-name' showing directories relative to project's root only."
  (let ((root (bmacs-project-root))
        (active (active)))
    (if (null root)
        (propertize "%b" 'face (if active 'doom-modeline-buffer-file))
      (let* ((modified-faces (if (buffer-modified-p) 'doom-modeline-buffer-modified))
             (relative-dirs (file-relative-name (file-name-directory buffer-file-name)
                                                (if include-project (concat root "../") root)))
             (relative-faces (or modified-faces (if active 'doom-modeline-buffer-path)))
             (file-faces (or modified-faces (if active 'doom-modeline-buffer-file))))
        (if (equal "./" relative-dirs) (setq relative-dirs ""))
        (concat (propertize relative-dirs 'face (if relative-faces `(:inherit ,relative-faces)))
                (propertize (file-name-nondirectory buffer-file-name)
                            'face (if file-faces `(:inherit ,file-faces))))))))

(defun +doom-modeline--buffer-file-name (truncate-project-root-parent)
  "Propertized `buffer-file-name'.
If TRUNCATE-PROJECT-ROOT-PARENT is t space will be saved by truncating it down
fish-shell style.
Example:
~/Projects/FOSS/emacs/lisp/comint.el => ~/P/F/emacs/lisp/comint.el"
  (let* ((project-root (bmacs-project-root))
         (file-name-split (shrink-path-file-mixed project-root
                                                  (file-name-directory
                                                   (or buffer-file-truename
                                                       (file-truename buffer-file-name)))
                                                  (file-truename buffer-file-name)))
         (active (active)))
    (if (null file-name-split)
        (propertize "%b" 'face (if active 'doom-modeline-buffer-file))
      (pcase-let ((`(,root-path-parent ,project ,relative-path ,filename) file-name-split))
        (let ((modified-faces (if (buffer-modified-p) 'doom-modeline-buffer-modified)))
          (let ((sp-faces       (or modified-faces (if active 'font-lock-comment-face)))
                (project-faces  (or modified-faces (if active 'font-lock-string-face)))
                (relative-faces (or modified-faces (if active 'doom-modeline-buffer-path)))
                (file-faces     (or modified-faces (if active 'doom-modeline-buffer-file))))
            (let ((sp-props       `(,@(if sp-faces       `(:inherit ,sp-faces))      ,@(if active '(:weight bold))))
                  (project-props  `(,@(if project-faces  `(:inherit ,project-faces)) ,@(if active '(:weight bold))))
                  (relative-props `(,@(if relative-faces `(:inherit ,relative-faces))))
                  (file-props     `(,@(if file-faces     `(:inherit ,file-faces)))))
              (concat (propertize (if truncate-project-root-parent
                                      root-path-parent
                                    (abbreviate-file-name project-root))
                                  'face sp-props)
                      (propertize (concat project "/") 'face project-props)
                      (when relative-path (propertize relative-path 'face relative-props))
                      (propertize filename 'face file-props)))))))))


;;
;; Segments
;;

(def-modeline-segment! buffer-default-directory
  "Displays `default-directory'. This is for special buffers like the scratch
buffer where knowing the current project directory is important."
  (let ((face (if (active) 'doom-modeline-buffer-path)))
    (concat (if (display-graphic-p) " ")
            (all-the-icons-octicon
             "file-directory"
             :face face
             :v-adjust -0.05
             :height 1.25)
            (propertize (concat " " (abbreviate-file-name default-directory))
                        'face face))))

;;
(def-modeline-segment! buffer-info
  "Combined information about the current buffer, including the current working
directory, the file name, and its state (modified, read-only or non-existent)."
    (concat (cond (buffer-read-only
                   (concat (all-the-icons-octicon
                            "lock"
                            :face 'doom-modeline-warning
                            :v-adjust -0.05)
                           " "))
                  ((buffer-modified-p)
                   (concat (all-the-icons-faicon
                            "floppy-o"
                            :face 'doom-modeline-buffer-modified
                            :v-adjust -0.0575)
                           " "))
                  ((and buffer-file-name
                        (not (file-exists-p buffer-file-name)))
                   (concat (all-the-icons-octicon
                            "circle-slash"
                            :face 'doom-modeline-urgent
                            :v-adjust -0.05)
                           " "))
                  ((buffer-narrowed-p)
                   (concat (all-the-icons-octicon
                            "fold"
                            :face 'doom-modeline-warning
                            :v-adjust -0.05)
                           " ")))
            (if buffer-file-name
                (+doom-modeline-buffer-file-name)
              "%b")))

;;
(def-modeline-segment! buffer-info-simple
  "Display only the current buffer's name, but with fontification."
  (propertize
   "%b"
   'face (cond ((and buffer-file-name (buffer-modified-p))
                'doom-modeline-buffer-modified)
               ((active) 'doom-modeline-buffer-file))))

;;
(def-modeline-segment! buffer-encoding
  "Displays the encoding and eol style of the buffer the same way Atom does."
  (concat (pcase (coding-system-eol-type buffer-file-coding-system)
            (0 "LF  ")
            (1 "CRLF  ")
            (2 "CR  "))
          (let ((sys (coding-system-plist buffer-file-coding-system)))
            (cond ((memq (plist-get sys :category) '(coding-category-undecided coding-category-utf-8))
                   "UTF-8")
                  (t (upcase (symbol-name (plist-get sys :name))))))
          "  "))

;;
(def-modeline-segment! major-mode
  "The major mode, including process, environment and text-scale info."
  (propertize
   (concat (format-mode-line mode-name)
           (when (stringp mode-line-process)
             mode-line-process)
           (and (featurep 'face-remap)
                (/= text-scale-mode-amount 0)
                (format " (%+d)" text-scale-mode-amount)))
   'face (if (active) 'doom-modeline-buffer-major-mode)))

;;
(def-modeline-segment! vcs
  "Displays the current branch, colored based on its state."
  (when (and vc-mode buffer-file-name)
    (let* ((backend (vc-backend buffer-file-name))
           (state   (vc-state buffer-file-name backend)))
      (let ((face    'mode-line-inactive)
            (active  (active))
            (all-the-icons-default-adjust -0.1))
        (concat "  "
                (cond ((memq state '(edited added))
                       (if active (setq face 'doom-modeline-info))
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :v-adjust -0.05))
                      ((eq state 'needs-merge)
                       (if active (setq face 'doom-modeline-info))
                       (all-the-icons-octicon "git-merge" :face face))
                      ((eq state 'needs-update)
                       (if active (setq face 'doom-modeline-warning))
                       (all-the-icons-octicon "arrow-down" :face face))
                      ((memq state '(removed conflict unregistered))
                       (if active (setq face 'doom-modeline-urgent))
                       (all-the-icons-octicon "alert" :face face))
                      (t
                       (if active (setq face 'font-lock-doc-face))
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :v-adjust -0.05)))
                " "
                (propertize (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))
                            'face (if active face))
                " ")))))

;;
(defun +doom-ml-icon (icon &optional text face voffset)
  "Displays an octicon ICON with FACE, followed by TEXT. Uses
`all-the-icons-octicon' to fetch the icon."
  (concat (if vc-mode " " "  ")
          (when icon
            (concat
             (all-the-icons-material icon :face face :height 1.1 :v-adjust (or voffset -0.2))
             (if text +doom-modeline-vspc)))
          (when text
            (propertize text 'face face))
          (if vc-mode "  " " ")))

(def-modeline-segment! flycheck
  "Displays color-coded flycheck error status in the current buffer with pretty
icons."
  (when (boundp 'flycheck-last-status-change)
    (pcase flycheck-last-status-change
      ('finished (if flycheck-current-errors
                     (let-alist (flycheck-count-errors flycheck-current-errors)
                       (let ((sum (+ (or .error 0) (or .warning 0))))
                         (+doom-ml-icon "do_not_disturb_alt"
                                        (number-to-string sum)
                                        (if .error 'doom-modeline-urgent 'doom-modeline-warning)
                                        -0.25)))
                   (+doom-ml-icon "check" nil 'doom-modeline-info)))
      ('running     (+doom-ml-icon "access_time" nil 'font-lock-doc-face -0.25))
      ('no-checker  (+doom-ml-icon "sim_card_alert" "-" 'font-lock-doc-face))
      ('errored     (+doom-ml-icon "sim_card_alert" "Error" 'doom-modeline-urgent))
      ('interrupted (+doom-ml-icon "pause" "Interrupted" 'font-lock-doc-face)))))
      ;; ('interrupted (+doom-ml-icon "x" "Interrupted" 'font-lock-doc-face)))))

;;
(defsubst doom-column (pos)
  (save-excursion (goto-char pos)
                  (current-column)))

(def-modeline-segment! selection-info
  "Information about the current selection, such as how many characters and
lines are selected, or the NxM dimensions of a block selection."
  (when (and (active) (or mark-active (eq evil-state 'visual)))
    (let ((reg-beg (region-beginning))
          (reg-end (region-end)))
      (propertize
       (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max)))))
         (cond ((or (bound-and-true-p rectangle-mark-mode)
                    (eq 'block evil-visual-selection))
                (let ((cols (abs (- (doom-column reg-end)
                                    (doom-column reg-beg)))))
                  (format "%dx%dB" lines cols)))
               ((eq 'line evil-visual-selection)
                (format "%dL" lines))
               ((> lines 1)
                (format "%dC %dL" (- (1+ reg-end) reg-beg) lines))
               (t
                (format "%dC" (- (1+ reg-end) reg-beg)))))
       'face 'doom-modeline-highlight))))


;;
(defun +doom-modeline--macro-recording ()
  "Display current Emacs or evil macro being recorded."
  (when (and (active) (or defining-kbd-macro executing-kbd-macro))
    (let ((sep (propertize " " 'face 'doom-modeline-panel)))
      (concat sep
              (propertize (if (bound-and-true-p evil-this-macro)
                              (char-to-string evil-this-macro)
                            "Macro")
                          'face 'doom-modeline-panel)
              sep
              (all-the-icons-octicon "triangle-right"
                                     :face 'doom-modeline-panel
                                     :v-adjust -0.05)
              sep))))

(defsubst +doom-modeline--anzu ()
  "Show the match index and total number thereof. Requires `anzu', also
`evil-anzu' if using `evil-mode' for compatibility with `evil-search'."
  (when (and anzu--state (not iedit-mode))
    (propertize
     (let ((here anzu--current-position)
           (total anzu--total-matched))
       (cond ((eq anzu--state 'replace-query)
              (format " %d replace " total))
             ((eq anzu--state 'replace)
              (format " %d/%d " here total))
             (anzu--overflow-p
              (format " %s+ " total))
             (t
              (format " %s/%d " here total))))
     'face (if (active) 'doom-modeline-panel))))

(defsubst +doom-modeline--evil-substitute ()
  "Show number of matches for evil-ex substitutions and highlights in real time."
  (when (and evil-mode
             (or (assq 'evil-ex-substitute evil-ex-active-highlights-alist)
                 (assq 'evil-ex-global-match evil-ex-active-highlights-alist)
                 (assq 'evil-ex-buffer-match evil-ex-active-highlights-alist)))
    (propertize
     (let ((range (if evil-ex-range
                      (cons (car evil-ex-range) (cadr evil-ex-range))
                    (cons (line-beginning-position) (line-end-position))))
           (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
       (if pattern
           (format " %s matches " (how-many pattern (car range) (cdr range)))
         " - "))
     'face (if (active) 'doom-modeline-panel))))

(defun doom-themes--overlay-sort (a b)
  (< (overlay-start a) (overlay-start b)))

(defsubst +doom-modeline--iedit ()
  "Show the number of iedit regions matches + what match you're on."
  (when (and iedit-mode iedit-occurrences-overlays)
    (propertize
     (let ((this-oc (or (let ((inhibit-message t))
                          (iedit-find-current-occurrence-overlay))
                        (progn (iedit-prev-occurrence)
                               (iedit-find-current-occurrence-overlay))))
           (length (length iedit-occurrences-overlays)))
       (format " %s/%d "
               (if this-oc
                   (- length
                      (length (memq this-oc (sort (append iedit-occurrences-overlays nil)
                                                  #'doom-themes--overlay-sort)))
                      -1)
                 "-")
               length))
     'face (if (active) 'doom-modeline-panel))))

(def-modeline-segment! matches
  "Displays: 1. the currently recording macro, 2. A current/total for the
current search term (with anzu), 3. The number of substitutions being conducted
with `evil-ex-substitute', and/or 4. The number of active `iedit' regions."
  (let ((meta (concat (+doom-modeline--macro-recording)
                      (+doom-modeline--anzu)
                      (+doom-modeline--evil-substitute)
                      (+doom-modeline--iedit))))
     (or (and (not (equal meta "")) meta)
         (if buffer-file-name " %I "))))

;; TODO Include other information
(def-modeline-segment! media-info
  "Metadata regarding the current file, such as dimensions for images."
  (cond ((eq major-mode 'image-mode)
         (cl-destructuring-bind (width . height)
             (image-size (image-get-display-property) :pixels)
           (format "  %dx%d  " width height)))))

(def-modeline-segment! bar
  "The bar regulates the height of the mode-line in GUI Emacs.
Returns \"\" to not break --no-window-system."
  (if (display-graphic-p)
      (+doom-modeline--make-xpm
       (face-background (if (active)
                            'doom-modeline-bar
                          'doom-modeline-inactive-bar)
                        nil t)
       +doom-modeline-height
       +doom-modeline-bar-width)
    ""))


;;
;; Mode lines
;;

(def-modeline! main
  (bar matches " " buffer-info "  %l:%c %p  " selection-info)
  (buffer-encoding major-mode vcs flycheck))

(def-modeline! minimal
  (bar matches " " buffer-info)
  (media-info major-mode))

(def-modeline! special
  (bar matches " " buffer-info-simple "  %l:%c %p  " selection-info)
  (buffer-encoding major-mode flycheck))

(def-modeline! project
  (bar buffer-default-directory)
  (major-mode))

(def-modeline! media
  (bar " %b  ")
  (media-info major-mode))


;;
;; Hooks
;;

(defun +doom-modeline|init ()
  "Set the default modeline."
  (doom-set-modeline 'main t)

  ;; This scratch buffer is already created and doesn't get a modeline. For the
  ;; love of Emacs, someone give the man a modeline!
  (with-current-buffer "*scratch*"
    (doom-set-modeline 'main)))

(defun +doom-modeline|set-special-modeline ()
  (doom-set-modeline 'special))

(defun +doom-modeline|set-media-modeline ()
  (doom-set-modeline 'media))

(defun +doom-modeline|set-project-modeline ()
  (doom-set-modeline 'project))


;;
;; Bootstrap
;;

(add-hook 'bmacs-post-init-hook #'+doom-modeline|init)
(add-hook 'doom-scratch-buffer-hook #'+doom-modeline|set-special-modeline)
(add-hook '+doom-dashboard-mode-hook #'+doom-modeline|set-project-modeline)

(add-hook 'org-src-mode-hook #'+doom-modeline|set-special-modeline)
(add-hook 'image-mode-hook   #'+doom-modeline|set-media-modeline)
(add-hook 'circe-mode-hook   #'+doom-modeline|set-special-modeline)

#+END_SRC

*** doom-quit
Quit prompt with messages

#+BEGIN_SRC emacs-lisp
(defvar +doom-quit-messages
  '(;; from Doom 1
    "Please don't leave, there's more demons to toast!"
    "Let's beat it -- This is turning into a bloodbath!"
    "I wouldn't leave if I were you. DOS is much worse."
    "Don't leave yet -- There's a demon around that corner!"
    "Ya know, next time you come in here I'm gonna toast ya."
    "Go ahead and leave. See if I care."
    "Are you sure you want to quit this great editor?"
    ;; Custom
    "(setq nothing t everything 'permitted)"
    "Emacs will remember that."
    "Emacs, Emacs never changes."
    "Hey! Hey, M-x listen!"
    "I'm the man who's going to burn your house down! With lemons!"
    "It's not like I'll miss you or anything, b-baka!"
    "Okay, look. We've both said a lot of things you're going to regret..."
    "Wake up, Mr. Stallman. Wake up and smell the ashes."
    "You are *not* prepared!")
  "A list of quit messages, picked randomly by `+doom-quit'. Taken from
http://doom.wikia.com/wiki/Quit_messages and elsewhere.")

(defun +doom|quit (&rest _)
  (doom-quit-p
   (format "%s  Quit?"
           (nth (random (length +doom-quit-messages))
                +doom-quit-messages))))

;;
(remove-hook 'kill-emacs-query-functions #'doom-quit-p)
(add-hook 'kill-emacs-query-functions #'+doom|quit)
#+END_SRC

*** evil-goggles

#+BEGIN_SRC emacs-lisp
(use-package evil-goggles
  :commands evil-goggles-mode
  :init
  (setq evil-goggles-duration 0.2)
  (add-hook 'bmacs-post-init-hook #'evil-goggles-mode t))

(defun +evil-goggles/toggle ()
  "Toggle evil goggles mode."
  (interactive)
  (if evil-goggles-mode
      (evil-goggles-mode -1)
    (evil-goggles-mode +1)))
#+END_SRC

*** hl-todo
Highlight toodledoos

#+BEGIN_SRC emacs-lisp
(defun +hl-todo|use-face-detection ()
  "Use a different, more primitive method of locating todo keywords.

This is useful for major modes that don't use or have a valid syntax-table entry
for comment start/end characters."
  (set (make-local-variable 'hl-todo-keywords)
       '(((lambda (limit)
            (let (case-fold-search)
              (and (re-search-forward hl-todo-regexp limit t)
                   (memq 'font-lock-comment-face (bmacs-enlist (get-text-property (point) 'face))))))
          (1 (hl-todo-get-face) t t))))
  (when hl-todo-mode
    (hl-todo-mode -1)
    (hl-todo-mode +1)))


(use-package hl-todo
  :commands hl-todo-mode
  :init (add-hook 'prog-mode-hook #'hl-todo-mode)
  :config
  (setq hl-todo-keyword-faces
        `(("TODO"  . ,(face-foreground 'warning))
          ("FIXME" . ,(face-foreground 'error))
          ("NOTE"  . ,(face-foreground 'success))))

  ;; Use a more primitive todo-keyword detection method in major modes that
  ;; don't use/have a valid syntax table entry for comments.
  (add-hook 'pug-mode #'+hl-todo|use-face-detection)
  (add-hook 'haml-mode #'+hl-todo|use-face-detection))
#+END_SRC

*** nav-flash
Flash the current line periodically to indicate current buffer position, especially after large movements.

**** Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs*blink-cursor-maybe (orig-fn &rest args)
  "Blink current line if the window has moved."
  (let ((point (save-excursion (goto-char (window-start))
                               (point-marker))))
    (apply orig-fn args)
    (unless (or (derived-mode-p 'term-mode)
                (equal point
                       (save-excursion (goto-char (window-start))
                                       (point-marker))))
      (bmacs/blink-cursor))))

(defun bmacs/blink-cursor (&rest _)
  "Blink current line using `nav-flash'."
  (interactive)
  (unless (minibufferp)
    (nav-flash-show)
    ;; only show in the current window
    (overlay-put compilation-highlight-overlay 'window (selected-window))))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package nav-flash
  :commands nav-flash-show
  :init
  (advice-add #'windmove-do-window-select :around #'bmacs*blink-cursor-maybe)
  (advice-add #'recenter :around #'bmacs*blink-cursor-maybe)

  (after! evil
    (advice-add #'evil--jumps-jump   :after #'bmacs/blink-cursor)
    (advice-add #'evil-window-top    :after #'bmacs/blink-cursor)
    (advice-add #'evil-window-middle :after #'bmacs/blink-cursor)
    (advice-add #'evil-window-bottom :after #'bmacs/blink-cursor)))

#+END_SRC

*** highlight-indentation
Simply allows indentation to be visibly highlighted

#+BEGIN_SRC emacs-lisp
(use-package highlight-indentation
  :commands (highlight-indentation-mode highlight-indentation-current-column-mode))
#+END_SRC

*** highlight-numbers
Highlights numbers for modes with sub-par number fontification

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers :commands highlight-numbers-mode)
#+END_SRC

*** hl-line
Highlights the current line

#+BEGIN_SRC emacs-lisp
(use-package hl-line ; built-in
  :demand t
  :init
  (add-hook! '(prog-mode-hook text-mode-hook conf-mode-hook) #'hl-line-mode)
  :config
  ;; I don't need hl-line showing in other windows. This also offers a small
  ;; speed boost when buffer is displayed in multiple windows.
  (setq hl-line-sticky-flag nil
        global-hl-line-sticky-flag nil)

  ;; On Emacs 26+, when point is on the last line, hl-line highlights bleed into
  ;; the rest of the window after eob. This is the fix.
  (when (boundp 'display-line-numbers)
    (defun bmacs--line-range ()
      (cons (line-beginning-position)
            (cond ((save-excursion
                     (goto-char (line-end-position))
                     (and (eobp) (not (bolp))))
                   (1- (line-end-position)))
                  ((or (eobp) (save-excursion (forward-line) (eobp)))
                   (line-end-position))
                  (t
                   (line-beginning-position 2)))))
    (setq hl-line-range-function #'bmacs--line-range))

  ;; Disable `hl-line' in evil-visual mode (temporarily). `hl-line' can make
  ;; the selection region harder to see while in evil visual mode.
  (defun bmacs|disable-hl-line () (hl-line-mode -1))

  (add-hook 'evil-visual-state-entry-hook #'bmacs|disable-hl-line)
  (add-hook 'evil-visual-state-exit-hook #'hl-line-mode))
#+END_SRC

*** rainbow-delimiters
Easily distinguish the delimiter pairs using colors especially in lisp modes.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode
  :config (setq rainbow-delimiters-max-face-count 3)
  :init (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

*** visual-fill-column
Allows margins to be dynamically resized.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :commands visual-fill-column-mode
  :config
  (setq-default
    visual-fill-column-center-text t
    visual-fill-column-width
    ;; take Emacs 26 line numbers into account
    (+ (if (boundp 'display-line-numbers) 6 0)
       fill-column)))
#+END_SRC

*** nlinum-mode
If we're not using Emacs 26+ we need nlinum to support line numbers.

#+BEGIN_SRC emacs-lisp
(unless (boundp 'display-line-numbers)
  (use-package nlinum
    :commands nlinum-mode
    :config
    (setq nlinum-highlight-current-line t)
    (add-hook 'hl-line-mode-hook #'(lambda ()
      (remove-overlays (point-min) (point-max) 'face 'hl-line)))

    (defun bmacs|init-nlinum-width ()
      "Calculate line number column width beforehand (optimization)."
      (setq nlinum--width
            (length (save-excursion (goto-char (point-max))
                                    (format-mode-line "%l")))))
    (add-hook 'nlinum-mode-hook #'bmacs|init-nlinum-width))

  (use-package nlinum-hl
    :demand t
    :after nlinum
    :config
    ;; With `markdown-fontify-code-blocks-natively' enabled in `markdown-mode',
    ;; line numbers tend to vanish next to code blocks.
    (advice-add #'markdown-fontify-code-block-natively
                :after #'nlinum-hl-do-markdown-fontify-region)

    ;; When using `web-mode's code-folding an entire range of line numbers will
    ;; vanish in the affected area.
    (advice-add #'web-mode-fold-or-unfold :after #'nlinum-hl-do-generic-flush)

    ;; Changing fonts can leave nlinum line numbers in their original size; this
    ;; forces them to resize.
    (advice-add #'set-frame-font :after #'nlinum-hl-flush-all-windows)))
#+END_SRC

*** winner-mode
Windowing operations (mostly undo/redo)

#+BEGIN_SRC emacs-lisp
(defvar winner-dont-bind-my-keys t) ; I'll bind keys myself
(autoload 'winner-mode "winner" nil t)
(add-hook 'bmacs-post-init-hook #'winner-mode)

#+END_SRC

** Navigation

*** ace-link
Easily select links to open.

#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :demand t
  :config (ace-link-setup-default))
#+END_SRC

*** ace-window
Easily select windows for various actions.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window ace-swap-window ace-delete-window
             ace-select-window ace-delete-other-windows)
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-scope 'frame
        aw-background t))
#+END_SRC

*** avy
Quickly jump to things

**** Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/evil-avy-goto-char-2-after-insert ()
  (interactive)
  (evil-avy-goto-char-2)
  (goto-char (+ (point) 2))
  (evil-insert-state))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-goto-char-2 avy-goto-line avy-go-word-or-subword-1 avy-goto-char-timer)
  :config
  (setq avy-all-windows 'all-frames
        avy-background t
        avy-timeout-seconds 0.3))
#+END_SRC

*** wgrep
Edit grep buffer and save changes

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :commands (wgrep-setup wgrep-change-to-wgrep-mode)
  :config
  (setq wgrep-auto-save-buffer t)
  (map! :map wgrep-mode-map
        (:desc "wgrep mode actions"
         :prefix ","
         :desc "finish edit"                 :n "s" 'wgrep-finish-edit
         :desc "discard edit"                :n "d" 'wgrep-abort-changes
         :desc "exit wgrep"                  :n "x" 'wgrep-exit)))
#+END_SRC


*** dumb-jump
Jump to any definition ... the dumb way!

**** Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/jump-definition (&optional other-window)
  "Jump to the definition of the symbol at point using `dumb-jump'"
  (interactive)
  (evil--jumps-push)
  (if other-window
      (dumb-jump-go-other-window)
    (dumb-jump-go)))

(defun bmacs/jump-definition-other-window ()
  (interactive)
  (bmacs/jump-definition t))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :commands (dumb-jump-go dumb-jump-quick-look dumb-jump-go-other-window
             dumb-jump-back dumb-jump-result-follow)
  :config
  (setq dumb-jump-default-project bmacs-emacs-dir
        dumb-jump-aggressive nil
        dumb-jump-use-visible-window nil
        dumb-jump-selector 'ivy))

;; Perform recenter after various jumps
(add-hook!
  '(imenu-after-jump-hook evil-jumps-post-jump-hook
    counsel-grep-post-action-hook dumb-jump-after-jump-hook)
  #'recenter)
#+END_SRC

** Org Mode (Needs Cleaning)
It's org-mode ya'll

*** Org

**** Functions

#+BEGIN_SRC emacs-lisp
(defun +borg/open-organizer ()
  "Open the default organizer"
  (interactive)
  (find-file +borg-organizer))

(defun +borg|realign-table-maybe ()
  "Auto-align table under cursor and re-calculate formulas."
  (when (org-at-table-p)
    (save-excursion
      (quiet! (org-table-recalculate)))))

(defun +borg|update-cookies ()
  "Update counts in headlines (aka \"cookies\")."
  (when (and buffer-file-name (file-exists-p buffer-file-name))
    (org-update-statistics-cookies t)))

(defun +borg/dwim-at-point ()
  "Do-what-I-mean at point. This includes following timestamp links, aligning
  tables, toggling checkboxes/todos, executing babel blocks, previewing latex
  fragments, opening links, or refreshing images."
  (interactive)
  (let* ((scroll-pt (window-start))
         (context (org-element-context))
         (type (org-element-type context)))
    (cond
     ((memq type '(planning timestamp))
      (org-follow-timestamp-link))

     ((memq type '(table table-row))
      (if (org-element-property :tblfm (org-element-property :parent context))
          (org-table-recalculate t)
        (org-table-align)))

     ((org-element-property :checkbox (org-element-lineage context '(item) t))
      (let ((match (and (org-at-item-checkbox-p) (match-string 1))))
        (org-toggle-checkbox (if (equal match "[ ]") '(16)))))

     ((and (eq type 'headline)
           (string= "ARCHIVE" (car-safe (org-get-tags))))
      (org-force-cycle-archived))

     ((eq type 'headline)
      (org-todo
       (cond
        ((eq (org-element-property :todo-type context) 'done) 'none)
        ((eq (org-element-property :todo-type context) 'todo) 'done)
        (t 'todo))))

     ((org-element-property :bullet (org-element-lineage context '(item) t))
      (+borg/toggle-checkbox))

     ((eq type 'babel-call)
      (org-babel-lob-execute-maybe))

     ((memq type '(src-block inline-src-block))
      (org-babel-execute-src-block))

     ((memq type '(latex-fragment latex-environment))
      (org-toggle-latex-fragment))

     ((eq type 'link)
      (let ((path (org-element-property :path (org-element-lineage context '(link) t))))
        (if (and path (image-type-from-file-name path))
            (+borg/refresh-inline-images)
          (org-open-at-point))))

     (t (+borg/refresh-inline-images)))
    (set-window-start nil scroll-pt)))

(defun +borg/indent ()
  "Indent the current item (header or item). Otherwise, forward to
  `self-insert-command'."
  (interactive)
  (cond ((org-at-item-p)
         (org-indent-item-tree))
        ((org-at-heading-p)
         (ignore-errors (org-demote)))
        ((org-in-src-block-p t)
         (indent-for-tab-command))
        (t
         (call-interactively #'self-insert-command))))

(defun +borg/indent-or-next-field-or-yas-expand ()
  "Depending on the context either a) indent the current line, b) go the next
  table field or c) run `yas-expand'."
  (interactive)
  (call-interactively
   (cond ((and (bound-and-true-p yas-minor-mode)
               (yas--templates-for-key-at-point))
          #'yas-expand)
         ((org-at-table-p)
          #'org-table-next-field)
         (t
          #'+borg/indent))))

(defun +borg/dedent ()
  "Dedent the current item (header or item). Otherwise, forward to
  `self-insert-command'."
  (interactive)
  (cond ((org-at-item-p)
         (org-list-indent-item-generic
          -1 nil
          (save-excursion
            (when (org-region-active-p)
              (goto-char (region-beginning)))
            (org-list-struct))))
        ((org-at-heading-p)
         (ignore-errors (org-promote)))
        (t
         (call-interactively #'self-insert-command))))

(defun +borg/dedent-or-prev-field ()
  "Depending on the context either dedent the current item or go the previous
  table field."
  (interactive)
  (call-interactively
   (if (org-at-table-p)
       #'org-table-previous-field
     #'+borg/dedent)))

(defun +borg/insert-item (direction)
  "Inserts a new heading, table cell or item, depending on the context.
  DIRECTION can be 'above or 'below.

  I use this instead of `org-insert-item' or `org-insert-heading' which are too
  opinionated and perform this simple task incorrectly (e.g. whitespace in the
  wrong places)."
  (interactive)
  (let* ((context (org-element-lineage
                   (org-element-context)
                   '(table table-row headline inlinetask item plain-list)
                   t))
         (type (org-element-type context)))
    (cond ((eq type 'item)
           (let ((marker (org-element-property :bullet context))
                 (pad (save-excursion
                        (back-to-indentation)
                        (- (point) (line-beginning-position)))))
             (pcase direction
               ('below
                (goto-char (line-end-position))
                (insert (concat  "\n" (make-string pad ? ) marker)))
               ('above
                (goto-char (line-beginning-position))
                (insert (make-string pad ? ) marker)
                (save-excursion (insert "\n")))))
           (when (org-element-property :checkbox context)
             (insert "[ ] ")))

          ((memq type '(table table-row))
           (pcase direction
             ('below (org-table-insert-row t))
             ('above (+borg/table-prepend-row-or-shift-up))))

          ((memq type '(headline inlinetask plain-list))
           (let* ((subcontext (org-element-context))
                  (level (save-excursion
                           (org-back-to-heading)
                           (org-element-property
                            :level
                            (if (eq (org-element-type subcontext) 'headline)
                                subcontext
                              1)))))
             (pcase direction
               ('below
                (let ((at-eol (= (point) (1- (line-end-position)))))
                  (goto-char (line-end-position))
                  (org-end-of-subtree)
                  (insert (concat "\n"
                                  (when (= level 1)
                                    (if at-eol
                                        (ignore (cl-incf level))
                                      "\n"))
                                  (make-string level ?*)
                                  " "))))
               ('above
                (org-back-to-heading)
                (org-insert-heading)
                (when (= level 1)
                  (save-excursion (evil-open-above 1))
                  (save-excursion (insert "\n")))))
             (when (org-element-property :todo-type context)
               (org-todo 'todo))))

          (t (user-error "Not a valid list, heading or table")))

    (when (bound-and-true-p evil-mode)
      (evil-append-line 1))))

(defun +org-get-property (name &optional _file) ; TODO Add FILE
  "Get a propery from an org file."
  (save-excursion
    (goto-char 1)
    (re-search-forward (format "^#\\+%s:[ \t]*\\([^\n]+\\)" (upcase name)) nil t)
    (buffer-substring-no-properties (match-beginning 1) (match-end 1))))

(defun +borg/refresh-inline-images ()
  "Refresh image previews in the current heading/tree."
  (interactive)
  (if (> (length org-inline-image-overlays) 0)
      (org-remove-inline-images)
    (org-display-inline-images
     t t
     (if (org-before-first-heading-p)
         (line-beginning-position)
       (save-excursion (org-back-to-heading) (point)))
     (if (org-before-first-heading-p)
         (line-end-position)
       (save-excursion (org-end-of-subtree) (point))))))

(defun +borg/toggle-checkbox ()
  "Toggle the presence of a checkbox in the current item."
  (interactive)
  (org-toggle-checkbox '(4)))

(defun +borg/org-file-is-large-p ()
  (when (buffer-file-name)
    (let* ((filename (buffer-file-name))
           (size (nth 7 (file-attributes filename))))
      (> (* 1024 size) +borg-large-file-size))))

(defun +borg/org-load-hook (func &optional append)
  (if (featurep 'org)
      (add-hook 'bmacs-post-init-hook func append)
    (add-hook 'org-load-hook func append)))

(defun evil-org-eol-call (fun)
  "Go to end of line and call provided function.
FUN function callback"
  (end-of-line)
  (funcall fun)
  (evil-append nil))

(defun borg-has-child-p ()
  (save-excursion
    (org-goto-first-child)))

(defun borg-folded-p ()
  "Return t if current heading is folded, nil otherwise"
  (let ((goal-column 0) eoh eol eos struct)
    ;; First, determine end of headline (EOH), end of subtree or item
    ;; (EOS)
    (save-excursion
	    (org-back-to-heading)
	    (setq eoh (save-excursion (outline-end-of-heading) (point)))
	    (setq eos (save-excursion (org-end-of-subtree t t)
				                        (when (bolp) (backward-char)) (point)))
      ;; Determine end invisible part of buffer (EOL)
      (beginning-of-line 2)
      (while (and (not (eobp)) ;This is like `next-line'.
		              (get-char-property (1- (point)) 'invisible))
	      (goto-char (next-single-char-property-change (point) 'invisible))
	      (and (eolp) (beginning-of-line 2)))
      (setq eol (point)))
    ;; Determine if current heading if folded
    (or (= eos eoh)
        (>= eol eos)
	      (not (string-match "\\S-" (buffer-substring eol eos))))))

(defun +borg/show-subtree-or-descend-child ()
  (interactive)
  (cond ((not (borg-has-child-p)) (outline-show-subtree))
        ((borg-folded-p) (outline-show-children))
        (t (org-goto-first-child))))

(defun +borg/close-subtree-or-ascend-parent ()
  (interactive)
  (cond ((not (org-at-heading-p)) (org-back-to-heading))
        ((borg-folded-p) (outline-up-heading 1))
        (t (outline-hide-subtree))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(setq org-modules '(org-bibtex org-docview org-info))

(use-package org
  :ensure org-plus-contrib
  :pin org
  :defer t)

;; Ensure ELPA org is prioritized above built-in org.
(setq load-path (seq-filter (lambda (x) (not (string-match-p "org$" x))) load-path))

;; Custom variables
(defvar +borg-dir (expand-file-name "~/org/")
  "The directory where org files are kept.")

(defvar +borg-organizer (concat +borg-dir "organizer.org")
  "The default organizer.")

(defvar +borg-large-file-size 500
  "The size threshold past which an org file is considered large in kb. If an org
  file exceeds this size some optimizations will be applied")

(use-package toc-org
             :commands toc-org-enable
             :init (add-hook 'org-mode-hook #'toc-org-enable))

(use-package org-bullets
             :commands org-bullets-mode
             :init (add-hook 'org-mode-hook #'org-bullets-mode))

(defun +borg|hook ()
  "Run everytime `org-mode' is enabled."
  (add-hook 'evil-insert-state-exit-hook #'+borg|realign-table-maybe nil t)
  (add-hook 'evil-insert-state-exit-hook #'+borg|update-cookies nil t)
  (+org-evil-mode +1)

  (unless (+borg/org-file-is-large-p)
    (add-hook 'before-save-hook #'+borg|update-cookies nil t))
  ;;
  (setq line-spacing 1)
  (visual-line-mode +1)
  (org-indent-mode +1)
  (bmacs|disable-line-numbers)
  (setq-local company-idle-delay nil)
  (undo-tree-mode +1)
  (setq-local evil-auto-indent nil)

  ;; show-paren-mode causes problems for org-indent-mode, so disable it
  (set (make-local-variable 'show-paren-mode) nil))

(defun +borg|init ()
  "Run once, when org is first loaded."
  (define-minor-mode +org-evil-mode
    "Evil-mode bindings for org-mode."
    :init-value nil
    :lighter " !"
    :keymap (make-sparse-keymap)
    :group 'evil-org)


  (defvaralias 'org-directory '+borg-dir)
  (+borg-init-ui)
  (+borg-hacks))

;;
(defun +borg-init-ui ()
  "Configures the UI for `org-mode'."
  (setq-default
   org-adapt-indentation nil
   org-agenda-dim-blocked-tasks nil
   org-agenda-files (if (file-exists-p +borg-dir) (directory-files +borg-dir t "\\.org$" t) nil)
   org-agenda-inhibit-startup t
   org-agenda-skip-unavailable-files nil
   org-cycle-include-plain-lists t
   org-cycle-separator-lines 1
   org-entities-user '(("flat"  "\\flat" nil "" "" "266D" "♭") ("sharp" "\\sharp" nil "" "" "266F" "♯"))
   org-ellipsis "  "
   org-fontify-quote-and-verse-blocks t
   org-footnote-auto-label 'plain
   org-hidden-keywords nil
   org-hide-emphasis-markers nil
   org-hide-leading-stars t
   org-hide-leading-stars-before-indent-mode t
   org-image-actual-width nil
   org-indent-indentation-per-level 2
   org-indent-mode-turns-on-hiding-stars t
   org-pretty-entities nil
   org-pretty-entities-include-sub-superscripts t
   org-priority-faces `((?a . ,(doom-color 'red))
                        (?b . ,(doom-color 'yellow))
                        (?c . ,(doom-color 'green)))
   org-startup-folded t
   org-startup-indented t
   org-startup-with-inline-images nil
   org-tags-column 0
   org-todo-keywords '((sequence "TODO(t)" "IN-PROGRESS(i)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c)"))
   org-use-sub-superscripts '{}
   outline-blank-line t
   org-log-done 'time)

  ;; Use ivy/helm if either is available
  (setq-default org-completion-use-ido nil
                org-outline-path-complete-in-steps nil))

(defun +borg-hacks ()
  "Getting org to behave."
  ;; Don't open separate windows
  (cl-pushnew '(file . find-file) org-link-frame-setup)

  ;; Let OS decide what to do with files when opened
  (setq org-file-apps
        `(("\\.org$" . emacs)
          (t . ,(cond (IS-MAC "open -R \"%s\"")
                      (IS-LINUX "xdg-open \"%s\"")))))

  (defun +borg|remove-occur-highlights ()
    "Remove org occur highlights on ESC in normal mode."
    (when org-occur-highlights
      (org-remove-occur-highlights)
      t))
  (add-hook 'bmacs-escape-hook #'+borg|remove-occur-highlights))

(+borg/org-load-hook #'+borg|init)
(add-hook 'org-mode-hook #'+borg|hook)

;; Disable auto pair ' in elisp mode
(sp-local-pair 'org-mode "'" nil :actions nil)
#+END_SRC

*** Babel

#+BEGIN_SRC emacs-lisp
(use-package ob-restclient
  :defer t)
(use-package ob-rust
  :defer t)
(use-package ob-sql-mode
  :defer t)
(use-package ob-translate
  :defer t)

(defun +org-babel|init ()
  (setq org-src-fontify-natively t      ; make code pretty
        org-src-preserve-indentation t  ; use native major-mode indentation
        org-src-tab-acts-natively t
        org-src-window-setup 'current-window)

  (org-babel-do-load-languages
   'org-babel-load-languages
   (mapcar (lambda (sym) (cons sym t))
           '(emacs-lisp
             restclient ; ob-restclient
             rust       ; ob-rust
             shell
             sql-mode   ; ob-sql-mode
             )))

  ;; I prefer C-c C-c for confirming over the default C-c '
  (map! :map org-src-mode-map "C-c C-c" #'org-edit-src-exit))

(+borg/org-load-hook #'+org-babel|init t)
#+END_SRC

*** Capture

#+BEGIN_SRC emacs-lisp
(+borg/org-load-hook #'+org-capture|init t)

(defun +org-capture|init ()
  "Set up a sane `org-capture' workflow."
  (setq org-capture-templates
        '(
          ("t" "Task" entry
           (file+headline +borg-organizer "Inbox")
           "* TODO %?\nCAPTURED: %t\n\n%i\n")

          ("T" "Quick Task" entry
           (file+headline +borg-organizer "Inbox")
           "* TODO %?\nSCHEDULED: %t\n\n%i\n")

          ("n" "Notes" entry
           (file+headline (concat +borg-dir "notes.org") "Inbox")
           "* %u %?\n%i" :prepend t)
          ))

  (add-hook 'org-capture-mode-hook #'evil-insert-state)

  ;; Allows the Emacs mini-frame (opened from an external shell script to run
  ;; and clean up properly) if the frame is named "org-capture".
  (require 'org-capture)
  (require 'org-protocol)
  (defun +org-capture*init (&rest _)
    "Makes sure the org-capture window is the only window in the frame."
    (when (equal "org-capture" (frame-parameter nil 'name))
      (setq mode-line-format nil)
      (delete-other-windows)))
  (advice-add #'org-capture :after #'+org-capture*init)

  (defun +org-capture|finalize ()
    "Closes the frame once org-capture is done."
    (when (equal "org-capture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'+org-capture|finalize))

#+END_SRC

*** Present

#+BEGIN_SRC emacs-lisp
(defun +doom-present*org-tree-slide-narrow-exclude-header (orig-fn &rest args)
  "TODO"
  (cl-letf (((symbol-function 'org-narrow-to-subtree)
             (lambda () (save-excursion
                     (save-match-data
                       (org-with-limited-levels
                        (narrow-to-region
                         (progn (org-back-to-heading t)
                                (forward-line 1)
                                (point))
                         (progn (org-end-of-subtree t t)
                                (when (and (org-at-heading-p) (not (eobp))) (backward-char 1))
                                (point)))))))))
    (apply orig-fn args)))

;;;###autoload
(defun +org-present|org-tree-prepare-window ()
  "TODO"
  (doom/window-zoom)
  (let ((arg (if org-tree-slide-mode +1 -1)))
    (when (fboundp 'centered-window-mode)
      (centered-window-mode arg))
    (window-divider-mode (* arg -1))
    (doom-hide-modeline-mode arg)
    (cond (org-tree-slide-mode
           (org-indent-mode -1)
           (text-scale-set +org-present-text-scale)
           (ignore-errors (org-toggle-latex-fragment '(4)))
           (set-face-attribute 'org-level-2 nil :height 1.4))
          (t
           (org-indent-mode +1)
           (text-scale-set 0)
           (org-remove-latex-fragment-image-overlays)
           (set-face-attribute 'org-level-2 nil :height 1.0)
           (+org-present|remove-overlays)
           (org-remove-inline-images)))))

(defvar +org-present--overlays nil)
;;;###autoload
(defun +org-present/org-tree-slides ()
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (error "Not in an org buffer"))
  (call-interactively 'org-tree-slide-mode)
  (add-hook 'kill-buffer-hook '+org-present--cleanup-org-tree-slides-mode))

;;;###autoload
(defun +org-present|add-overlays ()
  (add-to-invisibility-spec '(+org-present))
  (save-excursion
    ;; hide org-mode options starting with #+
    (goto-char (point-min))
    (while (re-search-forward "^[[:space:]]*\\(#\\+\\)\\(\\(?:BEGIN\\|END\\|ATTR\\)[^[:space:]]+\\).*" nil t)
      (+org-present--make-invisible
       (match-beginning 1)
       (match-end 0)))
    ;; hide stars in headings
    (goto-char (point-min))
    (while (re-search-forward "^\\(\\*+\\s-\\)" nil t)
      (+org-present--make-invisible (match-beginning 1) (match-end 1)))))

;;;###autoload
(defun +org-present|remove-overlays ()
  (mapc #'delete-overlay +org-present--overlays)
  (remove-from-invisibility-spec '(+org-present)))

;;;###autoload
(defun +org-present|detect-slide ()
  (outline-show-all)
  (if (member "title" (org-get-tags-at))
      (text-scale-set 10)
    (text-scale-set +org-present-text-scale)))

(defun +org-present--cleanup-org-tree-slides-mode ()
  (unless (cl-loop for buf in (doom-buffers-in-mode 'org-mode)
                   if (buffer-local-value 'org-tree-slide-mode buf)
                   return t)
    (org-tree-slide-mode -1)
    (remove-hook 'kill-buffer-hook #'+org-present--cleanup-org-tree-slides-mode)))

(defun +org-present--make-invisible (beg end)
  (let ((overlay (make-overlay beg end)))
    (push overlay +org-present--overlays)
    (overlay-put overlay 'invisible '+org-present)))

(defvar +org-present-text-scale 7
  "The `text-scale-amount' for `org-tree-slide-mode'.")

(+borg/org-load-hook #'+org-present|init t)

;;
;; Plugins
;;

(use-package ox-reveal
  :commands org-reveal
  :config
  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/"
        org-reveal-mathjax t))


(use-package org-tree-slide
  :commands org-tree-slide-mode
  :config
  (org-tree-slide-simple-profile)
  (setq org-tree-slide-skip-outline-level 2
        org-tree-slide-activate-message " "
        org-tree-slide-slide-in-effect t
        org-tree-slide-deactivate-message " "
        org-tree-slide-modeline-display nil)

  (map! :map org-tree-slide-mode-map
        :n [right] #'org-tree-slide-move-next-tree
        :n [left]  #'org-tree-slide-move-previous-tree
        :n "C-n"   #'org-tree-slide-move-next-tree
        :n "C-p"   #'org-tree-slide-move-previous-tree)

  (add-hook! 'org-tree-slide-mode-after-narrow-hook
    #'(+org-present|detect-slide +org-present|add-overlays org-display-inline-images))

  (add-hook 'org-tree-slide-mode-hook #'+org-present|org-tree-prepare-window)
  (advice-add #'org-tree-slide--display-tree-with-narrow
              :around #'+doom-present*org-tree-slide-narrow-exclude-header))


(use-package centered-window
  :commands centered-window-mode
  :config
  (setq cwm-use-vertical-padding t
        cwm-frame-internal-border 110
        cwm-left-fringe-ratio -10
        cwm-centered-window-width 240))


;;
;; Bootstrap
;;

(defun +org-present|init ()
  (map! :map org-mode-map
        "<f8>" #'+org-present/org-tree-slides
        "<f7>" #'+org-present/next))
#+END_SRC

** Email (Needs Cleaning)

Configuration

#+BEGIN_SRC emacs-lisp
(defvar +email-mu4e-mail-path "~/.mail"
  "The directory path of mu's maildir.")

(use-package mu4e
  :ensure nil
  :commands (mu4e mu4e-compose-new)
  :config
  (setq mu4e-maildir +email-mu4e-mail-path
        mu4e-attachment-dir "~/Downloads"
        mu4e-user-mail-address-list nil
        mu4e-update-interval nil
        mu4e-compose-format-flowed nil ; visual-line-mode + auto-fill upon sending
        mu4e-view-show-addresses t
        mu4e-html2text-command 'mu4e-shr2text
        shr-width 100
        ;; try to show images
        mu4e-view-show-images t
        mu4e-view-image-max-width 800
        ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
        mu4e-sent-messages-behavior 'sent
        ;; for mbsync
        mu4e-change-filenames-when-moving t
        ;; allow for updating mail using 'U' in the main view:
        mu4e-get-mail-command "mbsync-update-fast"
        ;; configuration for sending mail
        message-send-mail-function #'smtpmail-send-it
        smtpmail-stream-type 'ssl
        ;; start with the first (default) context;
        mu4e-context-policy 'pick-first
        ;; compose with the current context, or ask
        mu4e-compose-context-policy 'ask-if-none
        ;; use helm/ivy
        mu4e-completing-read-function #'ivy-completing-read
        ;; close message after sending it
        message-kill-buffer-on-exit t
        ;; no need to ask
        mu4e-confirm-quit nil
        ;; remove 'lists' column
        mu4e-headers-fields
        '((:account . 12)
          (:human-date . 12)
          (:flags . 4)
          (:from . 25)
          (:subject))
        mu4e-bookmarks `(("maildir:/fastmail/INBOX OR maildir:/gmail/INBOX OR maildir:/stream/INBOX" "Inbox" ?i)
                         ("maildir:/fastmail/Drafts OR maildir:/gmail/[Gmail]/.Drafts OR maildir:/stream/[Gmail]/.Drafts" "Drafts" ?d)
                         ("flag:unread AND maildir:/fastmail/INBOX OR maildir:/gmail/INBOX OR maildir:/stream/INBOX" "Unread messages" ?u)
                         ("flag:flagged" "Starred messages" ?s)
                         ("date:today..now" "Today's messages" ?t)
                         ("date:7d..now" "Last 7 days" ?w)
                         ("mime:image/*" "Messages with images" ?p)))

  (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)

  ;; Add a column to display what email account the email belongs to.
  (add-to-list 'mu4e-header-info-custom
               '(:account
                 :name "Account"
                 :shortname "Account"
                 :help "Which account this email belongs to"
                 :function
                 (lambda (msg)
                   (let ((maildir (mu4e-message-field msg :maildir)))
                     (format "%s" (substring maildir 1 (string-match-p "/" maildir 1)))))))



  ;; Change refile to an 'A'
  (setq mu4e-marks (assq-delete-all 'refile mu4e-marks))
  (push '(refile
          :char ("A" . "▶")
          :prompt "archive"
          :dyn-target (lambda (target msg) (mu4e-get-refile-folder msg))
          :action (lambda (docid msg target) (mu4e~proc-move docid
                                                        (mu4e~mark-check-target target) "-N")))
        mu4e-marks)

  ;; Special handling for fastmail, don't add +T and move to trash
  ;; Gmail is configured to automatically add deleted emails to the trash
  (setq mu4e-marks (assq-delete-all 'delete mu4e-marks))
  (push '(delete
          :char ("D" . "❌")
          :prompt "Delete"
          :show-target (lambda (target) "delete")
          :action (lambda (docid msg target)
                    (let ((maildir (mu4e-message-field msg :maildir)))
                      (cond ((string-prefix-p "/fastmail" maildir)
                             (mu4e~proc-move docid (mu4e-get-trash-folder msg) "-N"))
                            ((or (string-prefix-p "/gmail" maildir) (string-prefix-p "/stream" maildir))
                             (shell-command (format "expunge-email-id %s" (mu4e-message-field msg :message-id))))
                            (true (mu4e~proc-remove docid))))))
        mu4e-marks)

  ;; Refresh the current view after marks are executed
  (defun +email*refresh (&rest _) (mu4e-headers-rerun-search))
  (advice-add #'mu4e-mark-execute-all :after #'+email*refresh)

  (add-hook 'mu4e-compose-mode-hook (lambda ()
                                      (setq-local fill-column 120)
                                      (auto-fill-mode -1)
                                      (visual-line-mode)
                                      (visual-fill-column-mode)))

  (add-hook 'mu4e-view-mode-hook (lambda ()
                                   (setq-local fill-column 120)
                                   (visual-line-mode)
                                   (visual-fill-column-mode)))

                                        ; (when (featurep! :feature spellcheck) TODO
                                        ;   (add-hook 'mu4e-compose-mode-hook #'flyspell-mode))

  ;; Wrap text in messages
  (add-hook! 'mu4e-view-mode-hook
    (setq-local truncate-lines nil))

  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))

  (cl-loop for str in '((mu4e-main-mode . normal)
                        (mu4e-view-mode . normal)
                        (mu4e-headers-mode . normal)
                        (mu4e-compose-mode . normal)
                        (mu4e~update-mail-mode . normal))
           do (evil-set-initial-state (car str) (cdr str)))

  (setq mu4e-view-mode-map (make-sparse-keymap)
        mu4e-headers-mode-map (make-sparse-keymap)
        mu4e-main-mode-map (make-sparse-keymap))


  (use-package mu4e-maildirs-extension
               :demand t
               :after mu4e
               :config (mu4e-maildirs-extension))


  (defun bmail-refile-folder-function (msg)
    "Set the refile folder for MSG."
    (let ((maildir (mu4e-message-field msg :maildir)))
      (cond
       ((string-prefix-p "/fastmail" maildir)
        "/fastmail/Archive")
       ((string-prefix-p "/gmail" maildir)
        "/gmail/[Gmail]/All Mail")
       ((string-prefix-p "/stream" maildir)
        "/stream/[Gmail]/All Mail")
       (t nil))))

  (defun bmail-trash-folder-function (msg)
    "Set the trash folder for MSG."
    (let ((maildir (mu4e-message-field msg :maildir)))
      (cond
       ((string-prefix-p "/fastmail" maildir)
        "/fastmail/Trash")
       ((string-prefix-p "/gmail" maildir)
        "/gmail/[Gmail]/.Trash")
       ((string-prefix-p "/stream" maildir)
        "/stream/[Gmail]/.Trash")
       (t nil))))

  (defun email-signature (address)
    (bmacs/file-as-string
     (expand-file-name (concat "~/.signatures/" address))))

  (setq mu4e-refile-folder #'bmail-refile-folder-function
        mu4e-trash-folder #'bmail-trash-folder-function
        smtpmail-debug-info t
        smtpmail-stream-type 'ssl
        smtpmail-default-smtp-server "smtp.fastmail.com"
        smtpmail-smtp-server "smtp.fastmail.com"
        smtpmail-smtp-user "gilbertw1@fastmail.com"
        smtpmail-smtp-service 465)

  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "fastmail"
            :match-func (lambda (msg) (when msg
                                   (string-prefix-p "/fastmail" (mu4e-message-field msg :maildir))))
            :vars '((mu4e-sent-folder          . "/fastmail/Sent")
                    (mu4e-drafts-folder        . "/fastmail/Drafts")
                    (smtpmail-smtp-user        . "gilbertw1@fastmail.com")
                    (smtpmail-smtp-server      . "smtp.fastmail.com")
                    (smtpmail-stream-type      . ssl)
                    (smtpmail-smtp-service     . 465)
                    (user-mail-address         . "bryan@bryan.sh")
                    (user-full-name            . "Bryan Gilbert")
                    (mu4e-compose-signature    . (email-signature "bryan@bryan.sh"))))
          ,(make-mu4e-context
            :name "gmail"
            :match-func (lambda (msg) (when msg
                                   (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
            :vars '((mu4e-sent-folder          . "/gmail/[Gmail]/.Sent Mail")
                    (mu4e-drafts-folder        . "/gmail/[Gmail]/.Drafts")
                    (smtpmail-smtp-user        . "gilbertw1@gmail.com")
                    (smtpmail-smtp-server      . "smtp.gmail.com")
                    (smtpmail-stream-type      . starttls)
                    (smtpmail-smtp-service     . 587)
                    (user-mail-address         . "gilbertw1@gmail.com")
                    (user-full-name            . "Bryan Gilbert")
                    (mu4e-compose-signature    . (email-signature "gilbertw1@gmail.com"))))
          ,(make-mu4e-context
            :name "stream"
            :match-func (lambda (msg) (when msg
                                   (string-prefix-p "/stream" (mu4e-message-field msg :maildir))))
            :vars '((mu4e-sent-folder          . "/stream/[Gmail]/.Sent Mail")
                    (mu4e-drafts-folder        . "/stream/[Gmail]/.Drafts")
                    (smtpmail-smtp-user        . "bryan@stre.am")
                    (smtpmail-smtp-server      . "smtp.gmail.com")
                    (smtpmail-stream-type      . starttls)
                    (smtpmail-smtp-service     . 587)
                    (user-mail-address         . "bryan@stream.live")
                    (user-full-name            . "Bryan Gilbert")
                    (mu4e-compose-signature    . (email-signature "bryan@stream.live")))))))
#+END_SRC

*** Fix Mark Emails in Region

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (defun mu4e-mark-set (mark &optional target)
    "Mark the header at point, or, if region is active, mark all
  headers in the region. Optionally, provide TARGET (for moves)."
    (unless target
      (setq target (mu4e~mark-ask-target mark)))
    (if (not (use-region-p))
        ;; single message
        (mu4e-mark-at-point mark target)
      ;; mark all messages in the region.
      (save-excursion
        (let ((cant-go-further) (eor (region-end)))
	        (goto-char (region-beginning))
	        (while (and (< (point) eor) (not cant-go-further))
	          (mu4e-mark-at-point mark target)
	          (setq cant-go-further (not (mu4e-headers-next)))))))))
#+END_SRC

** Tools

*** Restclient

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :commands restclient-mode
  :mode ("\\.\\(http\\|rest\\)$" . restclient-mode)
  :config
  (map! :mode restclient-mode
        :n [M-return] 'restclient-http-send-current
        :localleader
        :desc "Execute HTTP request"     :n "e" 'restclient-http-send-current
        :desc "Execute raw HTTP request" :n "E" 'restclient-http-send-current-raw
        :desc "Copy curl command"        :n "c" 'restclient-copy-curl-command))


(use-package company-restclient
  :demand t
  :after restclient
  :config
  (add-hook! restclient-mode (setq-local company-backends (cons 'company-restclient company-backends))))
#+END_SRC

*** Dash Docs
Quick and awesome documentation lookup

#+BEGIN_SRC emacs-lisp
(require 'counsel-dash)

  (add-hook 'emacs-lisp-mode-hook (lambda () (setq-local dash-docs-docsets '("Emacs Lisp"))))
  (add-hook 'scala-mode-hook (lambda () (setq-local dash-docs-docsets '("Scala" "Akka" "Play_Scala" "Java"))))
  (add-hook 'java-mode-hook (lambda () (setq-local dash-docs-docsets '("Java" "Play_Java"))))
  (add-hook 'rust-mode-hook (lambda () (setq-local dash-docs-docsets '("Rust"))))
  (add-hook 'clojure-mode-hook (lambda () (setq-local dash-docs-docsets '("Clojure"))))
  (add-hook 'haskell-mode-hook (lambda () (setq-local dash-docs-docsets '("Haskell"))))
  (add-hook 'sh-mode-hook (lambda () (setq-local dash-docs-docsets '("Bash"))))
  (add-hook 'c-mode-hook (lambda () (setq-local dash-docs-docsets '("C"))))
  (add-hook 'c++-mode-hook (lambda () (setq-local dash-docs-docsets '("C++"))))
  (add-hook 'js2-mode-hook (lambda () (setq-local dash-docs-docsets '("JavaScript"))))
  (add-hook 'js-mode-hook (lambda () (setq-local dash-docs-docsets '("JavaScript"))))
  (add-hook 'html-mode-hook (lambda () (setq-local dash-docs-docsets '("HTML" "Javascript"))))
  (add-hook 'python-mode-hook (lambda () (setq-local dash-docs-docsets '("Python 3"))))

  (setq dash-docs-docsets-path (concat bmacs-etc-dir "docsets"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-dash
  :commands (counsel-dash counsel-dash-install-docset)
  :init
  ;; Language Hooks
  (add-hook 'emacs-lisp-mode-hook (lambda () (setq-local counsel-dash-docsets '("Emacs Lisp"))))
  (add-hook 'scala-mode-hook (lambda () (setq-local counsel-dash-docsets '("Scala" "Akka" "Play_Scala" "Java"))))
  (add-hook 'java-mode-hook (lambda () (setq-local counsel-dash-docsets '("Java" "Play_Java"))))
  (add-hook 'rust-mode-hook (lambda () (setq-local counsel-dash-docsets '("Rust"))))
  (add-hook 'clojure-mode-hook (lambda () (setq-local counsel-dash-docsets '("Clojure"))))
  (add-hook 'haskell-mode-hook (lambda () (setq-local counsel-dash-docsets '("Haskell"))))
  (add-hook 'sh-mode-hook (lambda () (setq-local counsel-dash-docsets '("Bash"))))
  (add-hook 'c-mode-hook (lambda () (setq-local counsel-dash-docsets '("C"))))
  (add-hook 'c++-mode-hook (lambda () (setq-local counsel-dash-docsets '("C++"))))
  (add-hook 'js2-mode-hook (lambda () (setq-local counsel-dash-docsets '("JavaScript"))))
  (add-hook 'js-mode-hook (lambda () (setq-local counsel-dash-docsets '("JavaScript"))))
  (add-hook 'html-mode-hook (lambda () (setq-local counsel-dash-docsets '("HTML" "Javascript"))))
  (add-hook 'python-mode-hook (lambda () (setq-local counsel-dash-docsets '("Python 3"))))

  :config
  (setq counsel-dash-docsets-path (concat bmacs-etc-dir "docsets")))
#+END_SRC

*** Dired
Directories in Emacs

#+BEGIN_SRC emacs-lisp
(setq ;; Always copy/delete recursively
      dired-recursive-copies  'always
      dired-recursive-deletes 'top
      ;; Auto refresh dired, but be quiet about it
      global-auto-revert-non-file-buffers nil
      auto-revert-verbose nil
      ;; files
      image-dired-dir (concat bmacs-cache-dir "image-dired/")
      image-dired-db-file (concat image-dired-dir "image-dired/db.el")
      image-dired-gallery-dir (concat image-dired-dir "gallery/")
      image-dired-temp-image-file (concat image-dired-dir "temp-image")
      image-dired-temp-rotate-image-file (concat image-dired-dir "temp-rotate-image"))

(after! dired
  (map! :map dired-mode-map
        :n "c" #'find-file
        :n "d" #'dired-do-delete
        :n "r" #'dired-do-rename))

(use-package dired-k
  :demand t
  :after dired
  :config
  (setq dired-k-style 'git)

  (defun +dired*dired-k-highlight (orig-fn &rest args)
    "Butt out if the requested directory is remote (i.e. through tramp)."
    (unless (file-remote-p default-directory)
      (apply orig-fn args)))
  (advice-add #'dired-k--highlight :around #'+dired*dired-k-highlight)

  (add-hook 'dired-initial-position-hook #'dired-k)
  (add-hook 'dired-after-readin-hook #'dired-k-no-revert))


(use-package stripe-buffer
  :commands stripe-buffer-mode
  :init (add-hook 'dired-mode-hook #'stripe-buffer-mode))

#+END_SRC

*** EShell
A terminal by Emacs for Emacs!

**** Functions

#+BEGIN_SRC emacs-lisp
(defface +eshell-prompt-pwd '((t :inherit eshell-prompt))
  "TODO")

(defface +eshell-prompt-git-branch '((t :inherit font-lock-function-name-face))
  "TODO")

(defface +eshell-prompt-char '((t :inherit font-lock-constant-face))
  "TODO")


(defvar +eshell-buffers (make-ring 25)
  "List of open eshell buffers.")

(defvar +eshell-buffer-name "*bmacs eshell*"
  "The name to use for custom eshell buffers. This only affects `+eshell/open',
`+eshell/open-popup'")

(defvar +eshell-last-buffer nil
  "TODO")


;;
;; Library
;;

(defun +eshell--outside-prompt-p ()
  (< (point) eshell-last-output-end))

(defun +eshell/popup ()
  (interactive)
  (let ((eshell-window (get-buffer-window "*eshell*")))
    (if eshell-window
      (delete-window eshell-window)
      (eshell))))

(defun +eshell/project-popup ()
  (interactive)
  (let ((eshell-window (get-buffer-window "*eshell-project*")))
    (if eshell-window
      (delete-window eshell-window)
      (let ((eshell-buffer-name "*eshell-project*")
            (eshell-directory-name (bmacs-project-root)))
        (eshell)))))

(defun +eshell--current-git-branch ()
  (let ((branch (car (cl-loop for match in (split-string (shell-command-to-string "git branch") "\n")
                              if (string-match-p "^\*" match)
                              collect match))))
    (if (not (eq branch nil))
        (format " [%s]" (substring branch 2))
      "")))

(defun +eshell-prompt ()
  "Generate the prompt string for eshell. Use for `eshell-prompt-function'."
  (concat (propertize (abbreviate-file-name (eshell/pwd)) 'face '+eshell-prompt-pwd)
          (propertize (+eshell--current-git-branch) 'face '+eshell-prompt-git-branch)
          (propertize " λ " 'face '+eshell-prompt-char)))

;;
;; Keybinds
;;

(defun +eshell/evil-append ()
  (interactive)
  (goto-char eshell-last-output-end)
  (call-interactively #'evil-append-line))

(defun +eshell/evil-append-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (+eshell/evil-append)
    (call-interactively #'evil-append)))

(defun +eshell/evil-prepend ()
  (interactive)
  (goto-char eshell-last-output-end)
  (call-interactively #'evil-insert))

(defun +eshell/evil-prepend-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (+eshell/evil-prepend)
    (call-interactively #'evil-insert)))

(defun +eshell/evil-replace-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (user-error "Cannot edit read-only region")
    (call-interactively #'evil-replace)))

(defun +eshell/evil-replace-state-maybe ()
  (interactive)
  (if (+eshell--outside-prompt-p)
      (user-error "Cannot edit read-only region")
    (call-interactively #'evil-replace-state)))

(defun +eshell/evil-change ()
  (interactive)
  (when (+eshell--outside-prompt-p)
    (goto-char eshell-last-output-end))
  (call-interactively #'evil-change))

(defun +eshell/evil-change-line ()
  (interactive)
  (when (+eshell--outside-prompt-p)
    (goto-char eshell-last-output-end))
  (call-interactively #'evil-change-line))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package eshell ; built-in
  :commands eshell-mode
  :init
  (setq eshell-directory-name (concat bmacs-etc-dir "/eshell")
        eshell-rc-script "~/.eshellrc"
        eshell-aliases-file "~/.eshell_aliases"
        ;;
        eshell-scroll-to-bottom-on-input 'all
        eshell-scroll-to-bottom-on-output 'all
        eshell-buffer-shorthand t
        eshell-kill-processes-on-exit t
        eshell-error-if-no-glob t
        eshell-hist-ignoredups t
        ;; em-prompt
        eshell-prompt-regexp "^.* λ "
        eshell-prompt-function #'+eshell-prompt
        ;; em-glob
        eshell-glob-case-insensitive t
        eshell-error-if-no-glob t)
  :config

  (after! em-term
    ;; Visual commands require a proper terminal. Eshell can't handle that, so it
    ;; delegates these commands to a term buffer.
    (setq eshell-visual-commands
          (append eshell-visual-commands '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim"))
          eshell-visual-subcommands '(("git" "log" "l" "diff" "show"))))

  (defun +eshell|init-keymap ()
    "Setup eshell keybindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
    (map! :map eshell-mode-map
          :n "i"        #'+eshell/evil-prepend-maybe
          :n "I"        #'+eshell/evil-prepend
          :n "a"        #'+eshell/evil-append-maybe
          :n "A"        #'+eshell/evil-append
          :n "r"        #'+eshell/evil-replace-maybe
          :n "R"        #'+eshell/evil-replace-state-maybe
          :n "c"        #'+eshell/evil-change
          :n "C"        #'+eshell/evil-change-line
          :i [tab]      #'eshell-pcomplete
          :i "SPC"      #'self-insert-command
          :i "C-u"      #'eshell-kill-input
          :i "C-a"      #'eshell-bol
          :i "C-d"      #'+eshell/quit-or-delete-char
          :i "C-k"      #'kill-line
          :i "C-p"      #'eshell-previous-input
          :i "<up>"     #'eshell-previous-input
          :i "C-n"      #'eshell-next-input
          :i "<down>"   #'eshell-next-input
          :m "<return>" #'+eshell/evil-append
          :i "<return>" #'eshell-send-input
          [remap bmacs/backward-to-bol-or-indent] #'eshell-bol
          [remap bmacs/backward-kill-to-bol-and-indent] #'eshell-kill-input))
  (add-hook 'eshell-first-time-mode-hook #'+eshell|init-keymap))
#+END_SRC

*** Imenu
TODO - I really have no idea

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
  :commands (ido-imenu-anywhere ivy-imenu-anywhere helm-imenu-anywhere)
  :config (setq imenu-anywhere-delimiter ": "))


(use-package imenu-list
  :commands imenu-list-minor-mode
  :config
  (setq imenu-list-focus-after-activation t))
#+END_SRC

*** NeoTree

**** Functions

#+BEGIN_SRC emacs-lisp
(defun +neotree/toggle ()
  "Toggle the neotree window."
  (interactive)
  (let ((path buffer-file-name)
        (project-root (bmacs-project-root)))
    (require 'neotree)
    (cond ((and (neo-global--window-exists-p)
                (get-buffer-window neo-buffer-name t))
           (neotree-find path project-root))
          ((not (and (neo-global--window-exists-p)
                     (equal (file-truename (neo-global--with-buffer neo-buffer--start-node))
                            (file-truename project-root))))
           (neotree-dir project-root)
           (neotree-find path project-root))
          (t (neotree-find path project-root)))))

(defun +neotree/collapse-or-up ()
  "Collapse an expanded directory node or go to the parent node."
  (interactive)
  (when-let* ((node (neo-buffer--get-filename-current-line)))
    (if (file-directory-p node)
        (if (neo-buffer--expanded-node-p node)
            (+neotree/collapse)
          (neotree-select-up-node))
      (neotree-select-up-node))))

(defun +neotree/collapse ()
  "Collapse a neotree node."
  (interactive)
  (when-let* ((node (neo-buffer--get-filename-current-line)))
    (when (file-directory-p node)
      (neo-buffer--set-expand node nil)
      (neo-buffer--refresh t))
    (when neo-auto-indent-point
      (neo-point-auto-indent))))

(defun +neotree/neo-hide-on-enter (type path arg)
  (if (or (and (eq +neotree/neotree-opening-file t)
               (equal type 'file))
          (and (eq +neotree/neotree-entering-dired t)
               (equal type 'directory)))
      (neotree-hide))
  (setq +neotree/neotree-opening-file nil
        +neotree/neotree-entering-dired nil))

(defun +neotree/before-neobuffer-execute (arg0 &optional file-fn dir-fn &rest args)
  (when (eq dir-fn 'neo-open-dired)
    (setq +neotree/neotree-entering-dired t))
  (when (or (eq file-fn 'neo-open-file)
            (eq file-fn 'neo-open-file-vertical-split)
            (eq file-fn 'neo-open-file-horizontal-split))
    (setq +neotree/neotree-opening-file t)))

(defun +neotree/expand-or-open ()
  "Expand or open a neotree node."
  (interactive)
  (when-let* ((node (neo-buffer--get-filename-current-line)))
    (cond ((file-directory-p node)
           (neo-buffer--set-expand node t)
           (neo-buffer--refresh t)
           (when neo-auto-indent-point
             (forward-line)
             (neo-point-auto-indent)))
          (t
           (call-interactively #'neotree-enter)))))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :commands (neotree-show
             neotree-hide
             neotree-toggle
             neotree-dir
             neotree-find
             neo-global--with-buffer
             neo-global--window-exists-p)
  :config
  (setq neo-create-file-auto-open nil
        neo-auto-indent-point nil
        neo-autorefresh nil
        neo-mode-line-type 'none
        neo-window-width 32
        neo-show-updir-line nil
        neo-theme 'nerd ; fallback
        neo-banner-message nil
        neo-confirm-create-file #'off-p
        neo-confirm-create-directory #'off-p
        neo-show-hidden-files nil
        neo-keymap-style 'concise
        neo-hidden-regexp-list
        '(;; vcs folders
          "^\\.\\(git\\|hg\\|svn\\)$"
          ;; compiled files
          "\\.\\(pyc\\|o\\|elc\\|lock\\|css.map\\)$"
          ;; generated files, caches or local pkgs
          "^\\(node_modules\\|vendor\\|.\\(project\\|cask\\|yardoc\\|sass-cache\\)\\)$"
          ;; org-mode folders
          "^\\.\\(sync\\|export\\|attach\\)$"
          "~$"
          "^#.*#$"))

  (when (bound-and-true-p winner-mode)
    (push neo-buffer-name winner-boring-buffers))

  (add-hook 'bmacs-escape-hook #'neotree-hide)

  (defvar +neotree/neotree-opening-file nil)
  (defvar +neotree/neotree-entering-dired nil)
  (add-hook 'neo-enter-hook #'+neotree/neo-hide-on-enter)
  (advice-add 'neo-buffer--execute :before #'+neotree/before-neobuffer-execute))

(setq doom-neotree-file-icons t)
#+END_SRC


** Programming Languages

*** Assembly
The language of the machine!

#+BEGIN_SRC emacs-lisp
(use-package mips-mode :mode "\\.mips$")

(use-package haxor-mode :mode "\\.hax$")

(use-package nasm-mode :commands nasm-mode)
#+END_SRC

*** CC
Can you hear the C? -- TODO: Pair this down to just basic C/C++ support ... too complex

#+BEGIN_SRC emacs-lisp
  ;;
  ;; Hooks
  ;;

  (defun +cc|fontify-constants ()
    "Better fontification for preprocessor constants"
    (font-lock-add-keywords
     nil '(("\\<[A-Z]*_[A-Z_]+\\>" . font-lock-constant-face)
           ("\\<[A-Z]\\{3,\\}\\>"  . font-lock-constant-face))
     t))

  (use-package cc-mode
    :commands (c-mode c++-mode objc-mode java-mode)
    :mode ("\\.mm" . objc-mode)
    :init
    (setq-default c-basic-offset tab-width
                  c-default-style "linux")

    :config
    ;;; Better fontification (also see `modern-cpp-font-lock')
    (add-hook 'c-mode-common-hook #'rainbow-delimiters-mode)
    (add-hook! (c-mode c++-mode) #'highlight-numbers-mode)
    (add-hook! (c-mode c++-mode) #'+cc|fontify-constants)

    ;; ...and leave it to smartparens
    (sp-with-modes '(c-mode c++-mode objc-mode java-mode)
      (sp-local-pair "/*" "*/" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
      ;; Doxygen blocks
      (sp-local-pair "/**" "*/" :post-handlers '(("||\n[i]" "RET") ("||\n[i]" "SPC")))
      (sp-local-pair "/*!" "*/" :post-handlers '(("||\n[i]" "RET") ("[d-1]< | " "SPC")))))


  (use-package modern-cpp-font-lock
    :commands modern-c++-font-lock-mode
    :init (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))

  ;;
  ;; Major modes
  ;;

  (use-package cmake-mode
    :mode "CMakeLists\\.txt$")
    ; :config
    ;(set! :company-backend 'cmake-mode '(company-cmake company-yasnippet)))

  (use-package cuda-mode :mode "\\.cuh?$")

  (use-package opencl-mode :mode "\\.cl$")

  (use-package demangle-mode
    :commands demangle-mode
    :init (add-hook 'llvm-mode-hook #'demangle-mode))

  (use-package glsl-mode
    :mode "\\.glsl$"
    :mode "\\.vert$"
    :mode "\\.frag$"
    :mode "\\.geom$")
#+END_SRC

*** Clojure
Lisp, but java.

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode "\\.clj$")

(use-package cider
  :commands (cider-jack-in cider-mode)
  :config
  (setq nrepl-hide-special-buffers t))
#+END_SRC

*** CSharp
Java, but Microsoft

#+BEGIN_SRC emacs-lisp
(use-package csharp-mode :mode "\\.cs$")

(use-package omnisharp
  :demand t
  :after csharp-mode
  :preface
  (setq omnisharp-auto-complete-want-documentation nil
        omnisharp-server-executable-path (concat bmacs-local-dir "OmniSharp.exe"))
  :config
  (if (file-exists-p omnisharp-server-executable-path)
      (add-hook! csharp-mode #'(eldoc-mode flycheck-mode omnisharp-mode))
    (warn "csharp-mode: omnisharp server isn't installed, completion won't work"))

  ;(set! :company-backend 'csharp-mode '(company-omnisharp))

  (map! :map omnisharp-mode-map
        :m "gd" #'omnisharp-go-to-definition

        (:localleader
         :n "b" #'omnisharp-recompile

         ; (:prefix "r"
         ;   :n "i"  #'omnisharp-fix-code-issue-at-point
         ;   :n "u"  #'omnisharp-fix-usings
         ;   :n "r"  #'omnisharp-rename
         ;   :n "a"  #'omnisharp-show-last-auto-complete-result
         ;   :n "o"  #'omnisharp-show-overloads-at-point)

         (:prefix "f"
           :n "u"  #'omnisharp-find-usages
           :n "i"  #'omnisharp-find-implementations
           :n "f"  #'omnisharp-navigate-to-current-file-member
           :n "m"  #'omnisharp-navigate-to-solution-member
           :n "M"  #'omnisharp-navigate-to-solution-file-then-file-member
           :n "F"  #'omnisharp-navigate-to-solution-file
           :n "r"  #'omnisharp-navigate-to-region
           :n "ti" #'omnisharp-current-type-information
           :n "td" #'omnisharp-current-type-documentation)

         (:prefix "t"
           :n "r" (lambda () (omnisharp-unit-test "fixture"))
           :n "s" (lambda () (omnisharp-unit-test "single"))
           :n "a" (lambda () (omnisharp-unit-test "all"))))))


(use-package shader-mode :mode "\\.shader$") ; unity shaders
#+END_SRC

*** Data + Config Formats
Various data and configuration formats

#+BEGIN_SRC emacs-lisp
  (push '("/sxhkdrc" . conf-mode) auto-mode-alist)

  (use-package nxml-mode
    :ensure nil
    :mode "\\.plist$")
    ;; :config
    ;; (set! :company-backend 'nxml-mode '(company-nxml company-yasnippet)))


  (use-package toml-mode :mode "\\.toml$")


  (use-package yaml-mode :mode "\\.ya?ml$")


  (use-package json-mode
    :mode "\\.js\\(on\\|[hl]int\\(rc\\)?\\)$")
    ;; :config
    ;; (set! :electric 'json-mode :chars '(?\n ?: ?{ ?})))


  (use-package vimrc-mode
    :mode "/\\.?g?vimrc$"
    :mode "\\.vim$"
    :mode "\\.?vimperatorrc$"
    :mode "\\.vimp$")


  (use-package dockerfile-mode
    :mode "/Dockerfile$")


  ;; For ROM hacking or debugging
  (use-package hexl
    :mode ("\\.hex$" . hexl-mode)
    :mode ("\\.nes$" . hexl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :mode "\\.exs?$")
#+END_SRC

*** Elm
Reactive javascriptish like?

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :mode "\\.elm$"
  :config
  (add-hook 'elm-mode-hook #'(flycheck-mode rainbow-delimiters-mode))
  (setq elm-format-on-save t))


(use-package flycheck-elm
  :demand t
  :after elm-mode
  :config
  (add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
#+END_SRC

*** Emacs-lisp
The language that runs on the Emacs interpreter

#+BEGIN_SRC emacs-lisp

  (use-package elisp-mode ; built-in
    :ensure nil
    :mode ("/Cask$" . emacs-lisp-mode)
    :config
    (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
    (add-hook 'emacs-lisp-mode-hook #'(lambda ()
      (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))
    (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'emacs-lisp-mode-hook #'highlight-quoted-mode)
    (add-hook 'emacs-lisp-mode-hook #'highlight-numbers-mode)
    (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp|extra-fontification)
    (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp|init-imenu)
    (add-hook 'emacs-lisp-mode-hook #'+emacs-lisp|init-flycheck)

    ;; Disable auto pair ' in elisp mode
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)

    (defun +emacs-lisp|extra-fontification ()
      "Display lambda as a smybol and fontify doom module functions."
      (font-lock-add-keywords
       nil `(;; Display "lambda" as λ
             ("(\\(lambda\\)" (1 (ignore (compose-region (match-beginning 1) (match-end 1) ?λ #'decompose-region))))
             ;; Highlight doom/module functions
             ("\\(^\\|\\s-\\|,\\)(\\(\\(doom\\|\\+\\)[^) ]+\\)[) \n]" (2 font-lock-keyword-face)))))

    (defun +emacs-lisp|init-imenu ()
      "Improve imenu support with better expression regexps and Doom-specific forms."
      (setq imenu-generic-expression
            '(("Evil Commands" "^\\s-*(evil-define-\\(?:command\\|operator\\|motion\\) +\\(\\_<[^ ()\n]+\\_>\\)" 1)
              ("Package" "^\\s-*(\\(?:def-\\)?package! +\\(\\_<[^ ()\n]+\\_>\\)" 1)
              ("Settings" "^\\s-*(def-setting! +\\([^ ()\n]+\\)" 1)
              ("Modelines" "^\\s-*(def-modeline! +\\([^ ()\n]+\\)" 1)
              ("Modeline Segments" "^\\s-*(def-modeline-segment! +\\([^ ()\n]+\\)" 1)
              ("Advice" "^\\s-*(def\\(?:\\(?:ine-\\)?advice\\))")
              ("Modes" "^\\s-*(define-\\(?:global\\(?:ized\\)?-minor\\|generic\\|minor\\)-mode +\\([^ ()\n]+\\)" 1)
              ("Macros" "^\\s-*(\\(?:cl-\\)?def\\(?:ine-compile-macro\\|macro\\) +\\([^ )\n]+\\)" 1)
              ("Inline Functions" "\\s-*(\\(?:cl-\\)?defsubst +\\([^ )\n]+\\)" 1)
              ("Functions" "^\\s-*(\\(?:cl-\\)?def\\(?:un\\|un\\*\\|method\\|generic\\|-memoized!\\) +\\([^ ,)\n]+\\)" 1)
              ("Variables" "^\\s-*(\\(def\\(?:c\\(?:onst\\(?:ant\\)?\\|ustom\\)\\|ine-symbol-macro\\|parameter\\)\\)\\s-+\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)" 2)
              ("Variables" "^\\s-*(defvar\\(?:-local\\)?\\s-+\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)[[:space:]\n]+[^)]" 1)
              ("Types" "^\\s-*(\\(cl-def\\(?:struct\\|type\\)\\|def\\(?:class\\|face\\|group\\|ine-\\(?:condition\\|error\\|widget\\)\\|package\\|struct\\|t\\(?:\\(?:hem\\|yp\\)e\\)\\)\\)\\s-+'?\\(\\(?:\\sw\\|\\s_\\|\\\\.\\)+\\)" 2))))

    (defun +emacs-lisp|init-flycheck ()
      "Initialize flycheck-mode if not in emacs.d."
      (when (and buffer-file-name
                 (not (file-in-directory-p buffer-file-name bmacs-emacs-dir)))
        (flycheck-mode +1))))

  ;;
  ;; Plugins
  ;;

  (use-package highlight-quoted
    :commands highlight-quoted-mode)

  (use-package slime
    :config
    (setq inferior-lisp-program "clisp")
    (require 'slime-fuzzy))

  (use-package macrostep
    :commands macrostep-expand
    :config
    (map! :map macrostep-keymap
          :n "RET"    #'macrostep-expand
          :n "e"      #'macrostep-expand
          :n "u"      #'macrostep-collapse
          :n "c"      #'macrostep-collapse

          :n "TAB"    #'macrostep-next-macro
          :n "n"      #'macrostep-next-macro
          :n "J"      #'macrostep-next-macro

          :n "S-TAB"  #'macrostep-prev-macro
          :n "K"      #'macrostep-prev-macro
          :n "p"      #'macrostep-prev-macro

          :n "q"      #'macrostep-collapse-all
          :n "C"      #'macrostep-collapse-all)
    ;; `evil-normalize-keymaps' seems to be required for macrostep or it won't
    ;; apply for the very first invocation
    (add-hook 'macrostep-mode-hook #'evil-normalize-keymaps))
#+END_SRC

*** Go
Go by Google

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go$"
    :interpreter "go"
    :config
    (add-hook 'go-mode-hook #'flycheck-mode)

    (setq gofmt-command "goimports")
    (if (not (executable-find "goimports"))
        (warn "go-mode: couldn't find goimports; no code formatting/fixed imports on save")
      (add-hook go-mode #'(add-hook 'before-save-hook #'gofmt-before-save nil t))))

  (use-package go-eldoc
    :demand t
    :after go-mode
    :commands go-eldoc-setup
    :config (add-hook 'go-mode-hook #'go-eldoc-setup))

  (use-package go-guru
    :commands (go-guru-describe go-guru-freevars go-guru-implements go-guru-peers
               go-guru-referrers go-guru-definition go-guru-pointsto
               go-guru-callstack go-guru-whicherrs go-guru-callers go-guru-callees
               go-guru-expand-region)
    :config
    (unless (executable-find "guru")
      (warn "go-mode: couldn't find guru, refactoring commands won't work")))

  (use-package gorepl-mode
    :commands (gorepl-run gorepl-run-load-current-file)
    :config
    (unless (executable-find "gore")
      (warn "go-mode: couldn't find gore, REPL support disabled")))

  (use-package company-go
    :init (setq command-go-gocode-command "gocode")
    :demand t
    :after go-mode)
    ;; :config
    ;; (if (executable-find command-go-gocode-command)
    ;;     (set! :company-backend 'go-mode '(company-go))
    ;;   (warn "go-mode: couldn't find gocode, code completion won't work")))
#+END_SRC

*** Haskell
Lazy lazy functional programming

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :mode "\\.hs$"
  :mode ("\\.ghci$" . ghci-script-mode)
  :mode ("\\.cabal$" . haskell-cabal-mode)
  :interpreter (("runghc" . haskell-mode)
                ("runhaskell" . haskell-mode))
  :config
  (load "haskell-mode-autoloads" nil t)
  (add-hook 'haskell-mode-hook #'hindent-mode)
  (add-hook 'haskell-mode-hook (lambda () (ghc-init)))
  (add-hook 'haskell-mode-hook #'structured-haskell-mode)

  (push ".hi" completion-ignored-extensions)

  (custom-set-variables '(company-ghc-show-info t))

  (autoload 'switch-to-haskell "inf-haskell" nil t))

;; (use-package ghc
;;   :commands (ghc-init ghc-debug))

;; (use-package company-ghc
;;   :commands (company-ghc))

(use-package shm
  :commands (structured-haskell-mode))

;; (use-package dante
;;   :demand t
;;   :after haskell-mode
;;   :init
;;   (add-hook 'haskell-mode-hook #'(dante-mode interactive-haskell-mode))
;;   :config
;;   (unless (executable-find "cabal")
;;     (warn "haskell-mode: couldn't find cabal")
;;     (remove-hook 'haskell-mode-hook #'dante-mode))

;;   (add-hook 'dante-mode-hook #'flycheck-mode))

;; (use-package company-ghc
;;   :demand t
;;   :after haskell-mode
;;   :init
;;   (add-hook 'haskell-mode-hook #'ghc-comp-init)
;;   :config
;;   (if (executable-find "ghc-mod")
;;       (add-hook! haskell-mode (setq-local company-backends '(company-ghc)))
;;     (warn "haskell-mode: couldn't find ghc-mode")
;;     (remove-hook 'haskell-mode-hook #'ghc-comp-init))

;;   (setq company-ghc-show-info 'oneline))
#+END_SRC

*** Hy
Python? Lisp? WTF?

#+BEGIN_SRC emacs-lisp
(use-package hy-mode
  :mode "\\.hy$")
#+END_SRC

*** Java / Android / Groovy

#+BEGIN_SRC emacs-lisp
  (add-hook 'java-mode-hook #'rainbow-delimiters-mode)

  (use-package meghanada
    :commands meghanada-mode
    :init
    (add-hook! 'java-mode-hook #'(meghanada-mode rainbow-delimiters-mode))
    :config
    (setq meghanada-server-install-dir (concat bmacs-etc-dir "meghanada-server/")
          meghanada-use-company t
          meghanada-use-flycheck t
          meghanada-use-eldoc t
          meghanada-use-auto-start nil)

    ;; Setup on first use
  (add-hook! 'meghanada-mode-hook #'(flycheck-mode eldoc-mode)))

  (use-package android-mode
    :commands android-mode)

  (use-package groovy-mode
    :mode "\\.g\\(radle\\|roovy\\)$")
    ;; :config
    ;; (set! :eval 'groovy-mode "groovy"))

  (add-hook 'java-mode-hook (lambda ()
                              (setq c-basic-offset 4
                                    tab-width 4
                                    indent-tabs-mode nil)))
#+END_SRC

*** Javascript
Gross

**** Functions

#+BEGIN_SRC emacs-lisp
(defun +javascript|cleanup-tide-processes ()
  "TODO"
  (when tide-mode
    (unless (cl-loop with root = (tide-project-root)
                     for buf in (delq (current-buffer) (buffer-list))
                     if (buffer-local-value 'tide-mode buf)
                     collect buf)
      (kill-process (tide-current-server)))))

(defun +javascript*tide-project-root ()
  "Resolve to `bmacs-project-root' if `tide-project-root' fails."
  (or tide-project-root
      (or (locate-dominating-file default-directory "tsconfig.json")
          (locate-dominating-file default-directory "jsconfig.json"))
      (bmacs-project-root)))
#+END_SRC

**** Config

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :mode "\\.js$"
  :interpreter "node"
  :config
  (setq js2-skip-preprocessor-directives t
        js2-highlight-external-variables nil
        js-chain-indent t
        ;; let flycheck handle this
        js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        ;; Flycheck provides these features, so disable them: conflicting with
        ;; the eslint settings.
        js2-strict-trailing-comma-warning nil
        js2-strict-missing-semi-warning nil)

  (add-hook! 'js2-mode-hook #'(flycheck-mode rainbow-delimiters-mode))

  ;; Conform switch-case indentation to js2 normal indent
  (defvaralias 'js-switch-indent-offset 'js2-basic-offset)

  (sp-with-modes '(js2-mode rjsx-mode)
    (sp-local-pair "/*" "*/" :post-handlers '(("| " "SPC")))))

(use-package typescript-mode
  :mode "\\.ts$"
  :config
  (add-hook! 'typescript-mode-hook #'(flycheck-mode rainbow-delimiters-mode)))

(use-package rjsx-mode
  :commands rjsx-mode
  :mode "\\.jsx$"
  :mode "components/.+\\.js$"
  :init
  (defun +javascript-jsx-file-p ()
    "Detect React or preact imports early in the file."
    (and buffer-file-name
         (string= (file-name-extension buffer-file-name) "js")
         (re-search-forward "\\(^\\s-*import +React\\|\\( from \\|require(\\)[\"']p?react\\)"
                            magic-mode-regexp-match-limit t)
         (progn (goto-char (match-beginning 1))
                (not (sp-point-in-string-or-comment)))))

  (push '(+javascript-jsx-file-p . rjsx-mode) magic-mode-alist)
  :config
  (add-hook! 'rjsx-mode-hook
    ;; jshint doesn't know how to deal with jsx
    (push 'javascript-jshint flycheck-disabled-checkers))

  ;; `rjsx-electric-gt' relies on js2's parser to tell it when the cursor is in
  ;; a self-closing tag, so that it can insert a matching ending tag at point.
  ;; However, the parser doesn't run immediately, so a fast typist can outrun
  ;; it, causing issues, so force it to parse.
  (defun +javascript|reparse (n)
    ;; if n != 0, then rjsx-maybe-reparse will be run elsewhere
    (if (= n 0) (rjsx-maybe-reparse)))
  (advice-add #'rjsx-electric-gt :before #'+javascript|reparse))

(use-package coffee-mode
  :mode "\\.coffee$"
  :init (setq coffee-indent-like-python-mode t))

(use-package tide
  :hook ((js2-mode . tide-setup)
         (typescript-mode . tide-setup))
  :init
  (defun +javascript|init-tide-in-web-mode ()
    (when (string= (file-name-extension (or buffer-file-name "")) "tsx")
      (tide-setup)))
  (add-hook 'web-mode-hook #'+javascript|init-tide-in-web-mode)
  :config
  (setq tide-completion-detailed t
        tide-always-show-documentation t)

  ;; code completion
  (after! company
    ;; tide affects the global `company-backends', undo this so doom can handle
    ;; it buffer-locally
    (setq-default company-backends (delq 'company-tide (default-value 'company-backends))))

  (add-hook 'tide-mode-hook (lambda ()
                                (setq-local company-backends '(company-tide))))

  ;; resolve to `bmacs-project-root' if `tide-project-root' fails
  (advice-add #'tide-project-root :override #'+javascript*tide-project-root)

  ;; cleanup tsserver when no tide buffers are left
  (add-hook 'tide-mode-hook (lambda ()
                              (add-hook 'kill-buffer-hook #'+javascript|cleanup-tide-processes nil t)))

  (def-menu! +javascript/refactor-menu
    "Refactoring commands for `js2-mode' buffers."
    '(("Restart tsserver"                :exec tide-restart-server   :when (bound-and-true-p tide-mode))
      ("Reformat buffer/region (tide)"   :exec tide-reformat         :when (bound-and-true-p tide-mode))
      ("Organize imports"                :exec tide-organize-imports :when (bound-and-true-p tide-mode))
      ("Rename symbol"                   :exec tide-rename-symbol    :when (bound-and-true-p tide-mode) :region nil)
      ("Reformat buffer (eslint_d)"      :exec eslintd-fix           :when (bound-and-true-p eslintd-fix-mode) :region nil)
      ("Extract into function"           :exec js2r-extract-function          :region t)
      ("Extract into method"             :exec js2r-extract-method            :region t)
      ("Introduce parameter to function" :exec js2r-introduce-parameter       :region t)
      ("Localize parameter"              :exec js2r-localize-parameter        :region nil)
      ("Expand object"                   :exec js2r-expand-object             :region nil)
      ("Expand function"                 :exec js2r-expand-function           :region nil)
      ("Expand array"                    :exec js2r-expand-array              :region nil)
      ("Contract object"                 :exec js2r-contract-object           :region nil)
      ("Contract function"               :exec js2r-contract-function         :region nil)
      ("Contract array"                  :exec js2r-contract-array            :region nil)
      ("Wrap buffer in IIFE"             :exec js2r-wrap-buffer-in-iife       :region nil)
      ("Inject global into IIFE"         :exec js2r-inject-global-in-iife     :region t)
      ("Add to globals annotation"       :exec js2r-add-to-globals-annotation :region nil)
      ("Extract variable"                :exec js2r-extract-var               :region t)
      ("Inline variable"                 :exec js2r-inline-var                :region t)
      ("Rename variable"                 :exec js2r-rename-var                :region nil)
      ("Replace var with this"           :exec js2r-var-to-this               :region nil)
      ("Arguments to object"             :exec js2r-arguments-to-object       :region nil)
      ("Ternary to if"                   :exec js2r-ternary-to-if             :region nil)
      ("Split var declaration"           :exec js2r-split-var-declaration     :region nil)
      ("Split string"                    :exec js2r-split-string              :region nil)
      ("Unwrap"                          :exec js2r-unwrap                    :region t)
      ("Log this"                        :exec js2r-log-this)
      ("Debug this"                      :exec js2r-debug-this))
    :prompt "Refactor: ")

  (map! :map tide-mode-map
        :localleader
        :n "r" #'+javascript/refactor-menu
        :n "d" #'tide-jump-to-definition
        :n "u" #'tide-references
        :n "e" #'nodejs-repl
        :n "h" #'tide-documentation-at-point))

(use-package js2-refactor
  :commands
  (js2r-extract-function js2r-extract-method js2r-introduce-parameter
   js2r-localize-parameter js2r-expand-object js2r-contract-object
   js2r-expand-function js2r-contract-function js2r-expand-array
   js2r-contract-array js2r-wrap-buffer-in-iife js2r-inject-global-in-iife
   js2r-add-to-globals-annotation js2r-extract-var js2r-inline-var
   js2r-rename-var js2r-var-to-this js2r-arguments-to-object js2r-ternary-to-if
   js2r-split-var-declaration js2r-split-string js2r-unwrap js2r-log-this
   js2r-debug-this js2r-forward-slurp js2r-forward-barf))

(use-package eslintd-fix
  :commands (eslintd-fix-mode eslintd-fix)
  :config
  (add-hook! 'eslintd-fix-mode-hook
    (setq flycheck-javascript-eslint-executable eslintd-fix-executable)))

(use-package web-beautify
  :commands web-beautify-js)
#+END_SRC

*** Julia
Math stuff.

#+BEGIN_SRC emacs-lisp
(use-package julia-mode
  :mode "\\.jl$"
  :interpreter "julia"
  :config
  ;; Borrow matlab.el's fontification of math operators
  ;; From <https://ogbe.net/emacsconfig.html>
  (font-lock-add-keywords
   'julia-mode
   `((,(let ((OR "\\|"))
         (concat "\\(" ;; stolen `matlab.el' operators first
                 "[<>!]=?" OR
                 "\\.[/*^']" OR
                 "==" OR
                 "=>" OR
                 "\\<xor\\>" OR
                 "[-+*\\/^&|$]=?" OR ;; this has to come before next (updating operators)
                 "[-!^&|*+\\/~:]" OR
                 ;; more extra julia operators follow
                 "[%$]" OR
                 ;; bitwise operators
                 ">>>" OR ">>" OR "<<" OR
                 ">>>=" OR ">>" OR "<<" OR
                 ;; comparison
                 "[<>!]=?" OR
                 "\\)"))
      1 font-lock-type-face))))
#+END_SRC

*** Lua

#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :mode "\\.lua$"
  :interpreter "lua"
  :init
  (add-hook 'lua-mode-hook #'flycheck-mode)
  :config
  ;; sp's lua-specific rules are obnoxious, so we disable them
  (setq sp-pairs (delete (assq 'lua-mode sp-pairs) sp-pairs)))

(use-package company-lua
  :demand t
  :after lua-mode)

(use-package moonscript
  :mode ("\\.moon$" . moonscript-mode))
#+END_SRC

*** Markdown
It's not org-mode, but it'll do in a pinch

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode "/README$"
  :mode "\\.m\\(d\\|arkdown\\)$"
  :mode ("/README\\.md$" . gfm-mode)
  :init
  (setq markdown-enable-wiki-links t
        markdown-enable-math t
        markdown-italic-underscore t
        markdown-asymmetric-header t
        markdown-make-gfm-checkboxes-buttons t
        markdown-gfm-additional-languages '("sh")
        markdown-fontify-code-blocks-natively t
        markdown-hide-urls nil) ; trigger with `markdown-toggle-url-hiding'

  :config
  (add-hook! markdown-mode
    (auto-fill-mode +1)
    (setq line-spacing 2
          fill-column 100))

  (map! (:map markdown-mode-map
          [remap find-file-at-point] #'markdown-follow-thing-at-point
          "M-*"      #'markdown-insert-list-item
          "M-b"      #'markdown-insert-bold
          "M-i"      #'markdown-insert-italic
          "M-`"      #'+markdown/insert-del
          :m "gj"    #'markdown-next-visible-heading
          :m "gk"    #'markdown-previous-visible-heading
          ;; Assumes you have a markdown renderer plugin in chrome
          :n "M-r"   #'browse-url-of-file
          ;; TODO: Make context sensitive
          :m "]h"    #'markdown-next-visible-heading
          :m "[h"    #'markdown-previous-visible-heading
          :m "[p"    #'markdown-promote
          :m "]p"    #'markdown-demote
          :m "[l"    #'markdown-next-link
          :m "]l"    #'markdown-previous-link
          :i "M--"   #'markdown-insert-hr

          (:localleader
            :nv "o" #'markdown-open
            :nv "b" #'markdown-preview
            (:prefix "i"
              :nv "t" #'markdown-toc-generate-toc
              :nv "i" #'markdown-insert-image
              :nv "l" #'markdown-insert-link)))))


(use-package markdown-toc
  :commands markdown-toc-generate-toc)
#+END_SRC

*** OCaml
OCaml ... He doesn't scare me at all

#+BEGIN_SRC emacs-lisp
(use-package tuareg
  :mode ("\\.ml[4ilpy]?$" . tuareg-mode))

(use-package merlin
  :demand t
  :after tuareg
  :config
  (add-hook 'tuareg-mode-hook #'merlin-mode))
#+END_SRC

*** Perl (Disabled)
Is perl still a thing?

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'perl-mode-hook #'flycheck-mode)

(use-package perl6-mode)
;  :init (require 'perl6-detect))

(use-package flycheck-perl6
  :demand t
  :after perl6-mode
  :config (add-hook 'perl6-mode-hook #'flycheck-mode))
#+END_SRC

*** Php
The language of CEO's

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :mode ("\\.php[s345]?$" "\\.inc$")
  :interpreter "php"
  :config
  (add-hook 'php-mode-hook
    #'(ac-php-core-eldoc-setup flycheck-mode))

  (setq php-template-compatibility nil)

  ;; default is 10; this optimizes `smartparens' performance, but limits sp
  ;; pairs to 6 characters.
  (add-hook 'php-mode-hook (setq-local sp-max-pair-length 6))

  (sp-with-modes '(php-mode)
    (sp-local-pair "/* "    "*/" :post-handlers '(("||\n[i] " "RET") ("| " "SPC")))
    (sp-local-pair "<? "    " ?>")
    (sp-local-pair "<?php " " ?>")
    (sp-local-pair "<?="    " ?>")
    (sp-local-pair "<?"    "?>"   :when '(("RET")) :post-handlers '("||\n[i]"))
    (sp-local-pair "<?php" "?>"   :when '(("RET")) :post-handlers '("||\n[i]")))

  (map! :map php-mode-map
        :localleader
        (:prefix "r"
          :n "cv" #'php-refactor--convert-local-to-instance-variable
          :n "u"  #'php-refactor--optimize-use
          :v "xm" #'php-refactor--extract-method
          :n "rv" #'php-refactor--rename-local-variable)
        (:prefix "t"
          :n "r"  #'phpunit-current-project
          :n "a"  #'phpunit-current-class
          :n "s"  #'phpunit-current-test)))

(use-package php-refactor-mode
  :commands php-refactor-mode
  :init (add-hook 'php-mode-hook #'php-refactor-mode))

(use-package phpunit
  :commands (phpunit-current-test phpunit-current-class phpunit-current-project))

(use-package php-boris :commands php-boris)

(use-package company-php
  :commands (company-ac-php-backend ac-php-remake-tags ac-php-remake-tags-all ac-php-core-eldoc-setup)
  :config
  (unless (executable-find "phpctags")
    (warn "php-mode: phpctags isn't installed, auto-completion will be gimped"))

  (setq ac-php-tags-path (concat bmacs-cache-dir "ac-php/")))
#+END_SRC

*** Plant Uml



Simple uml syntax

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :mode "\\.p\\(lant\\)?uml$"
  :config
  (setq plantuml-jar-path (concat bmacs-etc-dir "plantuml.jar"))

  (unless (executable-find "java")
    (warn "plantuml-mode: can't find java, preview disabled."))
  (unless (file-exists-p plantuml-jar-path)
    (warn "plantuml-mode: can't find plantuml.jar; run M-x +plantuml/install.")))

(use-package flycheck-plantuml
  :demand t
  :after plantuml-mode
  :config (flycheck-plantuml-setup))
#+END_SRC

*** Play Framework
Play framework routes support

#+BEGIN_SRC emacs-lisp
(use-package play-routes-mode
  :mode "/routes$")
#+END_SRC

*** Purescript

#+BEGIN_SRC emacs-lisp
(use-package purescript-mode
  :mode "\\.purs$"
  :config
  (add-hook 'purescript-mode-hook
    #'(flycheck-mode purescript-indentation-mode rainbow-delimiters-mode))

  (load "purescript-mode-autoloads" nil t))

(use-package psc-ide
  :demand t
  :after purescript-mode
  :config
  (add-hook 'purescript-mode-hook #'psc-ide-mode))

#+END_SRC

*** Python
Hey guys, it's python!

#+BEGIN_SRC emacs-lisp
(defvar +python-pyenv-root nil
  "The path to pyenv's root directory. This is automatically set when `python'
is loaded.")

(defvar +python-pyenv-versions nil
  "Available versions of python in pyenv.")

(defvar-local +python-current-version nil
  "The currently active pyenv version.")

;;
;; Plugins
;;

(use-package python
  :commands python-mode
  :init
  (setq python-environment-directory bmacs-cache-dir
        python-indent-guess-indent-offset-verbose nil
        python-shell-interpreter "python")

  :config
  (add-hook! 'python-mode-hook #'(flycheck-mode highlight-numbers-mode))

  (when (executable-find "ipython")
    (setq python-shell-interpreter "ipython"
          python-shell-interpreter-args "-i --simple-prompt --no-color-info"
          python-shell-prompt-regexp "In \\[[0-9]+\\]: "
          python-shell-prompt-block-regexp "\\.\\.\\.\\.: "
          python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
          python-shell-completion-setup-code
          "from IPython.core.completerlib import module_completion"
          python-shell-completion-string-code
          "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))

  ;; Version management with pyenv
  (defun +python|add-version-to-modeline ()
    "Add version string to the major mode in the modeline."
    (setq mode-name
          (if +python-current-version
              (format "Python %s" +python-current-version)
            "Python")))
  (add-hook! 'python-mode-hook #'+python|add-version-to-modeline)

  (if (not (executable-find "pyenv"))
      (setq +python-current-version (string-trim (shell-command-to-string "python --version 2>&1 | cut -d' ' -f2")))
    (setq +python-pyenv-root     (string-trim (shell-command-to-string "pyenv root"))
          +python-pyenv-versions (split-string (shell-command-to-string "pyenv versions --bare") "\n" t))

    (defun +python|detect-pyenv-version ()
      "Detect the pyenv version for the current project and set the relevant
environment variables."
      (when-let* ((version-str (shell-command-to-string "python --version 2>&1 | cut -d' ' -f2")))
        (setq version-str (string-trim version-str)
              +python-current-version version-str)
        (let ((pyenv-current-path (concat +python-pyenv-root "/versions/" version-str)))
          (when (file-directory-p pyenv-current-path)
            (setq pythonic-environment pyenv-current-path)))
        (when (member version-str +python-pyenv-versions)
          (setenv "PYENV_VERSION" version-str))))
    (add-hook 'python-mode-hook #'+python|detect-pyenv-version))

  (define-key python-mode-map (kbd "DEL") nil) ; interferes with smartparens
  (sp-with-modes 'python-mode
    (sp-local-pair "'" nil :unless '(sp-point-before-word-p sp-point-after-word-p sp-point-before-same-p))))


(use-package anaconda-mode
  :demand t
  :after python
  :init
  (add-hook 'python-mode-hook #'anaconda-mode)
  (add-hook 'anaconda-mode-hook #'anaconda-eldoc-mode)
  (setq anaconda-mode-installation-directory (concat bmacs-etc-dir "anaconda/")
        anaconda-mode-eldoc-as-single-line t))

(use-package company-anaconda
  :demand t
  :after anaconda-mode
  :config
  (map! :map python-mode-map
        :localleader
        :prefix "f"
        :nv "d" #'anaconda-mode-find-definitions
        :nv "h" #'anaconda-mode-show-doc
        :nv "a" #'anaconda-mode-find-assignments
        :nv "f" #'anaconda-mode-find-file
        :nv "u" #'anaconda-mode-find-references))


(use-package pip-requirements
  :mode ("/requirements.txt$" . pip-requirements-mode))
#+END_SRC

*** Ruby

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :mode ("\\.rb$" "\\.rake$" "\\.gemspec$" "\\.?pryrc$"
         "/\\(Gem\\|Cap\\|Vagrant\\|Rake\\|Pod\\|Puppet\\|Berks\\)file$")
  :interpreter "ruby"
  :init
  (add-hook 'ruby-mode-hook #'flycheck-mode)
  :config
  (setq ruby-deep-indent-paren t)
  ;; Don't interfere with my custom RET behavior
  (define-key ruby-mode-map [?\n] nil)

  ;; Version management with rbenv
  (defun +ruby|add-version-to-modeline ()
    "Add version string to the major mode in the modeline."
    (setq mode-name
          (if +python-current-version
              (format "Ruby %s" +ruby-current-version)
            "Ruby")))
  (add-hook 'ruby-mode-hook #'+ruby|add-version-to-modeline)

  (if (not (executable-find "rbenv"))
      (setq +ruby-current-version (string-trim (shell-command-to-string "ruby --version 2>&1 | cut -d' ' -f2")))
    (setq +ruby-rbenv-versions (split-string (shell-command-to-string "rbenv versions --bare") "\n" t))

    (defun +ruby|detect-rbenv-version ()
      "Detect the rbenv version for the current project and set the relevant
environment variables."
      (when-let* ((version-str (shell-command-to-string "ruby --version 2>&1 | cut -d' ' -f2")))
        (setq version-str (string-trim version-str)
              +ruby-current-version version-str)
        (when (member version-str +ruby-rbenv-versions)
          (setenv "RBENV_VERSION" version-str))))
    (add-hook 'ruby-mode-hook #'+ruby|detect-rbenv-version)))

  ; (map! :map ruby-mode-map
  ;       (:localleader
  ;       (:prefix "r"
  ;        :nv "b"  #'ruby-toggle-block
  ;        :nv "ec" #'ruby-refactor-extract-constant
  ;        :nv "el" #'ruby-refactor-extract-to-let
  ;        :nv "em" #'ruby-refactor-extract-to-method
  ;        :nv "ev" #'ruby-refactor-extract-local-variable
  ;        :nv "ad" #'ruby-refactor-add-parameter
  ;        :nv "cc" #'ruby-refactor-convert-post-conditional))))
#+END_SRC

*** Rust
The future!

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :mode "\\.rs$"
  :config
  (setq rust-indent-method-chain t)

  (map! :map rust-mode-map
        :localleader
        :desc "Build menu" :n "b" #'+rust/build-menu)

  (def-menu! +rust/build-menu
    "TODO"
    '(("cargo run"   :exec "cargo run --color always")
      ("cargo build" :exec "cargo build --color always")
      ("cargo test"  :exec "cargo test --color always"))
    :prompt "Cargo: "))

(use-package racer
  :demand t
  :after rust-mode
  :preface
  :init
  (add-hook! 'rust-mode-hook #'(racer-mode eldoc-mode flycheck-rust-setup))
  :config

  (map! :map rust-mode-map
        :localleader
        :desc "Racer describe"        :n "d" #'racer-describe
        :desc "Racer find definition" :n "D" #'racer-find-definition)

  (unless (file-exists-p racer-cmd)
    (warn "rust-mode: racer binary can't be found; auto-completion is disabled")))

(use-package company-racer
  :demand t
  :after racer
  :config
  (add-hook 'rust-mode-hook #'(lambda ()
                                (setq-local company-backends '(company-racer)))))

(use-package flycheck-rust
  :demand t
  :after rust-mode
  :config (add-hook 'rust-mode-hook #'flycheck-mode))
#+END_SRC

*** Scala
The best the JVM's got to offer

#+BEGIN_SRC emacs-lisp


(use-package scala-mode
  :mode "\\.s\\(cala\\|bt\\)$"
  :config
  (setq scala-indent:align-parameters t)
  (map! :mode scala-mode
        :niv "TAB" 'ensime-company-complete-or-indent
        :localleader
        :desc "Start ensime"             :n "s" #'ensime
        :desc "Shutdown ensime"          :n "x" #'ensime-shutdown
        :desc "Sbt command"              :n "c" #'sbt-command
        :desc "Goto next error"          :n "e" #'next-error
        :desc "Show errors at point"     :n "E" #'ensime-print-errors-at-point))

(use-package sbt-mode
  :demand t
  :after scala-mode)

(use-package ensime
  :demand t
  :after scala-mode
  :config
  (add-hook 'scala-mode #'(lambda ()
                            (setq-local company-backends '(ensime-company company-yasnippet))))

  (setq ensime-startup-snapshot-notification nil
        ensime-startup-notification nil
        ensime-eldoc-hints nil
        ensime-completion-style nil)

  (add-hook 'scala-mode-hook #'ensime-mode)
  (add-hook 'ensime-mode-hook #'eldoc-mode)

  ;; Fix void-variable imenu-auto-rescan error caused by `ensime--setup-imenu'
  ;; trying to make imenu variables buffer local before imenu is loaded.
  (require 'imenu))
#+END_SRC

*** Shell
Ghetto shell scripting

#+BEGIN_SRC emacs-lisp
(defun +sh--match-variables-in-quotes (limit)
  "Search for variables in double-quoted strings bounded by LIMIT."
  (with-syntax-table sh-mode-syntax-table
    (let (res)
      (while
          (and (setq res
                     (re-search-forward
                      "[^\\]\\(\\$\\)\\({.+?}\\|\\<[a-zA-Z0-9_]+\\|[@*#!]\\)"
                      limit t))
               (not (eq (nth 3 (syntax-ppss)) ?\"))))
      res)))

;;;###autoload
(defun +sh--match-command-subst-in-quotes (limit)
  "Search for variables in double-quoted strings bounded by LIMIT."
  (with-syntax-table sh-mode-syntax-table
    (let (res)
      (while
          (and (setq res
                     (re-search-forward "[^\\]\\(\\$(.+?)\\|`.+?`\\)"
                                        limit t))
               (not (eq (nth 3 (syntax-ppss)) ?\"))))
      res)))

(defvar +sh-builtin-keywords
  '("sudo" "echo" "ls" "sleep" "tee" "cd" "cat")
  "A list of common shell commands and keywords to be fontified especially in
`sh-mode'.")

(use-package sh-script ; built-in
  :mode ("\\.zsh$"   . sh-mode)
  :mode ("\\.zunit$" . sh-mode)
  :mode ("/bspwmrc$" . sh-mode)
  :init
  (add-hook! sh-mode #'(flycheck-mode highlight-numbers-mode))
  :config
  ;(set! :electric 'sh-mode :words '("else" "elif" "fi" "done" "then" "do" "esac" ";;")) TODO
  (setq sh-indent-after-continuation 'always)

  ;; recognize function names with dashes in them
   (push '((sh . ((nil "^\\s-*function\\s-+\\([[:alpha:]_-][[:alnum:]_-]*\\)\\s-*\\(?:()\\)?" 1)
                  (nil "^\\s-*\\([[:alpha:]_-][[:alnum:]_-]*\\)\\s-*()" 1))))
         sh-imenu-generic-expression)

  ;; 1. Fontifies variables in double quotes
  ;; 2. Fontify command substitution in double quotes
  ;; 3. Fontify built-in/common commands (see `+sh-builtin-keywords')
   (font-lock-add-keywords
    'sh-mode `((+sh--match-variables-in-quotes
                (1 'font-lock-constant-face prepend)
                (2 'font-lock-variable-name-face prepend))
               (+sh--match-command-subst-in-quotes
                (1 'sh-quoted-exec prepend))
               (,(regexp-opt +sh-builtin-keywords 'words)
                (0 'font-lock-type-face append))))

  ;; autoclose backticks
  ;;(sp-local-pair 'sh-mode "`" nil :unless '(sp-point-before-word-p sp-point-before-same-p))

  ;; sh-mode has file extensions checks for other shells, but not zsh, so...
  (defun +sh|detect-zsh ()
    (when (or (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
              (save-excursion
                (goto-char (point-min))
                (looking-at-p "^#!.+zsh[$\\s-]")))
      (sh-set-shell "zsh")))
  (add-hook 'sh-mode-hook #'+sh|detect-zsh))


(use-package company-shell
  :demand t
  :after sh-script
  :config
  (add-hook 'sh-mode-hook #'(lambda ()
                              (setq-local company-backends '(company-shell company-files))))
  (setq company-shell-delete-duplicates t))

#+END_SRC


*** Swift
Get Scwhifty!

#+BEGIN_SRC emacs-lisp
(use-package swift-mode
  :mode "\\.swift$"
  :init
  (add-hook 'swift-mode-hook #'flycheck-mode)
  :config
  (cl-pushnew 'swift flycheck-checkers))

(use-package company-sourcekit
  :demand t
  :after swift-mode
  :config
  (add-hook 'swift-mode-hook #'(lambda ()
                                 (setq-local company-backends '(company-sourcekit company-yasnippet)))))
#+END_SRC

*** Web

**** General

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :commands (web-beautify-html web-beautify-css)
  :init
  (map! (:map* (css-mode-map scss-mode-map less-css-mode-map)
          :n "gQ" #'web-beautify-css)
        (:map* web-mode-map
          :n "gQ" #'web-beautify-html)))


(use-package emmet-mode
  :commands emmet-mode
  :preface (defvar emmet-mode-keymap (make-sparse-keymap))
  :init
  (add-hook 'css-mode #'emmet-mode)
  (add-hook 'web-mode #'emmet-mode)
  (add-hook 'html-mode #'emmet-mode)
  (add-hook 'haml-mode #'emmet-mode)
  (add-hook 'nxml-mode #'emmet-mode)
  (add-hook 'rjsx-mode #'emmet-mode)
  :config
  (setq emmet-move-cursor-between-quotes t)
  (map! :map emmet-mode-keymap
        :v "M-e" #'emmet-wrap-with-markup
        :i "M-e" #'emmet-expand-yas
        :i "M-E" #'emmet-expand-line))

#+END_SRC

**** Html

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.p?html?$"
  :mode "\\.\\(tpl\\|blade\\)\\(\\.php\\)?$"
  :mode "\\.erb$"
  :mode "\\.jsp$"
  :mode "\\.as[cp]x$"
  :mode "\\.mustache$"
  :mode "\\.tsx$"
  :mode "wp-content/themes/.+/.+\\.php$"
  :init
  (add-hook 'web-mode-hook #'turn-off-smartparens-mode)
  :config
  (add-hook 'web-mode-hook (lambda ()
                             (setq-local company-backends '(company-web-html company-yasnippet))))
  (setq web-mode-enable-html-entities-fontification t)

  (map! :map web-mode-map
        (:localleader
        :n "rt" #'web-mode-element-rename)
        "M-/" #'web-mode-comment-or-uncomment
        :i  "SPC" #'self-insert-command
        :n  "M-r" #'doom/web-refresh-browser
        :n  "za"  #'web-mode-fold-or-unfold
        :nv "]a"  #'web-mode-attribute-next
        :nv "[a"  #'web-mode-attribute-previous
        :nv "]t"  #'web-mode-tag-next
        :nv "[t"  #'web-mode-tag-previous
        :nv "]T"  #'web-mode-element-child
        :nv "[T"  #'web-mode-element-parent))

(use-package company-web
  :demand t
  :after web-mode)

(use-package haml-mode :mode "\\.haml$")

(use-package pug-mode
  :mode "\\.jade$"
  :mode "\\.pug$")
#+END_SRC

**** CSS

#+BEGIN_SRC emacs-lisp
(add-hook 'css-mode-hook #'rainbow-delimiters-mode)
(add-hook! (css-mode-hook) #'(yas-minor-mode-on flycheck-mode highlight-numbers-mode))

(after! smartparens
  (sp-with-modes '(css-mode scss-mode less-css-mode stylus-mode)
    (sp-local-pair "/*" "*/" :post-handlers '(("[d-3]||\n[i]" "RET") ("| " "SPC")))))

(map! :map* (css-mode-map scss-mode-map less-css-mode-map)
      :n "M-R" #'+css/web-refresh-browser
      (:localleader
        :n  "rb" #'+css/toggle-inline-or-block))

(use-package rainbow-mode
  :commands rainbow-mode
  :init
  (add-hook 'css-mode #'rainbow-mode)
  (add-hook 'sass-mode #'rainbow-mode))

(use-package css-mode
  :mode "\\.css$"
  :mode ("\\.scss$" . scss-mode)
  :config
  (add-hook 'css-mode-hook #'(lambda ()
                               (setq-local company-backends '(company-css company-yasnippet))))
  (add-hook 'sass-mode-hook #'(lambda ()
                               (setq-local company-backends '(company-css company-yasnippet)))))

(use-package sass-mode
  :mode "\\.sass$")

(use-package less-css-mode
  :mode "\\.less$")

(use-package stylus-mode
  :mode "\\.styl$"
  :init (add-hook! stylus-mode #'(yas-minor-mode-on flycheck-mode)))
#+END_SRC

** Misc

*** hydra
Emacs bindings that stick around

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :demand t
  :config
  (setq lv-use-seperator t))
#+END_SRC

*** command-log-mode
Log commands to buffer

#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :commands (command-log-mode global-command-log-mode)
  :config
  (setq command-log-mode-auto-show t
        command-log-mode-open-log-turns-on-mode t))
#+END_SRC


** Popup Rules

Let's define a simple function that allows us to easily make any buffer into a popup based on a
regular expression. This function adds an entry to the `display-buffer-alist` to define constraints
about how the buffer should be displayed. These constraints define a simple popup behavior.

#+BEGIN_SRC emacs-lisp
(cl-defun bmacs/make-popup (buffer-rx &optional (height 0.4))
    (add-to-list 'bmacs-popups buffer-rx)
    (add-to-list 'display-buffer-alist
                 `(,buffer-rx
                   (display-buffer-reuse-window
                    display-buffer-in-side-window)
                   (reusable-frames . visible)
                   (side            . bottom)
                   (window-height   . ,height))))
#+END_SRC

Now we're going to create a set of rules based on the buffers we would like to become popups.

#+BEGIN_SRC emacs-lisp
;; Messages
(bmacs/make-popup (rx bos "*Messages*" eos))
;; Backtrace
(bmacs/make-popup (rx bos "*Backtrace*" eos))
;; Warnings
(bmacs/make-popup (rx bos "*Warnings*" eos))
;; Compilation
(bmacs/make-popup (rx bos "*compilation*" eos))
;; Pretty Print Eval Output
(bmacs/make-popup (rx bos "*Pp Eval Output*" eos))
;; Help
(bmacs/make-popup (rx bos "*Help*" eos))
;; Restclient Results
(bmacs/make-popup (rx bos "*HTTP Response*" eos))
;; Eshell
(bmacs/make-popup (rx bos "*eshell*" eos))
;; Bmacs Eshell
(bmacs/make-popup (rx bos "*bmacs eshell*" eos))
;; Eshell Project Buffer
(bmacs/make-popup (rx bos "*eshell-project*" eos))
;; Flycheck Errors
(bmacs/make-popup (rx bos "*Flycheck errors*" eos))
;; VC Diff
(bmacs/make-popup (rx bos "*vc-diff*" eos))
;; Sbt
(bmacs/make-popup (rx bos "*sbt*"))
;; GHC Error
(bmacs/make-popup (rx bos "*GHC Error*"))
;; Profiler Report
(bmacs/make-popup (rx bos "*CPU-Profiler-Report"))
;; Org Popups
(bmacs/make-popup (rx bos "*Calendar*" eos))
(bmacs/make-popup (rx bos "*Org todo*" eos) 0.05)
(bmacs/make-popup (rx bos "*Org Note*" eos) 0.1)
(bmacs/make-popup (rx bos "*Org Select*" eos) 0.2)
(bmacs/make-popup (rx bos "*Org Links*" eos) 0.05)
(bmacs/make-popup (rx bos "*Org Export Dispatcher*" eos) 0.05)
(bmacs/make-popup (rx bos "*Org Commands*" eos) 0.05)
(bmacs/make-popup (rx bos "*Org Agenda") 0.2)
(bmacs/make-popup (rx bos "*Agenda Commands*" eos) 0.2)
(bmacs/make-popup (rx bos "*Org Clock*" eos))
(bmacs/make-popup (rx bos "*Org Src"))
(bmacs/make-popup (rx bos "*Edit Formulas*" eos) 0.01)
(bmacs/make-popup (rx bos "*Org-Babel") 0.25)
;(bmacs/make-popup (rx bos "CAPTURE") 0.2)
;; Scratch Buffer
(bmacs/make-popup (rx bos "*scratch*" eos) 0.4)
#+END_SRC


** Hydras

*** Window Management

#+BEGIN_SRC emacs-lisp
(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

 (defhydra bmacs-hydra-window ()
   "
Movement^^        ^Split^         ^Switch^		^Resize^
----------------------------------------------------------------
_h_ ←       	_/_ vertical   	_b_uffer			_H_ X←
_j_ ↓        	_-_ horizontal	_f_ind files	_J_ X↓
_k_ ↑        	_z_ undo      	_a_ce 1				_K_ X↑
_l_ →        	_Z_ reset      	_s_wap				_L_ X→
_F_ollow		  _D_lt Other   	_S_ave				_m_aximize
_SPC_ cancel	_o_nly this   	_d_elete			_=_ Balance
"
   ("h" windmove-left )
   ("j" windmove-down )
   ("k" windmove-up )
   ("l" windmove-right )
   ("H" hydra-move-splitter-left)
   ("J" hydra-move-splitter-down)
   ("K" hydra-move-splitter-up)
   ("L" hydra-move-splitter-right)
   ("b" counsel-projectile-switch-to-buffer)
   ("f" counsel-find-file)
   ("F" follow-mode)
   ("a" (lambda ()
          (interactive)
          (ace-window 1)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("/" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right)))
   ("-" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down)))
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("S" save-buffer)
   ("d" delete-window)
   ("D" (lambda ()
          (interactive)
          (ace-window 16)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("o" delete-other-windows)
   ("m" ace-delete-other-windows)
   ("=" balance-windows)
   ("z" (progn
          (winner-undo)
          (setq this-command 'winner-undo)))
   ("Z" winner-redo)
   ("SPC" nil))

#+END_SRC

*** Smerge

#+BEGIN_SRC emacs-lisp
    (defhydra bmacs-hydra-smerge (:hint nil
                            :pre (smerge-mode 1)
                            ;; Disable `smerge-mode' when quitting hydra if
                            ;; no merge conflicts remain.
                            :post (smerge-auto-leave))
      "
                                                      ╭────────┐
    Movement   Keep           Diff              Other │ smerge │
    ╭─────────────────────────────────────────────────┴────────╯
       ^_g_^       [_b_] base       [_<_] upper/base    [_C_] Combine
       ^_C-k_^     [_u_] upper      [_=_] upper/lower   [_r_] resolve
       ^_k_ ↑^     [_l_] lower      [_>_] base/lower    [_R_] remove
       ^_j_ ↓^     [_a_] all        [_H_] hightlight
       ^_C-j_^     [_RET_] current  [_E_] ediff             ╭──────────
       ^_G_^                                            │ [_q_] quit"
      ("g" (progn (goto-char (point-min)) (smerge-next)))
      ("G" (progn (goto-char (point-max)) (smerge-prev)))
      ("C-j" smerge-next)
      ("C-k" smerge-prev)
      ("j" next-line)
      ("k" previous-line)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("\C-m" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("H" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("R" smerge-kill-current)
      ("q" nil :color blue))
#+END_SRC

*** Zoom

#+BEGIN_SRC emacs-lisp
  (defhydra bmacs-hydra-text-zoom (:hint t :color red)
    "
      Text zoom: _j_:zoom in, _k_:zoom out, _0_:reset
"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("0" (text-scale-set 0) "reset"))
#+END_SRC

** Functions

*** File Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/copy-file ()
  "Write the file under new name."
  (interactive)
  (call-interactively 'write-file))

(defun bmacs/rename-file (filename &optional new-filename)
  "Rename FILENAME to NEW-FILENAME.

  When NEW-FILENAME is not specified, asks user for a new name.

  Also renames associated buffer (if any exists), invalidates
  projectile cache when it's possible and update recentf list."
  (interactive "f")
  (when (and filename (file-exists-p filename))
    (let* ((buffer (find-buffer-visiting filename))
           (short-name (file-name-nondirectory filename))
           (new-name (if new-filename new-filename
                       (read-file-name
                        (format "Rename %s to: " short-name)))))
      (cond ((get-buffer new-name)
             (error "A buffer named '%s' already exists!" new-name))
            (t
             (let ((dir (file-name-directory new-name)))
               (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                 (make-directory dir t)))
             (rename-file filename new-name 1)
             (when buffer
               (kill-buffer buffer)
               (find-file new-name))
             (when (fboundp 'recentf-add-file)
               (recentf-add-file new-name)
               (recentf-remove-if-non-kept filename))
             (when (projectile-project-p)
               (call-interactively #'projectile-invalidate-cache))
             (message "File '%s' successfully renamed to '%s'" short-name (file-name-nondirectory new-name)))))))

(defun bmacs/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let* ((name (buffer-name))
         (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let* ((dir (file-name-directory filename))
             (new-name (read-file-name "New name: " dir)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (let ((dir (file-name-directory new-name)))
                 (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                   (make-directory dir t)))
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (when (fboundp 'recentf-add-file)
                 (recentf-add-file new-name)
                 (recentf-remove-if-non-kept filename))
               (when (projectile-project-p)
                 (call-interactively #'projectile-invalidate-cache))
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(defun bmacs/delete-file (filename &optional ask-user)
  "Remove specified file or directory.

  Also kills associated buffer (if any exists) and invalidates
  projectile cache when it's possible.

  When ASK-USER is non-nil, user will be asked to confirm file
  removal."
  (interactive "f")
  (when (and filename (file-exists-p filename))
    (let ((buffer (find-buffer-visiting filename)))
      (when buffer
        (kill-buffer buffer)))
    (when (or (not ask-user)
              (yes-or-no-p "Are you sure you want to delete this file? "))
      (delete-file filename)
      (when (projectile-project-p)
        (call-interactively #'projectile-invalidate-cache)))))

(defun bmacs/delete-file-confirm (filename)
  "Remove specified file or directory after users approval.

  FILENAME is deleted using `bmacs/delete-file' function.."
  (interactive "f")
  (funcall-interactively #'bmacs/delete-file filename t))

(defun bmacs/delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to delete this file? ")
        (delete-file filename t)
        (kill-buffer buffer)
        (when (projectile-project-p)
          (call-interactively #'projectile-invalidate-cache))
        (message "File '%s' successfully removed" filename)))))

(defun bmacs/sudo-find-file (file)
  "Open FILE as root."
  (interactive
   (list (read-file-name "Open as root: ")))
  (find-file (if (file-writable-p file)
                 file
               (if (file-remote-p file)
                   (let ((method (file-remote-p file 'method))
                         (user (file-remote-p file 'user))
                         (host (file-remote-p file 'host))
                         (localname (file-remote-p file 'localname)))
                     (concat "/" method ":" user (if user "@" "") host  "|sudo:root@" host ":" localname))
                 (concat "/sudo:root@localhost:" file)))))

(defun bmacs/sudo-this-file ()
  "Open the current file as root."
  (interactive)
  (bmacs/sudo-find-file (file-truename buffer-file-name)))

(defun bmacs/show-and-copy-buffer-filename ()
  "Show and copy the full path to the current file in the minibuffer."
  (interactive)
  ;; list-buffers-directory is the variable set in dired buffers
  (let ((file-name (or (buffer-file-name) list-buffers-directory)))
    (if file-name
        (progn
          (kill-new file-name)
          (message file-name))
      (error "Buffer not visiting a file"))))

(defun bmacs/alternate-buffer (&optional window)
  "Switch back and forth between current and last buffer in the
  current window."
  (interactive)
  (let ((current-buffer (window-buffer window))
        (buffer-predicate
         (frame-parameter (window-frame window) 'buffer-predicate)))
    ;; switch to first buffer previously shown in this window that matches
    ;; frame-parameter `buffer-predicate'
    (switch-to-buffer
     (or (cl-find-if (lambda (buffer)
                       (and (not (eq buffer current-buffer))
                            (or (null buffer-predicate)
                                (funcall buffer-predicate buffer))
                            (persp-contain-buffer-p buffer)))
                     (mapcar #'car (window-prev-buffers window)))
         ;; `other-buffer' honors `buffer-predicate' so no need to filter
         (other-buffer current-buffer t)))))

(defun bmacs/toggle-fold ()
  (interactive)
  (save-excursion
    (end-of-line)
    (hs-toggle-hiding)))
#+END_SRC

*** Buffer Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/kill-buffer-and-windows (buffer)
  "Kill the buffer and delete all the windows it's displayed in."
  (dolist (window (get-buffer-window-list buffer))
    (unless (one-window-p t)
      (delete-window window)))
  (kill-buffer buffer))

(defun bmacs/kill-other-buffers (&optional persp-p)
  "Kill all other buffers (besides the current one).

If PROJECT-P (universal argument), kill only buffers that belong to the current
project."
  (interactive "P")
  (let ((buffers (if persp-p (persp-buffer-list) (buffer-list)))
        (current-buffer (current-buffer)))
    (dolist (buf buffers)
      (unless (eq buf current-buffer)
        (bmacs/kill-buffer-and-windows buf)))
    (when (called-interactively-p 'interactive)
      (message "Killed %s buffers" (length buffers)))))

 (defun bmacs//get-buffer-display-time (buffer start-time)
   (with-current-buffer buffer
     (let ((buffer-time (float-time buffer-display-time)))
       (if (< start-time buffer-time)
           0
         buffer-time))))

 (defun bmacs/show-hide-popup-buffer (&optional select buffer-rx)
   (interactive)
   (let ((start-time (float-time (current-time)))
         (open-popup-buffers
           (if buffer-rx
             (seq-filter
               (lambda (buff)
                 (string-match buffer-rx (buffer-name buff)))
               (mapcar #'window-buffer (window-at-side-list)))
             (seq-filter
               (lambda (buff)
                 (seq-some
                   (lambda (buff-rx)
                     (string-match buff-rx (buffer-name buff)))
                   bmacs-popups))
               (mapcar #'window-buffer (window-at-side-list)))))
         (closed-popup-buffers
           (if buffer-rx
             (seq-filter
               (lambda (buff)
                 (string-match buffer-rx (buffer-name buff)))
               (buffer-list))
             (seq-filter
               (lambda (buff)
                 (seq-some
                   (lambda (buff-rx)
                     (string-match buff-rx (buffer-name buff)))
                   bmacs-popups))
               (buffer-list)))))
   (cond ((= 1 (length open-popup-buffers))
          (delete-window (get-buffer-window (car open-popup-buffers))))
         ((and (> 0 (length open-popup-buffers) (not select)))
           (delete-window
             (get-buffer-window
               (car
                 (sort
                   open-popup-buffers
                   #'(lambda (a b)
                     (> (bmacs//get-buffer-display-time a start-time) (bmacs//get-buffer-display-time b start-time))))))))
         ((> 0 (length open-popup-buffers))
           (ivy-read "Close popup: "
                 (mapcar #'buffer-name open-popup-buffers)
                 :action (lambda (x)
                           (delete-window (get-buffer-window x)))
                 :caller 'bmacs/show-hide-popup-buffer))
         ((seq-empty-p closed-popup-buffers)
          (message "No popup buffers found"))
         ((= 1 (length closed-popup-buffers))
          (pop-to-buffer (car closed-popup-buffers)))
         ((not select)
           (pop-to-buffer
             (car
               (sort
                 closed-popup-buffers
                 #'(lambda (a b)
                   (> (bmacs//get-buffer-display-time a start-time) (bmacs//get-buffer-display-time b start-time)))))))
         (t
          (ivy-read "Open popup: "
                 (mapcar #'buffer-name closed-popup-buffers)
                 :require-match t
                 :action (lambda (x)
                           (pop-to-buffer x))
                 :caller 'bmacs/show-hide-popup-buffer)))))

(defun bmacs/toggle-whitespace ()
  (interactive)
  (if (and (boundp 'whitespace-mode) whitespace-mode)
      (whitespace-mode -1)
    (whitespace-mode +1)))

(defun bmacs/scratch-buffer ()
  (interactive)
  (let ((text (and (region-active-p)
                   (buffer-substring-no-properties
                    (region-beginning) (region-end))))
        (mode major-mode)
        (derived-p (derived-mode-p 'prog-mode 'text-mode))
        (scratch-buffer (get-buffer-create "*scratch*")))
    (with-current-buffer scratch-buffer
      (when (and (not (eq major-mode mode))
                 derived-p
                 (functionp mode))
        (funcall mode))
      (when text
        (when (> (buffer-size) 0)
          (goto-char (point-max))
          (newline))
        (insert text))
      (pop-to-buffer "*scratch*"))))
#+END_SRC

*** Window Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/window-zoom ()
  "Maximize and isolate the current buffer. Activate again to undo this. If the
window changes before then, the undo expires."
  (interactive)
  (if (and (one-window-p)
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (window-configuration-to-register ?_)
    (delete-other-windows)))
#+END_SRC

*** Counsel Project Bookmarks

#+BEGIN_SRC emacs-lisp
(defun counsel-projectile-bookmark ()
    "Forward to `bookmark-jump' or `bookmark-set' if bookmark doesn't exist."
    (interactive)
    (require 'bookmark)
    (let ((projectile-bookmarks (projectile-bookmarks)))
      (ivy-read "Create or jump to bookmark: "
                projectile-bookmarks
                :action (lambda (x)
                          (cond ((and counsel-bookmark-avoid-dired
                                      (member x projectile-bookmarks)
                                      (file-directory-p (bookmark-location x)))
                                 (with-ivy-window
                                   (let ((default-directory (bookmark-location x)))
                                     (counsel-find-file))))
                                ((member x projectile-bookmarks)
                                 (with-ivy-window
                                   (bookmark-jump x)))
                                (t
                                 (bookmark-set x))))
                :caller 'counsel-projectile-bookmark)))

  (ivy-set-actions
   'counsel-projectile-bookmark
   '(("d" bookmark-delete "delete")
     ("e" bookmark-rename "edit")))

  (defun projectile-bookmarks ()
    (let ((bmarks (bookmark-all-names)))
      (cl-remove-if-not #'workspace-bookmark-p bmarks)))

  (defun workspace-bookmark-p (bmark)
    (let ((bmark-path (expand-file-name (bookmark-location bmark))))
      (string-prefix-p (bmacs-project-root) bmark-path)))
#+END_SRC

*** Random Functions

#+BEGIN_SRC emacs-lisp
(defun bmacs/delete-git-index-lock ()
  "Deletes index.lock file for git project if it exists"
  (interactive)
  (let ((git-index-lock-file (concat (magit-git-dir) "index.lock")))
    (when (file-exists-p git-index-lock-file)
      (delete-file git-index-lock-file))))

(defun bmacs/ace-delete-window-dispatch ()
  "Invokes ace-delete window with aw-dispatch-always temporarily set to true"
  (interactive)
  (let ((aw-dispatch-always t))
    (call-interactively #'ace-delete-window)))

(defun bmacs/file-as-string (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

(defun bmacs/set-limit-fill-column ()
  (interactive)
  (let ((column (string-to-number
                 (read-string "Fill Column: "))))
    (when (> column 0)
      (setq-local fill-column 120)
      (visual-line-mode +1)
      (auto-fill-mode -1)
      (visual-fill-column-mode +1))))

(defun bmacs/set-limit-auto-fill-column ()
  (interactive)
  (let ((column (string-to-number
                 (read-string "Fill Column: "))))
    (when (> column 0)
      (setq-local fill-column column)
      (visual-line-mode +1)
      (auto-fill-mode +1)
      (visual-fill-column-mode +1))))

(defun bmacs/disable-all-fill-column ()
  (interactive)
  (visual-line-mode -1)
  (auto-fill-mode -1)
  (visual-fill-column-mode -1))
#+END_SRC

** Keybindings
Whoa Nelly!

#+BEGIN_SRC emacs-lisp
(defmacro +ivy-do-action! (action)
  "A factory function that returns an interactive lamba that sets the current
ivy action and immediately runs it on the current candidate (ending the ivy
session)."
  `(lambda ()
     (interactive)
     (ivy-set-action ,action)
     (setq ivy-exit 'done)
     (exit-minibuffer)))

(defmacro find-file-in! (path &optional project-p)
  "Returns a interactive function for searching files"
  `(lambda () (interactive)
     (let ((default-directory ,path))
       (call-interactively
        ',(if project-p
              (command-remapping 'projectile-find-file)
            (command-remapping 'find-file))))))

(define-key input-decode-map [?\C-i] [C-i])

(map!
 ;; Essential
 "M-x"    #'execute-extended-command
 "M-;"    #'eval-expression
 "M-u"    #'universal-argument
 ;; Tools
 "C-`"    #'bmacs/show-hide-popup-buffer
 "C-~"    (λ! (bmacs/show-hide-popup-buffer t))
 ;; Text-scaling
 "M-0"    (λ! (text-scale-set 0))
 "M-="    #'text-scale-increase
 "M--"    #'text-scale-decrease
 ;; Evil Escape
 [escape] #'bmacs/escape
 ;; Temporary escape into emacs mode
 :e [C-escape] #'evil-normal-state
 :n [C-escape] #'evil-emacs-state
 ;; Indent on tab
 :nvi "TAB"     #'indent-for-tab-command
 ;; Fold toggle
 :nv [C-backspace] #'bmacs/toggle-fold
 :nv [S-backspace] #'hs-hide-level
 :nv [C-S-backspace] #'hs-show-all

  :m ";" #'evil-ex
  (:leader
    ;; common
    :desc "Blink cursor line"                :nv "SPC" #'bmacs/blink-cursor
    :desc "Counsel M-x"                      :nv ":" #'counsel-M-x
    :desc "Eval expr"                        :nv ";" #'eval-expression
    :desc "Run shell command"                :nv "!" #'shell-command
    :desc "Search in project"                :nv "/" #'counsel-projectile-rg
    :desc "Search from here"                 :nv "?" #'counsel-rg
    :desc "Find selection in project"        :nv "*" #'counsel-projectile-rg-region-or-symbol
    :desc "Switch to Emacs mode"             :n "|"  #'evil-emacs-state
    :desc "Switch to last buffer"            :nv "TAB" #'bmacs/alternate-buffer
    :desc "Ace window"                       :nv "W" #'ace-window
    :desc "Pop terminal"                     :nv "'" #'+term/open-popup
    :desc "Pop eshell"                       :nv "`" #'+eshell/popup

    (:desc "file"
      :prefix "f"
      :desc "Open file from here"            :nv "f" #'counsel-find-file
      :desc "Sudo open file from here"       :nv "F" #'bmacs/sudo-find-file
      :desc "Copy file"                      :nv "c" #'copy-file
      :desc "Copy current file"              :nv "C" #'bmacs/copy-file
      :desc "Rename current file"            :nv "R" #'bmacs/rename-current-buffer-file
      :desc "Delete file"                    :nv "d" #'bmacs/delete-file-confirm
      :desc "Delete current file"            :nv "D" #'bmacs/delete-current-buffer-file
      :desc "Sudo edit file"                 :nv "E" #'bmacs/sudo-this-file
      :desc "Recent files"                   :nv "r" #'counsel-recentf
      :desc "Neotree toggle"                 :nv "t" #'neotree-toggle
      :desc "Save buffer"                    :nv "s" #'save-buffer
      :desc "Save all buffers"               :nv "S" #'evil-write-all
      :desc "Counsel bookmark"               :nv "b" #'counsel-bookmark
      :desc "Remote"                         :nv "i" (λ! (counsel-find-file "/"))
      :desc "Cleanup this tramp conn"        :nv "x" #'tramp-cleanup-this-connection
      :desc "Cleanup all tramp conns"        :nv "X" (λ! (tramp-cleanup-all-buffers) (tramp-cleanup-all-connections))
      :desc "Show and copy filename"         :nv "y" #'bmacs/show-and-copy-buffer-filename
      )

    (:desc "buffer"
      :prefix "b"
      :desc "Select entire buffer"           :nv "a" #'mark-whole-buffer
      :desc "Switch workspace buffer"        :nv "b" #'counsel-projectile-switch-to-buffer
      :desc "Switch buffer"                  :nv "B" #'ivy-switch-buffer
      :desc "Kill buffer"                    :nv "d" #'kill-this-buffer
      :desc "Kill other buffers"             :nv "D" (λ! (bmacs/kill-other-buffers t))
      :desc "Kill a buffer"                  :nv "k" #'kill-buffer
      :desc "New empty buffer"               :nv "n" #'evil-buffer-new
      :desc "Scratch buffer"                 :nv "s" #'bmacs/scratch-buffer
      ;; TODO spacemacs/copy-whole-buffer-to-clipboard y
      ;; TODO spacemacs/paste-whole-file-to-clipboard p
      )

    (:desc "ivy"
      :prefix "i"
      :desc "Ivy resume"                    :nv "r" #'ivy-resume)

    (:desc "project"
      :prefix "p"
      :desc "Find file in project"          :nv "f" #'counsel-projectile-find-file
      :desc "Run cmd in project root"       :nv "!" #'projectile-run-shell-command-in-root
      :desc "Toggle project neotree"        :nv "t" #'+neotree/toggle
      :desc "Switch project"                :nv "p" #'counsel-projectile-switch-project
      :desc "Switch project workspace"      :nv "l" #'+workspace-switch-project
      :desc "Kill project buffers"          :nv "k" #'projectile-kill-buffers
      :desc "Recent project files"          :nv "r" #'projectile-recentf
      :desc "Invalidate cache"              :nv "I" #'projectile-invalidate-cache
      :desc "List project tasks"            :nv "a" #'+ivy/tasks
      :desc "Pop term in project root"      :nv "'" #'+term/open-popup-in-project
      :desc "Pop eshell in project root"    :nv "`" #'+eshell/project-popup
      :desc "Project specific bookmarks"    :nv "b" #'counsel-projectile-bookmark)

    (:desc "search"
      :prefix "s"
      :desc "IEdit mode"                    :nv "e" #'evil-iedit-state/iedit-mode
      :desc "Swiper search"                 :nv "s" #'swiper
      :desc "Search online"                 :nv "o" #'+search/online
      :desc "Search online same source"     :nv "O" #'+search/online-use-last)

    (:desc "workspace"
      :prefix "l"
      :desc "Switch to workspace"          :nv "l" #'persp-switch
      :desc "Save workspace state"         :nv "s" #'persp-save-state-to-file
      :desc "Switch last workspace"        :nv "TAB" #'+workspace-switch-last
      :desc "Kill workspace"               :nv "d" #'persp-kill)

    (:desc "window"
      :prefix "w"
      :desc "Split window vertical"        :nv "/" #'split-window-right
      :desc "Split window horizontal"      :nv "-" #'split-window-below
      :desc "Balance windows"              :nv "=" #'balance-windows
      :desc "Delete current window"        :nv "d" #'delete-window
      :desc "Ace delete window"            :nv "D" #'bmacs/ace-delete-window-dispatch
      :desc "Window left"                  :nv "h" #'evil-window-left
      :desc "Window down"                  :nv "j" #'evil-window-down
      :desc "Window right"                 :nv "l" #'evil-window-right
      :desc "Window up"                    :nv "k" #'evil-window-up
      :desc "Move window left"             :nv "H" #'evil-window-move-far-left
      :desc "Move window down"             :nv "J" #'evil-window-move-very-bottom
      :desc "Move window right"            :nv "L" #'evil-window-move-far-right
      :desc "Move window up"               :nv "K" #'evil-window-move-very-top
      :desc "Ace swap window"              :nv "s" #'ace-swap-window
      :desc "Winner undo"                  :nv "u" #'winner-undo
      :desc "Winner redo"                  :nv "U" #'winner-redo
      :desc "Ace window"                   :nv "W" #'ace-window
      :desc "Manage Windows"               :nv "w" #'bmacs-hydra-window/body
      :desc "Toggle maximize window"       :nv "m" #'bmacs/window-zoom)

    (:desc "jump"
      :prefix "j"
      :desc "Go definition"                :nv "q" #'bmacs/jump-definition
      :desc "Go definition other window"   :nv "Q" #'bmacs/jump-definition-other-window
      :desc "Avy go to line"               :nv "l" #'avy-goto-line
      :desc "Avy go to word"               :nv "w" #'evil-avy-goto-word-or-subword-1
      :desc "Avy go to char"               :nv "j" #'avy-goto-char-2
      :desc "Lookup online"                :nv "o" #'+jump/online
      :desc "Lookup online same source"    :nv "O" #'+jump/online-use-last)

    (:desc "git"
      :prefix "g"
      :desc "Git status"                   :nv "s" #'magit-status
      :desc "Git blame"                    :nv "b" #'magit-blame
      :desc "Git time machine"             :nv "t" #'git-timemachine
      :desc "Git log current file"         :nv "f" #'magit-file-popup
      :desc "Git log all"                  :nv "l" #'magit-log-all
      :desc "Smerge Hydra"                 :nv "m" #'bmacs-hydra-smerge/body
      :desc "Show and copy git link"       :nv "y" #'git-link
      :desc "Open git link"                :nv "o" #'bmacs/git-browse
      :desc "Delete git index lock"        :nv "X" #'bmacs/delete-git-index-lock
      (:desc "gist"
        :prefix "g"
        :desc "Gist from buffer"           :nv "b" #'gist-buffer
        :desc "Private gist from buffer"   :nv "B" #'gist-buffer-private
        :desc "Gist from region"           :nv "r" #'gist-region
        :desc "Private gist from region"   :nv "R" #'gist-region-private
        :desc "List gists"                 :nv "l" #'gist-list))

    (:desc "open"
      :prefix "o"
      :desc "Organizer"                    :nv "o" #'+borg/open-organizer
      :desc "Agenda"                       :nv "a" #'org-agenda
      :desc "Org capture"                  :nv "c" #'org-capture
      :desc "Email"                        :nv "e" #'mu4e)

    (:desc "quit"
     :prefix "q"
     :desc "Quit"                          :nv "q" #'evil-save-and-quit)

   (:desc "toggle"
     :prefix "z"
     :desc "Text size increase"            :nv "+" #'text-scale-increase
     :desc "Text size decrease"            :nv "+" #'text-scale-decrease
     :desc "Spell check"                   :nv "s" #'flyspell-mode
     :desc "Line numbers"                  :nv "l" #'doom/toggle-line-numbers
     :desc "Indent guides"                 :nv "i" #'highlight-indentation-mode
     :desc "Indent guides (column)"        :nv "I" #'highlight-indentation-current-column-mode
     :desc "Evil goggles"                  :nv "g" #'+evil-goggles/toggle
     :desc "Visual line wrapping"          :nv "v" #'visual-line-mode
     :desc "Whitespace mode"               :nv "w" #'bmacs/toggle-whitespace)

   (:desc "text"
     :prefix "t"
     :desc "Regular expression builder"    :nv "r" #'regexp-builder
     :desc "Zoom"                          :nv "z" #'bmacs-hydra-text-zoom/body
     (:desc "fill"
       :prefix "f"
       :desc "Limit fill column"           :nv "l" #'bmacs/set-limit-fill-column
       :desc "Auto limit fill column"      :nv "a" #'bmacs/set-limit-fill-column
       :desc "Disable fill column limit"   :nv "d" #'bmacs/disable-all-fill-column)
     (:desc "html"
       :prefix "h"
       :desc "Copy region as html"         :v "y" #'gdoom/htmlize-region-copy))

   (:desc "editor"
     :prefix "e"
     :desc "Select from kill ring"         :n "y" #'counsel-yank-pop
     (:desc "snippets"
       :prefix "s"
       :desc "Insert snippet"              :n "i" #'yas-insert-snippet
       :desc "List all snippets"           :n "l" #'yas-describe-tables))

   (:desc "code"
     :prefix "c"
     :desc "Build"                         :nv "b" #'+eval/build
     :desc "Open/Send to REPL"             :nv "r" #'+eval/repl
     :desc "Open debugger"                 :nv "R" #'+debug/open
     :desc "Counsel dash"                  :nv "d" #'counsel-dash
     :desc "Dash install docset"           :nv "i" #'counsel-dash-install-docset))


 ;; Works when I accidentally use tmux bindings
 (:desc "tmux emulation"
   :prefix "C-b"
   :desc "Window left"                     :nv "h" #'evil-window-left
   :desc "Window down"                     :nv "j" #'evil-window-down
   :desc "Window right"                    :nv "l" #'evil-window-right
   :desc "Window up"                       :nv "k" #'evil-window-up
   :desc "Delete current window"           :nv "x" #'delete-window
   :desc "Split window vertical"           :nv "/" #'split-window-right
   :desc "Split window horizontal"         :nv "-" #'split-window-below)

 ;;; Evil-esque bindings
 ;;; indent on new line
 :i "RET" #'evil-ret-and-indent
 ;; Yank to EOL
 :n  "Y"  "y$"
 ;; Repeat in visual mode (buggy)
 :v  "."  #'evil-repeat
 :v  "<"  #'+evil/visual-dedent     ; vnoremap < <gv
 :v  ">"  #'+evil/visual-indent     ; vnoremap > >gv
 ;; undo/redo for regions (buggy)
 :nv "u"   #'undo-tree-undo
 :nv "C-r" #'undo-tree-redo
 ;; without yank commands
 :n  "c"  #'evil-change-without-register
 :n  "C"  #'evil-change-line-without-register
 :n  "p"  #'evil-paste-after-without-register
 :n  "P"  #'evil-paste-before-without-register
 :n  "x"  #'evil-delete-char-without-register
 :n  "X"  #'evil-delete-backward-char-without-register
 :n  "d"  #'evil-delete-without-register-if-whitespace
 ;; evil little word motions
 :nov "w" #'evil-forward-little-word-begin
 :nov "b" #'evil-backward-little-word-begin
 :nov "e" #'evil-forward-little-word-end
 ;; simple motions
 :nv "H"  #'evil-first-non-blank
 :nv "L"  #'evil-last-non-blank
 ;; search avy goto
 :nv "C-f"  #'avy-goto-char-timer
 ;; evil-commentary
 :n  "gc" #'evil-commentary
 ;; avy goto char
 :n "s"   #'avy-goto-char-2
 :n "S"   #'bmacs/evil-avy-goto-char-2-after-insert
 ;; evil-surround
 :v  "s"  #'evil-surround-region
 :o  "s"  #'evil-surround-edit
 :o  "S"  #'evil-Surround-edit
 ;; expand-region
 :v  "v"  #'er/expand-region
 :v  "V"  #'er/contract-region
 ;; save buffer (but don't close window)
 :n "zz"  #'save-buffer
 :v "J" (concat ":m '>+1" (kbd "RET") "gv=gv")
 :v "K" (concat ":m '<-2" (kbd "RET") "gv=gv")
 :n "K" #'evil-previous-line

 (:map evil-window-map ; prefix "C-w"
   ;; Navigation
   "C-h"     #'evil-window-left
   "C-j"     #'evil-window-down
   "C-k"     #'evil-window-up
   "C-l"     #'evil-window-right
   "C-w"     #'ace-window
   ;; Swapping windows
   "H"       #'+evil/window-move-left
   "J"       #'+evil/window-move-down
   "K"       #'+evil/window-move-up
   "L"       #'+evil/window-move-right
   "C-S-w"   #'ace-swap-window
   ;; Window undo/redo
   "u"       #'winner-undo
   "C-u"     #'winner-undo
   "C-r"     #'winner-redo
   "o"       #'bmacs/window-zoom
   ;; Delete window
   "C-C"     #'ace-delete-window)

 ;; help-mode
 (:map help-mode-map
   :n "q"      #'quit-window
   :n [escape] #'quit-window
   :n "]]"     #'help-go-forward
   :n "[["     #'help-go-back
   :n "o"      #'ace-link-help)

 ;; --- Plugin bindings ------------------------------
 ;; auto-yasnippet
 :i  [C-tab] #'aya-expand
 :nv [C-tab] #'aya-create

 ;; company-mode (+ vim-like omnicompletion)
 :i "C-SPC"  #'+company/complete

 (:after evil-mc
   (:map evil-mc-key-map
     "C-S-j"          #'evil-mc-make-cursor-move-next-line
     "C-S-k"          #'evil-mc-make-cursor-move-prev-line
     [M-down-mouse-1] #'evil-mc-toggle-cursor-on-click))

 (:after company
   (:map company-active-map
     ;; Don't interfere with `evil-delete-backward-word' in insert mode
     "C-w"           nil
     "C-o"           #'company-search-kill-others
     "C-n"           #'company-select-next
     "C-p"           #'company-select-previous
     "C-j"           #'company-select-next
     "C-k"           #'company-select-previous
     "C-h"           #'company-quickhelp-manual-begin
     "C-S-h"         #'company-show-doc-buffer
     "C-S-s"         #'company-search-candidates
     "C-s"           #'company-filter-candidates
     [enter]         #'company-complete-common
     "C-h"           #'company-quickhelp-manual-begin
     "C-g"           #'company-abort
     [tab]           #'company-complete-common-or-cycle
     [backtab]       #'company-select-previous
     [escape]        (λ! (company-abort) (evil-normal-state 1)))
   ;; Automatically applies to `company-filter-map'
   (:map company-search-map
     "C-j"        #'company-search-repeat-forward
     "C-k"        #'company-search-repeat-backward
     "C-s"        (λ! (company-search-abort) (company-filter-candidates))
     [escape]     #'company-search-abort))

 ;; compilation-mode
 (:after compile
   (:map compilation-mode-map
     "SPC" nil
     (:prefix "SPC"
       (:prefix "b"
         "d" #'kill-this-buffer))))

 ;; counsel
 (:after counsel
   :map counsel-ag-map
   [backtab] #'+ivy/wgrep-occur  ; search/replace on results
   "C-SPC"   #'counsel-git-grep-recenter   ; preview
   "M-RET"   (+ivy-do-action! #'+ivy-git-grep-other-window-action))

 (:after eldoc-eval
   (:map eldoc-in-minibuffer-mode-map
     "C-n" #'next-history-element
     "C-p" #'previous-history-element))

 (:after flycheck
   (:map flycheck-error-list-mode-map
     :n "C-n" #'flycheck-error-list-next-error
     :n "C-p" #'flycheck-error-list-previous-error
     :n "j"   #'flycheck-error-list-next-error

     :n "RET" #'flycheck-error-list-goto-error))

 ;; git-timemachine
 (:after git-timemachine
   (:map git-timemachine-mode-map
     :nv "p" #'git-timemachine-show-previous-revision
     :nv "n" #'git-timemachine-show-next-revision
     :nv "g" #'git-timemachine-show-nth-revision
     :nv "q" #'git-timemachine-quit
     :nv "w" #'git-timemachine-kill-abbreviated-revision
     :nv "W" #'git-timemachine-kill-revision
     :nv "b" #'git-timemachine-blame))

 ;; gist
 (:after gist
   (:map gist-list-menu-mode-map
     :n "RET" #'+gist/open-current
     :n "b"   #'gist-browse-current-url
     :n "c"   #'gist-add-buffer
     :n "d"   #'gist-kill-current
     :n "f"   #'gist-fork
     :n "q"   #'quit-window
     :n "r"   #'gist-list-reload
     :n "s"   #'gist-star
     :n "S"   #'gist-unstar
     :n "y"   #'gist-print-current-url))

 ;; ivy
 (:after ivy
   (:map ivy-minibuffer-map
     [escape] #'keyboard-escape-quit
     "C-y" #'yank
     "M-v" #'yank
     "C-v" #'yank
     "M-z" #'undo
     "C-r" #'evil-paste-from-register
     "C-h" (kbd "DEL")
     "C-k" #'ivy-previous-line
     "C-j" #'ivy-next-line
     "C-l" #'ivy-alt-done
     "C-w" #'ivy-backward-kill-word
     "C-u" #'ivy-kill-line
     "C-b" #'backward-word
     "C-f" #'forward-word
     "C-o" #'ivy-dispatching-done
     "<C-return>" #'ivy-immediate-done
     "C-S-h k" #'describe-key
     "C-S-h f" #'describe-function
     "C-S-h v" #'describe-variable)
   (:map ivy-occur-grep-mode-map
     (:desc "ivy occur actions"
       :prefix ","
       :desc "switch to ivy wgrep mode"    :n "," 'ivy-wgrep-change-to-wgrep-mode
       :desc "switch to ivy wgrep mode"    :n "w" 'ivy-wgrep-change-to-wgrep-mode)))

 (:after mu4e
   (:map (mu4e-main-mode-map mu4e-view-mode-map)
     :localleader
     :n "s" #'mu4e-context-switch
     :n "b" #'mu4e-headers-search-bookmark
     :n "B" #'mu4e-headers-search-bookmark-edit
     :n "j" #'mu4e~headers-jump-to-maildir
     :n "/" #'mu4e-headers-search)

   (:map (mu4e-headers-mode-map mu4e-view-mode-map)
     :localleader
     :n "f" #'mu4e-compose-forward
     :n "r" #'mu4e-compose-reply
     :n "c" #'mu4e-compose-new
     :n "e" #'mu4e-compose-edit)

   (:map mu4e-main-mode-map
     :n "J"   #'mu4e~headers-jump-to-maildir
     :n "s"   #'mu4e-headers-search
     :n "q"   #'mu4e-quit
     :n "u"   #'mu4e-update-index
     :n "U"   #'mu4e-update-mail-and-index
     :n "J"   #'mu4e~headers-jump-to-maildir
     :n "c"   #'mu4e-compose-new
     :n "b"   #'mu4e-headers-search-bookmark)

   (:map mu4e-headers-mode-map
     :n "q"   #'mu4e~headers-quit-buffer
     :n "r"   #'mu4e-compose-reply
     :n "c"   #'mu4e-compose-edit
     :n "s"   #'mu4e-headers-search-edit
     :n "S"   #'mu4e-headers-search-narrow
     :n "RET" #'mu4e-headers-view-message
     :n "u"   #'mu4e-headers-mark-for-unmark
     :n "U"   #'mu4e-mark-unmark-all
     :n "v"   #'evil-visual-line
     :nv "d"  #'mu4e-headers-mark-for-delete
     :nv "a"  #'mu4e-headers-mark-for-refile
     :n "x"   #'mu4e-mark-execute-all

     :n "]]"  #'mu4e-headers-next-unread
     :n "[["  #'mu4e-headers-prev-unread

     (:localleader
       :n "s" 'mu4e-headers-change-sorting
       :n "t" 'mu4e-headers-toggle-threading
       :n "r" 'mu4e-headers-toggle-include-related
       :n "a" #'mu4e-headers-action
       :n "%" #'mu4e-headers-mark-pattern
       :n "t" #'mu4e-headers-mark-subthread
       :n "T" #'mu4e-headers-mark-thread
       :n "/" #'mu4e-headers-search-narrow))

   (:map mu4e-view-mode-map
     :n "q" #'mu4e~view-quit-buffer
     :n "r" #'mu4e-compose-reply
     :n "c" #'mu4e-compose-edit
     :n "o" #'ace-link-mu4e
     :n "O" #'mu4e-view-go-to-url
     :n "d"  #'mu4e-view-mark-for-delete
     :n "a"  #'mu4e-view-mark-for-refile

     :n "<M-Left>"  #'mu4e-view-headers-prev
     :n "<M-Right>" #'mu4e-view-headers-next
     :n "[m" #'mu4e-view-headers-prev
     :n "]m" #'mu4e-view-headers-next
     :n "[u" #'mu4e-view-headers-prev-unread
     :n "]u" #'mu4e-view-headers-next-unread

     (:localleader
       :n "%" #'mu4e-view-mark-pattern
       :n "t" #'mu4e-view-mark-subthread
       :n "T" #'mu4e-view-mark-thread
       :n "a" #'mu4e-view-action
       :n "o" #'mu4e-view-open-attachment
       :n "d" #'mu4e-view-mark-for-trash
       :n "r" #'mu4e-view-mark-for-refile
       :n "m" #'mu4e-view-mark-for-move))

   (:map mu4e~update-mail-mode-map
     :n "q" #'mu4e-kill-update-mail))

 ;; neotree
 (:after neotree
   (:map neotree-mode-map
     :n "g"         nil
     :n [tab]       #'neotree-quick-look
     :n "RET"       #'neotree-enter
     :n [backspace] #'evil-window-prev
     :n "j"         #'neotree-next-line
     :n "k"         #'neotree-previous-line
     :n "n"         #'neotree-next-line
     :n "p"         #'neotree-previous-line
     :n "h"         #'+neotree/collapse-or-up
     :n "l"         #'+neotree/expand-or-open
     :n "J"         #'neotree-select-next-sibling-node
     :n "K"         #'neotree-select-previous-sibling-node
     :n "H"         #'neotree-select-up-node
     :n "L"         #'neotree-select-down-node
     :n "c"         #'neotree-create-node
     :n "r"         #'neotree-rename-node
     :n "d"         #'neotree-delete-node
     :n "G"         #'evil-goto-line
     :n "gg"        #'evil-goto-first-line
     :n "v"         #'neotree-enter-vertical-split
     :n "s"         #'neotree-enter-horizontal-split
     :n "q"         #'neotree-hide
     :n "R"         #'neotree-refresh))

 ;; org mode
 (:after org
   (:map org-mode-map
     "RET" #'org-return-indent
     "C-j" nil
     "C-k" nil
     :n "RET" #'+borg/dwim-at-point
     ;; Navigate table cells
     :i  "M-l"   #'+borg/table-next-field
     :i  "M-h"   #'+borg/table-previous-field
     :i  "M-k"   #'+borg/table-previous-row
     :i  "M-j"   #'+borg/table-next-row

     :i  [tab]     #'+borg/indent-or-next-field-or-yas-expand
     :i  [backtab] #'+borg/dedent-or-prev-field

     :nv "j"   #'evil-next-visual-line
     :nv "k"   #'evil-previous-visual-line

     :ni [M-return]   (λ! (+borg/insert-item 'below))
     :ni [S-M-return] (λ! (+borg/insert-item 'above))
     :ni [C-return]   (λ! (+borg/insert-item 'below))
     :ni [S-C-return] (λ! (+borg/insert-item 'above))

     :ni "S-SPC" #'org-cycle

     :n  "C-j"   #'org-next-visible-heading
     :n  "C-k"   #'org-previous-visible-heading
     :niv "C-S-j" #'org-metadown
     :niv "C-S-k" #'org-metaup
     :niv "C-S-h" #'org-metaleft
     :niv "C-S-l" #'org-metaright

     ;; Evil-org
     :niv "M-h" #'+borg/close-subtree-or-ascend-parent
     :niv "M-l" #'+borg/show-subtree-or-descend-child
     :niv "M-k" #'org-previous-visible-heading
     :niv "M-j" #'org-next-visible-heading
     :niv "M-H" #'org-metaleft
     :niv "M-L" #'org-metaright
     :niv "M-K" #'org-metaup
     :niv "M-J" #'org-metadown
     :niv "M-o" '(lambda () (interactive)
                   (evil-org-eol-call
                    '(lambda()
                       (org-insert-heading)
                       (org-metaright))))
     :niv "C-t" '(lambda () (interactive)
                   (evil-org-eol-call
                    '(lambda()
                       (org-insert-todo-heading nil)
                       (org-metaright))))
     :niv "M-t" '(lambda () (interactive)
                   (evil-org-eol-call
                    '(lambda()
                       (org-insert-todo-heading nil)
                       (org-metaright))))

     (:localleader
       :n  "RET" #'org-archive-subtree
       :n  "SPC" #'+borg/toggle-checkbox
       :n  "/"   #'org-sparse-tree
       :n  "="   #'org-align-all-tags
       :n  "?"   #'org-tags-view
       :n  "a"   #'org-agenda
       :n  "d"   #'org-time-stamp
       :n  "D"   #'org-deadline
       :n  "e"   #'org-edit-special
       :n  "E"   #'+borg/edit-special-same-window
       :n  "i"   (lambda () (if (and (boundp 'iimage-mode) iimage-mode) (iimage-mode -1) (iimage-mode +1)))
       :n  "n"   (lambda () (if (buffer-narrowed-p) (widen) (org-narrow-to-subtree)))
       :n  "r"   #'org-refile
       :n  "R"   (lambda () (org-metaleft) (org-archive-to-archive-sibling)) ; archive to parent sibling
       :n  "s"   #'org-schedule
       :n  "t"   #'counsel-org-tag
       :v  "t"   (lambda () (evil-ex-normal evil-visual-beginning evil-visual-end "\\t"))
       :n  "T"   #'org-todo
       :n  "v"   #'variable-pitch-mode
       :nv "l"   #'org-insert-link
       :nv "L"   #'org-store-link
       :n  "+"   #'org-timestamp-up-day
       :n  "-"   #'org-timestamp-down-day)

     :n  "<"   #'org-metaleft
     :n  ">"   #'org-metaright
     :v  "<"   (lambda () (org-metaleft)  (evil-visual-restore))
     :v  ">"   (lambda () (org-metaright) (evil-visual-restore))))

 ;; org agenda
 (:after org-agenda
    (:map org-agenda-mode-map
      :e "<escape>" #'org-agenda-Quit
      :e "m"   #'org-agenda-month-view
      :e "C-j" #'org-agenda-next-item
      :e "C-k" #'org-agenda-previous-item
      :e "C-n" #'org-agenda-next-item
      :e "C-p" #'org-agenda-previous-item))

 ;; realgud
 (:after realgud
   (:map realgud:shortkey-mode-map
     :n "j" #'evil-next-line
     :n "k" #'evil-previous-line
     :n "h" #'evil-backward-char
     :n "l" #'evil-forward-char
     :m "n" #'realgud:cmd-next
     :m "b" #'realgud:cmd-break
     :m "B" #'realgud:cmd-clear
     :n "c" #'realgud:cmd-continue))

 ;; sbt
 (:after sbt
   (:map sbt-mode-map
     :nv "C-d" #'evil-scroll-down))

 ;; comint
 (:after comint
   (:map comint-mode-map
     :nv "C-d" #'evil-scroll-down))

 ;; yasnippet
 (:after yasnippet
   (:map yas-keymap
     [tab]           #'yas-next-field
     "C-e"           #'+snippets/goto-end-of-field
     "C-a"           #'+snippets/goto-start-of-field
     "<M-right>"     #'+snippets/goto-end-of-field
     "<M-left>"      #'+snippets/goto-start-of-field
     "<M-backspace>" #'+snippets/delete-to-start-of-field
     [escape]        #'evil-normal-state
     [backspace]     #'+snippets/delete-backward-char
     [delete]        #'+snippets/delete-forward-char-or-field)
   (:map yas-minor-mode-map
     :i "M-SPC" #'yas-expand)))


;;
;; Keybinding fixes
;;

;; This section is dedicated to "fixing" certain keys so that they behave
;; properly, more like vim, or how I like it.

(map! (:map input-decode-map
        [?\C-i] [C-i]
        [S-iso-lefttab] [backtab]
        (:unless window-system "TAB" [tab])) ; Fix TAB in terminal

      :niv "<C-i>" #'evil-jump-forward

      ;; I want C-a and C-e to be a little smarter. C-a will jump to
      ;; indentation. Pressing it again will send you to the true bol. Same goes
      ;; for C-e, except it will ignore comments and trailing whitespace before
      ;; jumping to eol.
      :i "C-a" #'bmacs/backward-to-bol-or-indent
      :i "C-e" #'bmacs/forward-to-last-non-comment-or-eol
      :i "C-u" #'bmacs/backward-kill-to-bol-and-indent

      ;; textmate-esque newline insertion
      :i [C-return]     #'evil-open-below
      :i [S-C-return]   #'evil-open-above
      ;; textmate-esque deletion
      [C-backspace]     #'bmacs/backward-kill-to-bol-and-indent
      :i [backspace]    #'delete-backward-char
      :i [C-backspace]  #'bmacs/backward-kill-to-bol-and-indent
      ;; Emacsien motions for insert mode
      :i "C-b" #'backward-word
      :i "C-f" #'forward-word

      :i [remap newline]                #'doom/newline-and-indent

      ;; Make ESC quit all the things
      (:map (minibuffer-local-map
             minibuffer-local-ns-map
             minibuffer-local-completion-map
             minibuffer-local-must-match-map
             minibuffer-local-isearch-map)
        [escape] #'abort-recursive-edit
        "C-r" #'evil-paste-from-register)

      (:map messages-buffer-mode-map
        "M-;" #'eval-expression
        "A-;" #'eval-expression)

      (:map tabulated-list-mode-map
        [remap evil-record-macro] #'doom/popup-close-maybe)

      (:map (evil-ex-completion-map evil-ex-search-keymap read-expression-map)
        "C-a" #'move-beginning-of-line
        "C-w" #'doom/minibuffer-kill-word
        "C-u" #'doom/minibuffer-kill-line
        "C-b" #'backward-word
        "C-f" #'forward-word
        "M-z" #'doom/minibuffer-undo)

      (:after view
        (:map view-mode-map "<escape>" #'View-quit-all)))
#+END_SRC

** Post Init

*** Run Post Init Hook

#+BEGIN_SRC emacs-lisp
(run-hooks 'bmacs-post-init-hook)
#+END_SRC

*** Web Browser
Open url links in qutebrowser

#+BEGIN_SRC emacs-lisp
(defun gilbertw1/browse-url (url &optional ignored)
  (interactive (browse-url-interactive-arg "URL: "))
  (call-process "firefox-developer-edition" nil 0 nil url))
(setq browse-url-browser-function #'gilbertw1/browse-url)

(defun gilbertw1/browse-url-new-window (url &optional ignored)
  (call-process "firefox-developer-edition" nil 0 nil "-new-window" url))
(setq dash-docs-browser-func #'gilbertw1/browse-url-new-window)
#+END_SRC

*** Indentation
Set the various indentations

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2
              c-basic-offset 4
              coffee-tab-width 2
              javascript-2-level 2
              js-2-level 2
              js2-basic-offset 2
              web-mode-markup-2-offset 2
              web-mode-css-2-offset 2
              web-mode-code-2-offset 2
              css-2-offset 2
              rust-indent-offset 4)

(add-hook 'js2-mode-hook (lambda ()
                           (setq js2-basic-offset 2)))
#+END_SRC

*** Adjust Fringe

#+BEGIN_SRC emacs-lisp
(fringe-mode '(12 . 12))
#+END_SRC

*** Update Faces

#+BEGIN_SRC emacs-lisp
;; Override vc modified color (gray -> yellow)
(custom-set-faces
  '(diff-hl-change         ((t (:foreground "#ECBE7B"))))
  '(git-gutter:modified    ((t (:foreground "#ECBE7B"))))
  '(git-gutter+-modified   ((t (:foreground "#ECBE7B"))))
  '(git-gutter-fr:modified ((t (:foreground "#ECBE7B")))))

;; Override smerge colors
(custom-set-faces
  '(smerge-refined-removed ((t (:inherit 'smerge-mine))))
  '(smerge-refined-added   ((t (:inherit 'smerge-other)))))

;; Override evil googles colors
(custom-set-faces
 '(evil-goggles-delete-face           ((t (:foreground "#ff6c6b"))))
 '(evil-goggles-paste-face            ((t (:foreground "#98be65"))))
 '(evil-goggles-yank-face             ((t (:foreground "#51afef"))))
 '(evil-goggles-undo-redo-remove-face ((t (:foreground "#ff6c6b"))))
 '(evil-goggles-undo-redo-add-face    ((t (:foreground "#98be65"))))
 '(evil-goggles-undo-redo-change-face ((t (:foreground "#51afef")))))

;; Override org mode colors
(custom-set-faces
 '(org-level-1              ((t :foreground "#51afef" :inherit nil :height 1.2)))
 '(org-level-2              ((t :foreground "#DCAEEA" :inherit nil :height 1.1)))
 '(org-level-3              ((t :foreground "#a9a1e1" :inherit nil :height 1.1)))
 '(org-level-4              ((t :foreground "#ECBE7B" :inherit nil :height 1.1)))
 '(org-level-5              ((t :foreground "#46D9FF" :inherit nil :height 1.1))))
#+END_SRC

*** Mardown Open Comamnd

#+BEGIN_SRC emacs-lisp
(setq markdown-open-command "typora")
#+END_SRC


*** Fix Org Popups

#+BEGIN_SRC emacs-lisp
(after! org
  (defun org-switch-to-buffer-other-window (&rest args)
    (apply #'switch-to-buffer-other-window args)))
#+END_SRC


*** Start profiling (debug)
This is useful to debug slow startups. Off by default

#+BEGIN_SRC emacs-lisp :tangle no
(profiler-start 'cpu)
#+END_SRC
